/*
 * U.S. National Center for Health Statistics
 *
 * eMKF v2.4 30-Jan-2026
 *
 * Suggested citation:
 * Talih M, Patel P, Rossen LM. The enhanced modified Kalman filter (eMKF) tool for small domain estimation 
 * (version 2.4 2026-01-30). National Center for Health Statistics. 2026. https://github.com/CDCgov/eMKF.
 *
 * See the eMKF Guidance Report (DOI: 10.15620/cdc/157496) for background and how to use the SAS eMKF macro.
 *
 *
 * The NCHS eMKF macro expands RAND's MKF macro to:
 *
 *  - [NEW in v2.4] allow for trend break (level shift or full break) at a specified break point.
 *  - [NEW in v2.4] to better accommodate fractional timepoints, restrict AR(1) auto-correlation parameter for random effects to the interval [0,1) instead of (-1,1).
 *  - [NEW in v2.4] implement truncated normal random number generator with PROC FCMP and use truncated normal priors for all AR(1) parameters and hyper-parameters.
 *  - allow for unequally-spaced time points.
 *	- allow for quadratic and cubic trends in both MLE-based and Bayesian estimation settings.
 *  - allow for model averaging over (orthogonal) polynomial trend model sequences up to cubic in both MLE-based and Bayesian settings.
 *  - allow for common as well as group-specific AR parameters rho and tausq for the random effects in the Bayesian setting and [NEW in v2.4] MLE-based setting.
 *  - [NEW in v2.4] added specification for common autocorrelation parameter rho but independent variance parameters tausq by group for the random effects.
 * 	- allow for random sampling variances in the Bayesian setting.
 *  - implement Gibbs sampling in PROC MCMC using user defined samplers (UDSs) that are precompiled with PROC FCMP, replacing .exe file (C code).
 *  - expand calculations of between-group disparities at the latest time point in the Bayesian setting.
 *   
 * See README.md file for additional details on methodological differences between this eMKF version and RAND's MKF.
 *
 * Comments and code inserted for the eMKF version in this file are prefixed with *eMKF or otherwise indicated. 
 * All other comments and code are from the developers of the original MKF macro.
 *
 * Makram Talih, Ph.D.
 * 
 *
 * SAS macros defined in this file are as follows:
 *
 * - MKF (main) .............................................................. line   223
 * - bayesfit (Bayesian estimation workhorse) ................................ line  5843
 * - bayesfitxptl (Bayesian estimation workhorse, level shift case) .......... line  7195
 * - bayesfitxptf (Bayesian estimation workhorse, full trend break) .......... line  8677
 * - bayesBMA (Bayesian model averaging workhorse, via mixture prior) ........ line 10611
 * - bayesBMAxptl (Bayesian model averaging, via mixture prior, level shift) . line 11961
 * - bayesBMAxptf (Bayesian model averaging, via mixture prior, full break) .. line 13408
 * - htrpxptf (ML-based estimation workhorse, full trend break case) ......... line 15373
 * - htrpxptl (ML-based estimation workhorse, level shift case) .............. line 17287
 * - htrp (ML-based estimation workhorse) .................................... line 18867
 * - htrp2d (ML-based estimation workhorse for 2 outcomes) ................... line 20356
 * - reformat (set up of dataset for analysis) ............................... line 22254
 * - reformatXPT (set up of dataset for analysis, trend break case) .......... line 22625
 * - various utility macros: _counts_, zeros, thevacompr, etc. ............... line 23020
 * - gibbs_uds_compile_EP (Gibbs sampler for true state predictions) ......... line 23192
 * - gibbs_uds_compile_RP (Gibbs sampler for random sampling variances) ...... line 23274
 * - gibbs_uds_compile_MP (Gibbs samplers for mean hyper-parameters) ......... line 23311
 * - gibbs_uds_compile_MP_xptl (Mean hyper-parameters, level shift) .......... line 23484
 * - gibbs_uds_compile_MP_xptf (Mean hyper-parameters, full trend break) ..... line 23658
 * - gibbs_uds_compile_CP (Gibbs samplers for regression coefficients) ....... line 24212
 * - gibbs_uds_compile_CP_xptl (Regression coefficients, level shift) ........ line 26354
 * - gibbs_uds_compile_CP_xptf (Regression coefficients, full trend break) ... line 28563
 * - gibbs_uds_compile_FP (Gibbs samplers for model flags) ................... line 34068
 * - gibbs_uds_compile_FP_xptl (Gibbs samplers for model flags, level shift) . line 35285
 * - gibbs_uds_compile_FP_xptf (Gibbs samplers for model flags, full break) .. line 36515
 * - gibbs_uds_compile_TNORM (Truncated normal) .............................. line 40237
 *
 */

/* eMFK v2.4: this is the default, but (re)setting here, in case mkf was interrupted (e.g., due to an error) before reaching the macro end */
options notes; 

data _null_;
run;

/* MKF macro + eMKF expansion in 2023 Q1-Q2 by M. Talih + expanded in 2025 Q1-Q2 to allow for trend break specification (eMKF v2.4)
Macro defined 03-16-2007, Revised 05-08-09 D. McCaffrey. Revised 03-15-2010 [RAND Statistics Group]
It allows for the estimation of parameters from the non-linear mixed effect model.
In addition it allows for the estimation of model averaging as well as Bayesian estimates

1- Printing (modified for eMKF)

modelprint  : YES will print the proc nlmixed and/or proc mcmc results and NO will not. Default is NO.
finalprint  : YES will print MKF estimates for last time point at the end of the estimations and NO will not. Default is YES.

2- data and variables (eMKF v2.4 streamlining: "format 2" is the only supported option)

data 		: name of the dataset. Must be in long/stacked format ("format 2" in previous versions of the macro)
outcome 	: the outcome of interest (data "format 2")
se      	: the standard error of the outcome (data "format 2")
neff		: (eMKF) (Effective) sample sizes of the outcomes for the random sampling variance case in the Bayesian model
		  	  If empty, but random sampling variances are requested, an error is returned. Ignored in the MLE-based models.
time    	: the time variable (data "format 2")
by      	: allows models to run for multiple strata at the same time and can be used for simulations
group   	: the different groups (e.g., race/ethnicity group) variable
breakPoint  : [New in eMKF v2.4] specifies value of timepoint at which trend break occurs, if any (default is none).
breakType   : [New in eMKF v2.4] indicates whether trend break impacts intercepts only (level_break or <empty> [default]), or all regression coefficients (full_break).

3- Modeling option: The linear mixed model

slopes : the type of slope one needs: eMKF options are the following:

         indep_cubic	: The values of the parameters b1, b2, and b3 are computed for each group
         indep_quad		: b3=0. The values of the parameters b1 and b2 are computed for each group
         indep_linear   : b3=0 and b2=0. The value of the slope b1 is computed for each group
         common_cubic	: The values of each of the parameters b1, b2, and b3 are assumed to be the same across groups
         common_quad	: b3=0. The values of each of the parameters b1 and b2 are assumed to be the same across groups
         common_linear  : b3=0 and b2=0. The value of the slope b1 is assumed to be the same across groups
         dropped    	: A model without time trend is computed (b3=0, b2=0, b1=0).
         (empty)		: DEFAULT when using one outcome -- results in Bayesian approach only.

         eMKF: the number of time points will be checked and an error returned if:
	  	  * Cubic trend is requested when there are less than 5 time points
	  	  * Quadratic trend is requested when there are less than 4 time points
	  	  * Linear trend is requested when there are less than 3 time points
	  	  * There are less than 2 time points

         If multiple options are selected, model averaging is computed using those options
           * eMKF: When using two outcomes, DEFAULT is model average over all models up to cubic.
           * eMKF: Combinations will be checked to ensure a common reference (shared descendent) model for the Bayes factor calculations.
		  	** If both indep_quad and common_cubic are selected, then common_quad will be added if needed.
		  	** If both indep_linear and common_cubic are selected, then common_linear will be added if needed.
		  	** If both indep_linear and common_quad are selected, then common_linear will be added if needed.

4- Modeling option: The Bayesian model

Bayesmodel : This is the Bayesian model one wants to fit. eMKF options are the following:

		bma_cubic     : (eMKF v2.4: DEFAULT with no trend break) Bayesian model averaging implemented using a mixture of polynomial trend models up to unconstrained cubic.
		bma_quad	  : Bayesian model averaging implemented using a mixture of polynomial trend models up to unconstrained quadratic.
		bma_linear    : (eMKF v2.4: DEFAULT with trend break) Bayesian model averaging implemented using a mixture of polynomial trend models up to unconstrained linear.
        full_cubic 	  : Fully Bayesian cubic trends. The b1s, b2s, and b3s are independent draws from multilevel priors.
        full_quad 	  : Fully Bayesian quadratic trends. Here, b3s are 0, and b1s and b2s are independent draws from multilevel priors.
        full_linear   : Fully Bayesian linear trends. Here, b3s and b2s are 0, and b1s are independent draws from a multilevel prior.
        indep_cubic	  : Bayesian cubic trends. The b1s, b2s, and b3s are independent draws from uninformative (flat) priors.
        indep_quad	  : Bayesian quadratic trends. Here, b3s are 0 and b1s and b2s are independent draws from uninformative (flat) priors.
        indep_linear  : Bayesian linear trends. Here, b3s and b2s are 0, and b1s are independent draws from an uninformative (flat) prior.
        common_cubic  : Bayesian model with common cubic trend. The common b1, b2, and b3 are each drawn from an uninformative (flat) prior.
        common_quad	  : Bayesian model with common quadratic trend. b3=0 and the common b1 and b2 are each drawn from an uninformative (flat) prior.
        common_linear : Bayesian model with common linear trend. b3=0, b2=0, and the common b1 is drawn from an uninformative (flat) prior.
        dropped    	  : Bayesian model with no time trend is computed (b3=0, b2=0, b1=0).

BayesmodelAvg :	(eMKF) If multiple options are selected in Bayesmodel and BayesmodelAvg = NO or empty, 
				all selected models are included in the output datasets. 
			 	However, only the last model in the specified sequence is used for printing the MKF estimates for last time point.
 			 	If BayesmodelAvg = YES (DEFAULT) and more than one model is specified, then model averaging up to the largest 
				unconstrained polynomial trend that was listed is conducted.

ARmodel : If common_ar (default), groups will share AR(1) parameters rho and tausq.
		  If common_arh (new in eMKF v2.4), each group will have its own variance parameter tausq, but share a common autocorrelation coefficient rho. 
		  If indep_ar, each group will have its own set of stationary AR(1) parameters rho and tausq, drawn from a common prior distribution. 

randomVars : (eMKF) Default is YES. 
			 Sampling variances will be treated as scaled chi-squared random variables with an inverse gamma prior. 

5- Output prefix (modified for eMKF)

out     : The name for the output prefix. Default is param. 
		  Outputs (prefix + suffix) are saved. Here are some of the relevant suffixes:
           _pred    : Kalman prediction of the outcome of interest includes original values as well as parameters
           _bayes   : Kalman prediction of the outcome from bayesian modeling
         (e.g., for OUT=param then PARAM_PRED will be the Kalman prediction data of the outcome of interest.)

nlmixedDetails: (eMKF v2.4 streamlining) (default = NO) to omit model datasets with fit details/statistics and retain only predictions and regression coefficients
xtrakeep	  : Any variable one wants to keep in the data while running models: weights, ... (eMKF: could be used to retain labels for multiyear data)
comparedata, comparedto  : (eMKF) options from MKF allowing for estimating disparities/differences in Bayesian setting

6- Parameters that should only be changed by experienced users (modified for eMKF)

 pdigit	: Number of decimal digits for the printed outputs. Default is set to 4.

 MLE-based model parameters (eMKF: passed on to proc nlmixed)
 			 		 (eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied -- they are estimated instead)

 nlmixedDF  : Non-linear model degrees of freedom. The default is set pretty high at 1,0000
 nlmixedTech: (eMFK v2.4 streamlining) (defaults to NEWRAP for one outcome, and QUANEW for two) -- gives user control over choice of optimization algorithm for MLE

 Bayes model parameters (eMKF: passed on to proc mcmc)

 chains   			: number of chains to run for the Bayesian estimation. Default is 4, as per Vehtari et al (2021; DOI 10.1214/20-BA1221)
 GRthreshold		: threshold to use for Gelman-Rubin convergence diagnostic, usually no larger than 1.1. Default is 1.01, as per Vehtari et al.
 mcmcplot			: if YES, within-chain trace/diagnostics plots from proc mcmc will be included (default is NO)
 mcmclog   			: if YES, the full posterior samples will be retained in the work directory (default is NO, as dataset will be large)
 seed     			: random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 maxtune			: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 ntu				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 nbi	 			: number of burn-in in MCMC iterations (if empty, proc mcmc default of 1000 is used; if 0, burn-in will be skipped)
 nmc	 			: number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 thin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 accepttol			: tolerance for target acceptance probabilities (targetaccept +|- accepttol). If empty, proc mcmc defaults are used.
 targetaccept		: target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used (see proc mcmc documentation). 
 propcov			: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation).
					  If empty, proc mcmc default of IND will be used.
 init				: Option for generating initial values for the parameters. If empty, proc mcmc defaults to MODE (see proc mcmc documentation).
					  eMKF default is REINIT, which resets model parameters to the user-supplied initial values after tuning. 
 slicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling steps. 
					  Default is NO due to heavier computational load.
 checkSampleSize	: YES (default) to check sample size is large enough before proceeding. Set to NO to replicate earlier MKF from RAND.
 orpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior parameters below are assumed to be for the coefficients of the orthogonal polynomial regression if orpoly=YES.

 ******************** New in eMKF v2.4 for all regression-related parameters: user can optionally specify separate values for segment 2 in trend break scenarios
 malpha, s2malpha 	: prior mean for intercepts
 palpha, s2palpha 	: prior precision for intercepts 
 mbeta1, s2mbeta1	: prior mean for mean linear coefficient(s) across groups
 pbeta1, s2pbeta1 	: prior precision for mean linear coefficient(s) across groups
 mbeta2, s2mbeta2 	: prior mean for mean quadratic coefficient(s) across groups
 pbeta2, s2pbeta2	: prior precision for mean quadratic coefficient(s) across groups
 mbeta3, s2mbeta3 	: prior mean for mean cubic coefficient(s) across groups
 pbeta3, s2pbeta3	: prior precision for mean cubic coefficient(s) across groups
 beta1l, beta1u		: bounds for Unif(a,b) prior for SD of linear coefficients across groups -- used for hyperprior(s) in all 3 full_ models
 s2beta1l, s2beta1u	: bounds for Unif(a,b) prior for SD of linear coefficients across groups -- used for hyperprior(s) in all 3 full_ models [segment 2]
 beta2l, beta2u		: bounds for Unif(a,b) prior for SD of quadratic coefficients across groups -- used for hyperprior(s) in full_cubic or full_quad
 s2beta2l, s2beta2u	: bounds for Unif(a,b) prior for SD of quadratic coefficients across groups -- used for hyperprior(s) in full_cubic or full_quad [segment 2]
 beta3l, beta3u		: bounds for Unif(a,b) prior for SD of cubic coefficients across groups -- used for hyperprior(s) in full_cubic
 s2beta3l, s2beta3u	: bounds for Unif(a,b) prior for SD of cubic coefficients across groups -- used for hyperprior(s) in full_cubic [segment 2]
 ********************
 mrho, prho			: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 taul, tauu			: bounds for Unif(a,b) prior for tau (SD of innovation variance tausq)
 vshape, vscale		: Shape and scale parameters for inverse gamma prior distribution of the variance when randomVars = YES
 wdirichlet			: [eMKF v2.4 streamlining] Whether to use the Dirichlet prior for model weights (default = NO) -- not fully tested yet
 wshape				: Common shape parameter to use for Dirichlet prior on model indicators in mixture priors (default = 2)
 saslognotes		: [new in eMKF v2.4] = YES or <empty> to include and = NO to turn off SAS notes in log file. Warnings and error messages are kept. Default is NO.
 cmploc				: Desired location of CMP library (sasuser.funcs or work.funcs if sasuser is write-protected)
*/
%macro mkf(	data			= , 
           	outcome			= , 
            se				= , 
			neff 			= ,
		 	outcome2		= , 
            se2				= , 
			neff2 			= ,
		    by				= ,  
            group			= , 
            time			= ,
			breakPoint		= ,
			breakType		= , /* eMKF v2.4: unless breakType is specifically set to full_break, it will default to level_break */
            slopes			= ,
			Bayesmodel		= , /* eMKF v2.4: changed to empty: when slopes = <empty>, this will default to bma_cubic when breakPoint = <empty> and bma_linear otherwise */
			BayesmodelAvg 	= YES,
			randomVars		= YES,
			ARmodel			= common_ar,
            xtrakeep		= ,
            out				= param, 
			nlmixedDetails	= NO,
			comparedto		= ,
			comparedata		= ,
            modelprint 		= NO,
            finalprint 		= YES,
  		/* eMKF: The parameters from here down should not be modified unless the user really knows what they are doing*/
			pdigit 			= 4,
            nlmixedDF 		= 10000, 			 
			nlmixedTech		= ,
			chains  		= 4 ,
			GRthreshold 	= 1.01,
			seed			= 1235,
			maxtune			= 50,
			ntu				= 1000,
			nbi				= 10000,
			nmc				= 50000,
			thin			= 1,			
			accepttol		= ,	 
			targetaccept	= ,
			propcov  		= ,
			init 			= reinit,
			slicesampler 	= NO,
			checkSampleSize	= YES,
			orpoly 			= YES,
  		/* eMKF: If parameters below are empty, the data will be used to inform the starting values */
		/* eMKF v2.4: User can also specify regression related parameters in the Bayesian setting for segment 2 if applicable */
			malpha 			= ,  palpha 	= , 
			s2malpha 		= ,  s2palpha 	= , 
			mbeta1  		= 0, pbeta1  	= , 
			s2mbeta1  		= 0, s2pbeta1  	= , 
			mbeta2  		= 0, pbeta2  	= , 
			s2mbeta2  		= 0, s2pbeta2  	= , 
			mbeta3  		= 0, pbeta3  	= , 
			s2mbeta3  		= 0, s2pbeta3  	= , 
			beta1l  		= 0, beta1u  	= , 
			s2beta1l  		= 0, s2beta1u  	= , 
			beta2l  		= 0, beta2u  	= ,
			s2beta2l  		= 0, s2beta2u  	= ,
			beta3l  		= 0, beta3u  	= , 
			s2beta3l  		= 0, s2beta3u  	= , 
			mrho   			= 0, prho   	= 1,
			taul   			= 0.0001, tauu  = ,
			vshape 			= ,  vscale 	= ,
			wdirichlet		= NO, wshape    = 2,
			mcmcplot 		= NO, mcmclog 	= NO,
			saslognotes		= NO,
			cmploc 			= work.funcs
            ) / minoperator; /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local uvar ui Bayesian _ssby _oo1_ _oo2_ _thet _thekeeps _thekeepsb _thekeep1 _thekeep1b _thekeep2 _thekeep3 _ssn run1 run2 run3 ug un uns1 uns2
       s2uvar toprint2 uj emkfkeep emkfrename newuvar s2newvar s22uvar xtrakeep22 flag1 flag2 flag3 flag4 flag5 flag6 flag7 _slopes
	   uii flag1f flag2f flag3f flag1a flag2a flag3a _BMAmodel toprint crep uk _chainseed _idf _jdf _igrp_ _t_ _comp2 uloc
	   s2flag1 s2flag2 s2flag3 s2flag4 s2flag5 s2flag6 s2flag7 s2flag1f s2flag2f s2flag3f s2flag1a s2flag2a s2flag3a;

/* eMFK v2.4 streamlining: added option to suppress notes being written to log (put statements, warnings and errors will still appear) */
%if &saslognotes = %str() %then %let saslognotes = YES;
%if %upcase(&saslognotes) ^= YES %then %do;
	%put ;
	%put SAS log notes are suppressed by default (warnings and errors will still appear).;
	options nonotes;
%end;
%else %do; /* eMFK v2.4: this is the default, but resetting here, in case mkf was interupted (e.g., due to an error) before reaching the macro end */
	options notes; 
%end;

/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
%put ;
%put MKF macro is currently checking the data (this could take a while).;

/* eMKF: Added error check for the length of &out prefix */
%if &out = %str() or %length(&out) > 16 %then %do;
	%put ERROR: Please specify a non-empty prefix in out= that is no longer than 16 characters.;
	proc iml;
		print "  Error Note:";
		print "  Please specify a non-empty prefix in out= that is no longer than 16 characters.";
	quit;
	%return;
%end;

/* eMKF: Added error check for the length of &outcome variable name */
%if &outcome = %str() or %length(&outcome) > 18 %then %do;
	%put ERROR: Please specify a non-empty variable name in outcome= that is no longer than 18 characters.;
	proc iml;
		print "  Error Note:";
		print "  Please specify a non-empty variable name in outcome= that is no longer than 18 characters.";
	quit;
	%return;
%end;

/* eMKF: Added error check for the length of &outcome2 variable name (if applicable) */
%if &outcome2 ^= %str() and %length(&outcome2) > 18 %then %do;
	%put ERROR: Please specify a variable name in outcome2= that is no longer than 18 characters.;
	proc iml;
		print "  Error Note:";
		print "  Please specify a variable name in outcome2= that is no longer than 18 characters.";
	quit;
	%return;
%end;

/* eMKF v2.4 streamlining: Added error check to rule out "format 1" used in previous versions of the macro */
%if %scan(&outcome,2) ^= %str() or %scan(&se,2) ^=%str() or %scan(&outcome2,2) ^= %str() or %scan(&se2,2) ^=%str() or &time = %str() %then %do;
	%put ERROR: Format 1 is no longer supported.;
	%put ERROR- Please ensure data are in long (stacked) format and the time variable is specified!;
	proc iml;
		print "  Error Note:";
		print "  Format 1 is no longer supported.";
		print "  Please ensure data are in long (stacked) format and the time variable is specified!";
	quit;
	%return;
%end;

/* eMKF v2.4: trend break estimation not yet implemented for two outcomes--use model with no trend break instead */
%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	%if &breakPoint ^= %str() %then %let breakPoint = ;
	%put WARNING: Trend break estimation is not yet implemented for two outcomes.;
	%put WARNING- Using model with no break in trend.;
%end;

/* eMKF v2.4: default to level_break if unspecified, and check for mispellings/misspecification */
%if &breakPoint ^= %str() %then %do;
	%if &breakType = %str() %then %let breakType = level_break;
	%if not(%upcase(&breakType) in LEVEL_BREAK FULL_BREAK) %then %do;
		%put ERROR: breakType=&breakType is not a supported specification.; 
	    %put ERROR- breakType must be either level_break for an intercept-only shift or full_break otherwise.;
		proc iml;
			print "  Error Note:";
			print "  breakType=&breakType is not a supported specification.";
	        print "  breakType must be either level_break for an intercept-only shift or full_break otherwise.";
		quit;
		%return;
	%end;
%end;

/* eMKF v2.4: set breakType to empty string if no breakpoint is requested */
%if &breakPoint = %str() and &breakType ^= %str() %then %let breakType = ;

/* eMKF v2.4: Added warning and default bma models if both slopes and bayesmodel are empty */
%if &Bayesmodel = %str() and &slopes = %str() %then %do;
	%put WARNING: Because no estimation method was specified, MKF will use Bayesian model averaging;
	%if &breakPoint = %str() %then %do;
		%let Bayesmodel = bma_cubic;
		%put WARNING- over a mixture of polynomial trend models up to the unconstrained cubic.;
	%end;
	%else %do;
		%let Bayesmodel = bma_linear;
		%put WARNING- over a mixture of polynomial trend models up to the unconstrained linear.;
	%end;
%end;

/* eMKF v2.4: Added check for any mispellings/misspecification of the AR(1) model */
%if not(%upcase(&ARmodel) in COMMON_AR COMMON_ARH INDEP_AR) %then %do;
	%put ERROR: ARmodel=&ARmodel is not a supported AR(1) model specification.; 
    %put ERROR- AR(1) model must be one of common_ar, common_arh, or indep_ar.;
	proc iml;
		print "  Error Note:";
		print "  ARmodel=&ARmodel is not a supported AR(1) model specification.";
        print "  AR(1) model must be one of common_ar, common_arh, or indep_ar.";
	quit;
	%return;
%end;

/* eMKF: Check for any mispellings/misspecification of the model(s) */
%if &slopes ^= %str() %then %do;
	%let uvar=; %let ui=0;
    %do ui=1 %to %_counts_(&slopes);
		%let uvar=%scan(&slopes, &ui);
		%if not(%upcase(&uvar) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
			%put ERROR: &uvar is not a supported ML model specification.; 
            %put ERROR- Model(s) must be one (or more) of indep_cubic, indep_quad, indep_linear, ;
			%put ERROR- common_cubic, common_quad, common_linear, or dropped.;
			proc iml;
				print "  Error Note:";
				print "  Specified ML model(s) not supported.";
                print "  Model(s) must be one (or more) of indep_cubic, indep_quad, indep_linear, ";
			    print "  common_cubic, common_quad, common_linear, or dropped.";
			quit;
			%return;
		%end;
		%let uvar=;
	%end;
%end;

/* eMKF: Bayesian modeling flag and check for any mispellings/misspecification of the model(s) */
%let Bayesian=;
%if &Bayesmodel ^=%str() %then %do;
	%let Bayesian= Yes; %let uvar=; %let ui=0;
    %do ui=1 %to %_counts_(&Bayesmodel);
		%let uvar=%scan(&Bayesmodel, &ui);
		%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR FULL_CUBIC FULL_QUAD FULL_LINEAR 
								  INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
			%put ERROR: &uvar is not a supported Bayesian model specification.;
            %put ERROR- Model(s) must be one (or more) of bma_cubic, bma_quad, bma_linear, full_cubic, full_quad, full_linear, ;
			%put ERROR- indep_cubic, indep_quad, indep_linear, common_cubic, common_quad, common_linear, or dropped.;
			proc iml;
				print "  Error Note:";
				print "  Specified Bayesian model(s) not supported."; 
                print "  Model(s) must be one (or more) of bma_cubic, bma_quad, bma_linear, full_cubic, full_quad, full_linear, ";
				print "  indep_cubic, indep_quad, indep_linear, common_cubic, common_quad, common_linear, or dropped. ";
			quit;
			%return;
		%end;
		%let uvar=;
	%end;
%end;
%else %let Bayesian = No; /* eMKF: Added to allow for Bayes approach to be explicitly disabled */

/* eMKF: Set up internal &by variable name _reps, e.g., for use in calls to HTRP and HTRP2D */
%let _ssby=; %if &by ^=%str() %then %let _ssby=_reps;

/* eMKF: Set up dataset name for differences/disparities if requested */
%if &comparedata = %str() and &comparedto ^= %str() %then %let comparedata = &out._diff;

/* eMKF v2.4 correction: deals with case when comparedata is specified but comparedto is not  */
%if &comparedata ^= %str() and &comparedto = %str() %then %let comparedto = unspecified;

/* eMKF v2.4: Set up internal names for the outcome(s) variable(s) */
%let _oo1_=; %if &outcome  ^=%str() %then %let _oo1_=&outcome;
%let _oo2_=; %if &outcome2 ^=%str() %then %let _oo2_=&outcome2;

/* eMKF v2.4: Initialize macro variables for use in symbolic calculations/operations */
%let _thet=; %let _thekeeps=; %let _thekeepsb=; %let _thekeep1=; %let _thekeep1b=; %let _thekeep3=;
%let _thekeep2= &by &group &time; 
%if &outcome2 =%str() or &se2 =%str() %then %do; /* eMKF v2.4: one outcome */
	%let _thekeep2 = &_thekeep2 &outcome &se;
	%if &by ^=%str() %then %let _thekeep3= &_thekeep3 &out.(keep= &by);
	%let _thekeep3= &_thekeep3 &out.(keep= &group) &out.(keep= &time);
	%let _thekeep3= &_thekeep3 &out.(keep= &outcome) &out.(keep= &se);
%end;
%else %do; /* eMKF v2.4: two outcomes */
	%let _thekeep2 = &_thekeep2 &outcome &se &outcome2 &se2;
	%if &by ^=%str() %then %let _thekeep3= &_thekeep3 &out.(keep= &by);
	%let _thekeep3= &_thekeep3 &out.(keep= &group) &out.(keep= &time);
	%let _thekeep3= &_thekeep3 &out.(keep= &outcome) &out.(keep= &se) &out.(keep= &outcome2) &out.(keep= &se2);
%end;

/* eMKF: Bayesian estimation not yet implemented for two outcomes--use MLE-based estimation instead */
%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	%let Bayesian= NO; %let Bayesmodel= ;
	/* eMKF: If slopes parameter is unspecified, default to MA up to cubic */
	/* eMFK v2.4 streamlining: added warning to log file */
	%if &slopes=%str() %then %let slopes= indep_cubic common_cubic indep_quad common_quad indep_linear common_linear dropped;
	%put WARNING: Bayesian estimation not yet implemented for two outcomes.;
	%put WARNING- Using ML-based estimation instead, with model averaging across the following:;
	%put WARNING- &slopes.;
%end; 

/* eMKF v2.4: default options for optimization algorithm to use in proc nlmixed when ML estimation is requested */
%if &nlmixedTech = %str() and %upcase(&Bayesian) ^= YES %then %do;
	%let nlmixedTech = NEWRAP; 	/* eMKF v2.4: Try for second-order optimization algorithm in proc nlmixed */
	%if &outcome2 ^= %str() and &se2 ^=%str() %then %let nlmixedTech = QUANEW; /* eMKF v2.4: Use proc nlmixed default for 2 outcomes */
%end;

/******************************************************/
/* eMKF: Reformat the data only once at the top level */
/******************************************************/
data _bayesdata_ ;
run;

/* eMKF: macro variable &_ssn will be used in call to bayesfit to indicate generic variable name for neff */
%let _ssn = ;

/* eMKF: reformat data if needed and calculate variables needed for processing */
/* eMKF v2.4: added functionality for single breakpoint specification */
%if %upcase(&Bayesian) = YES and %upcase(&randomVars) = YES %then %do;
	%if &neff = %str() %then %do; /* eMKF: if no effective sample sizes were provided, return an error */
		%put ERROR: (Effective) sample sizes neff must be specified to fit random sampling variances.;
		proc iml;
			print "  Error Note:";
			print "  (Effective) sample sizes neff must be specified to fit random sampling variances.";
		quit;
		%return;
	%end;
	%if &breakPoint ^= %str() %then %do;
		%reformatXPT(data=&data, outcome=&outcome, se=&se, neff=&neff, outcome2=&outcome2, se2=&se2, neff2=&neff2,
				     group=&group, time=&time, xpt=&breakPoint, by=&by, randomVars=YES, outformat= _bayesdata_ );
	%end;
	%else %do; 
		%reformat(data=&data, outcome=&outcome, se=&se, neff=&neff, outcome2=&outcome2, se2=&se2, neff2=&neff2, 
				  group=&group, time=&time, by=&by, randomVars=YES, outformat= _bayesdata_ );
	%end;
	%let _ssn = _n; 
%end;
%else %do;
	/* eMKF: Ignore effective samples sizes if random variances not requested in Bayesian setting, or for MLE-based estimation */
	%if &breakPoint ^= %str() %then %do;
		%reformatXPT(data=&data, outcome=&outcome, se=&se, outcome2=&outcome2, se2=&se2,
				     group=&group, time=&time, xpt=&breakPoint, by=&by, randomVars=NO, outformat= _bayesdata_ );
	%end;
	%else %do; 
		%reformat(data=&data, outcome=&outcome, se=&se, outcome2=&outcome2, se2=&se2,
				  group=&group, time=&time, by=&by, randomVars=NO, outformat= _bayesdata_ );
	%end;
	%let randomVars = NO;
%end;

proc sort data= _bayesdata_;
  by &by _group_ _time ;
run;

/* eMKF: Note that _nlmixdata_ (formerly _bayesdata00_) has renamed variables */
/* eMKF: Added columns with new variables instead of re-naming, as original MKF code was re-creating generic variables _y, _time, etc. */

/* eMKF: Create copies of _group_ and _rep variables for use in proc iml matrix calculations */
%if %upcase(&Bayesian) ^= YES %then %do;
    data _nlmixdata_; 
      set _bayesdata_; 
      _groupnum = _group_; 
      %if &by ^=%str() %then _reps = _rep;; 
    run;
%end;

/* eMKF: Datasets to check number of time points and groups are consistent within and across strata */
data _junk_ _freq1_ _freq2_ _freq3_;
run;

/* eMKF: Original RAND macro assumed < 10 groups and timepoints at this point in the code. Here, we do away with this assumption. */
data _junk_;
  set _bayesdata_;
  /* eMKF v2.4 correction: reintroduced _name_ variable (which was in RAND's original version), with added hyphen separator */
  _name_= compress(_rep || "-" ||  _group_ || "-" || _time);
  if _y=. then delete;
  if _se=. then delete;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _y2=.  then delete;;;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _se2=. then delete;;;
run;
proc freq data=_junk_ noprint;
  tables _group_ /list out=_freq1_(rename=(count=ntime));
  %if &by ^=%str() %then by &by;;
run;
proc freq data=_junk_ noprint;
  tables _time /list out=_freq2_(rename=(count=ngroup));
  %if &by ^=%str() %then by &by;;
run;

/* eMKF: added if-clause to avoid creating dataset _finalprint_ if it remains unused */
%if %upcase(&finalprint) = YES %then %do; 
	options formchar="|----|+|---+=|-/\<>*"; /* eMKF: system options for correct SAS monospace font in printed tables*/
	data _finalprint_;
	  set _freq2_;
	  _rp_=1;
	run;
	data _finalprint_;
	  set _finalprint_;
	  keep=0;
	  %if &by ^=%str() %then by &by _time;;
	  %if &by  =%str() %then by _rp_ _time;;
	  %if &by ^=%str() %then if last.&by and last._time then keep=1;;;
	  %if &by  =%str() %then if last._rp_ and last._time then keep=1;;;
	  drop _rp_;
	run;
	data _finalprint_;
	  set _finalprint_;
	  if keep=1;
	  keep &by _time;
	run;
%end;

proc sort data=_freq1_ nodupkey;
  by &by ntime;
run;
proc sort data=_freq2_ nodupkey;
  by &by ngroup;
run;
data _freq1_;
  merge _freq1_ _freq2_;
  %if &by ^=%str() %then by &by;;
  drop _group_ _time percent;
run;
data _freq1_;
  set _freq1_;
  %if &by ^=%str() %then by &by;;
  %if &by ^=%str() %then if first.&by then id =0;;;
  stop=0;
  id +1;
run;
data _freq2_;
  set _freq1_;
  if id=1;
run;
data _freq1_;
  set _freq1_;
  stop=1;
  if id=2;
run;
proc sort data= _freq1_ nodupkey;
  by &by id;
run;
data _freq2_;
  merge _freq2_ _freq1_(drop=id);
  %if &by ^=%str() %then by &by;;
run;

%let run1=0; %let run2=0;
data _null_;
  set _freq2_;
  one=1;
  if stop = 1 then call symput("run1" , stop);
  if stop ne 1 then call symput("run2" , one);
run;
%let run1= %eval(&run1 +0); %let run2= %eval(&run2 +0);

/* eMKF v2.4 correction: Added check to ensure any &by variables were not omitted when in fact data are stratified (as in RAND's version of the macro) */
%if &run1=0 %then %do;
	proc sort data=_junk_;
	  by _name_;
	run;
	data _junk_;
	  set _junk_;
	  by _name_;
	  if first._name_ then _id=0;
	  _id+1;
	  _one=1;
	  if _id =2 then  call symput("run1" , _one);
	run;
	%let run1= %eval(&run1 +0);
%end;

/* eMKF: Precaution to ensure groups and timepoints are consistent across &by strata */
%if &by ^= %str() and &run1 = 0 %then %do;
  %let run3 = 0;
  proc freq data=_freq2_ noprint;
    tables ngroup /list out=_freq3_;
  run;
  data _freq3_;
	set _freq3_;
	stop = 0;
	_ng_ + 1;
    if _ng_ > 1 then stop = 1;
	call symput("run3", stop);
  run;
  %let run3= %eval(&run3 +0);
  %if &run3 = 0 %then %do;
    proc freq data=_freq2_ noprint;
      tables ntime /list out=_freq3_;
    run;
    data _freq3_;
	  set _freq3_;
	  stop = 0;
	  _nt_ + 1;
	  if _nt_ > 1 then stop = 1;
	  call symput("run3", stop);
    run;
  %end;
  %let run1= %eval(&run3 +0);
%end;

proc datasets nolist;
  delete _junk_ _freq1_ _freq2_ _freq3_;
run ;

%if &run1=0 and &run2=0 %then %do;
	%put ERROR: There appears to be no data to work with: Please check!;
	proc iml;
	  print "  Error Note:";
	  print "  There appears to be no data to work with. Please check. ";
	quit;
	%return; /* eMKF: added return functionality for easier debugging*/
%end;

%if &run1=1 and &run2=0 %then %do;
	%put ERROR: Please check your data: The number of valid timepoints is inconsistent across groups.;
	proc iml;
	  print "  Error Note:";
	  print "  An error occurred with your data. ";
	  print "  Check the data to make sure there are no missing values for means/SEs or only zero SEs, ";
	  print "  and that all the groups have data for the same number of timepoints (&time).";
	  print "  You may need to combine some groups and/or timepoints to avoid this problem.";
	quit;
	%return; /* eMKF: added return functionality for easier debugging*/
%end;

%if &run1=1 and &run2=1 %then %do;
	%put ERROR: Please check your data: The number of valid timepoints is inconsistent across groups and strata.;
	%put ERROR- This problem occurred in at least one subgroup.;
	%put ERROR- Alternatively, you may have forgotten to specify a BY variable when one is needed.; /* eMKF v2.4 correction: Additional error note for missing by variable */
	proc iml;
	  print "  Error Note:";
	  print "  An error occurred with your data. ";
	  print "  Check the data to make sure there are no missing values for means/SEs or only zero SEs, ";
	  print "  and that all the groups and strata have data for the same number of timepoints (&time).";
	  print "  You may need to combine some groups and/or timepoints to avoid this problem.";
	  print "  Alternatively, you may have forgotten to specify a BY variable when one is needed."; /* eMKF v2.4 correction: Additional error note for missing by variable */
	quit;
	%return; /* eMKF: added return functionality for easier debugging*/
%end;

%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	%let ug=0;
	data _null_;
	  set _bayesdata_;
	  one=1;
	  if _se2 ne . then call symput('ug',one);
	run;
	%let ug = %eval(&ug + 0);
	%if &ug=0 %then %let run1=1;
	%if &run1=1 %then %do; /* eMKF v2.4 streamlining: changed if condition from ug=0 to run1=1 for clarity */
		%put ERROR: Please check your data: You are using two outcomes &outcome and &outcome2.;
		%put ERROR- Check to make sure that both outcomes and SEs are correctly specified!;
		proc iml;
		  print "  Error Note:";
		  print "  Please check your data: You are using two outcomes &outcome and &outcome2.";
		  print "  Check to make sure that both outcomes and SEs are correctly specified!";
		quit;
		%return; /* eMKF: added return functionality for easier debugging*/
	%end;
%end;

%if &run1=0 and &run2=1 %then %do;

	/* Setting up the number of time points and the number of groups */

	%let ug=0; /* eMKF: Number of groups */
	data _freqg_;
	run;
	proc freq data=&data noprint;
	  tables &group /list out=_freqg_;
	run;
	data _freqg_;
	  set _freqg_;
	  _group_ +1;
	  call symput('ug',_group_);
	  keep _group_ &group;
	run;
	%let ug= %eval(0 + &ug);

	%let un=0;  /* eMKF: Macro variable for the number of time points */
	data _freqn_;
	run;
	proc freq data=_bayesdata_ noprint;
	  tables _rtime /list out=_freqn_;
	run;
	data _freqn_;
	  set _freqn_;
	  _time+1;
	  call symput('un',_time);
	  keep _rtime _time;
	run;
	%let un= %eval(0 + &un);

	%let uns1=0; %let uns2=0;  /* eMKF v2.4: Macro variables for the numbers of time points in segments 1 and 2 */	
	%if &breakPoint ^= %str() %then %do;
		data _freqns1_;
		run;
		proc freq data=_bayesdata_ noprint;
		  tables _s1rtime /list out=_freqns1_;
		run;
		data _freqns1_;
		  set _freqns1_(where=(_s1rtime ne 0));
		  _s1time+1;
		  call symput('uns1',_s1time);
		  keep _s1time _s1rtime;
		run;
		%let uns1= %eval(0 + &uns1); 
		data _freqns2_;
		run;
		proc freq data=_bayesdata_ noprint;
		  tables _s2rtime /list out=_freqns2_;
		run;
		data _freqns2_;
		  set _freqns2_(where=(_s2rtime ne 0));
		  _s2time+1;
		  call symput('uns2',_s2time);
		  keep _s2time _s2rtime;
		run;
		%let uns2= %eval(0 + &uns2);
		data _freqns2_;
		  set _freqns2_;
		  _s2time = _s2time + &uns1; /* eMKF v2.4: continue numbering from segment 1 */
		run;
	%end;

	/************************************************************************************************************************************/
	/* eMKF v2.4 streamlining: removed real times macro variable _rtimess from the parent mkf macro; it is used locally in child macros */
	/************************************************************************************************************************************/

	proc datasets nolist;
  		delete _freqn_ _freqg_ %if &breakPoint ^= %str() %then _freqns1_ _freqns2_; ;
	run ;

	/* eMKF v2.4 streamlining: thresholds for minimum number of timepoints apply to both ML and Bayesian estimation methods */ 
	%local minpts_&ARmodel._DROPPED; %let minpts_&ARmodel._DROPPED = 0; 
	%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._DROPPED = %sysfunc(ceil((0+4*&ug)/&ug));;
	%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._DROPPED = %sysfunc(ceil((1+3*&ug)/&ug));;
	%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._DROPPED = %sysfunc(ceil((2+2*&ug)/&ug));;

	/* eMKF v2.4: extra timepoints -- if segment 2 has fewer than 3 extra points, change full-break to level break */
	%if &uns2 < 3 and %upcase(&breakType) = FULL_BREAK %then %do;
		%put WARNING: breakType=full_break changed to level_break due to insufficient number of timepoints in segment 2.;
		%let breakType = level_break;
	%end;
	%local xtrpts_&breakType; %let xtrpts_&breakType = 0;
	%if %upcase(&breakType) = LEVEL_BREAK %then %let xtrpts_&breakType = %eval(2);;
	%if %upcase(&breakType) = FULL_BREAK  %then %let xtrpts_&breakType = %eval(3);;

	/* eMKF v2.4 streamlining: Revised cutoffs from 204 to 200 groups and 5508 to 5000 data points for simplicity */
	%if (&ug > 200 or %eval(&ug*&un) > 5000) %then %do;
		%put ERROR: Current implementation cannot handle more than 200 groups or 5000 data points per stratum.;
		%put ERROR- Please reduce the number of groups and/or timepoints.;
		proc iml;
		  print "  Error Note:";
		  print "  Current implementation cannot handle more than 200 groups or 5000 data points per stratum.";
		  print "  Please reduce the number of groups and/or timepoints. ";
		quit;
		%return;
	%end;

	/* eMKF v2.4 streamlining: Clarified minimal sample size requirements to use the macro and added trend break scenario */
	%if &breakPoint = %str() and &un < &&minpts_&ARmodel._DROPPED %then %do; 
		%put ERROR: There are not enough timepoints to use this macro!; 
		%put ERROR- At least &&minpts_&ARmodel._DROPPED timepoints are required with &ug &group groups and ARmodel=&ARmodel.;
		proc iml;
		  print "  Error Note:";
		  print "  There are not enough timepoints to use this macro!";
		  print "  At least &&minpts_&ARmodel._DROPPED timepoints are required with &ug &group groups and ARmodel=&ARmodel.";
		quit;
		%return;
	%end;
	%if &breakPoint ^= %str() and (&uns1 < &&minpts_&ARmodel._DROPPED or &uns2 < &&xtrpts_&breakType) %then %do;
		%put ERROR: Specified break point either was not found or resulted in too few timepoints. Please review!;
		%put ERROR- Segment 1 needs at least &&minpts_&ARmodel._DROPPED timepoints with &ug &group groups and ARmodel=&ARmodel.;
		%put ERROR- Additionally, segment 2 should have &&xtrpts_&breakType or more timepoints when breakType = &breakType.;
		proc iml;
	    	print "  Error Note:";
	    	print "  Specified break point either was not found or resulted in too few timepoints. Please review! ";
			print "  Segment 1 needs at least &&minpts_&ARmodel._DROPPED timepoints with &ug &group groups and ARmodel=&ARmodel.";
			print "  Additionally, segment 2 should have &&xtrpts_&breakType or more timepoints when breakType = &breakType.";
		quit;
	  	%return;
	%end;

	/******************************************************/
	/* eMKF v2.4 note: Code for ML estimation starts here */
	/******************************************************/

	%if &slopes ^=%str() %then %do;
		
		/* eMKF v2.4 streamlining: check for repeated models and remove */
	    /* eMKF v2.4 streamlining: with only 1 group, common trend models are redundant */
		%if &ug > 1 %then %let slopes = %_unique_(&slopes);
		%else %do;
			%let flag4=0; %let flag5=0; %let flag6=0; %let uvar=; %let ui = 0;
			%do ui=1 %to %_counts_(&slopes); /* eMKF v2.4: set flags */
				%let uvar = %scan(&slopes, &ui);
				%if %upcase(&uvar) = COMMON_CUBIC %then %let flag4 = 1;
				%if %upcase(&uvar) = COMMON_QUAD %then %let flag5 = 1;
				%if %upcase(&uvar) = COMMON_LINEAR %then %let flag6 = 1; 
			%end;		
			%if &flag4 = 1 or &flag5 = 1 or &flag6 = 1 %then %do;
				%put WARNING: As there is only one &group group, common trend models are redundant.;
				%put WARNING- Corresponding independent trend models will be assumed instead.;
				%local wrem wadd; %let wrem=; %let wadd=;
				%if &flag4 = 1 %then %do; %let wrem = &wrem common_cubic; %let wadd = &wadd indep_cubic; %end;
				%if &flag5 = 1 %then %do; %let wrem = &wrem common_quad; %let wadd = &wadd indep_quad; %end;
				%if &flag6 = 1 %then %do; %let wrem = &wrem common_linear; %let wadd = &wadd indep_linear; %end;
				%let slopes = %_unique_(&slopes, remove=&wrem, add=&wadd);
			%end;
			%let uvar=; %let flag4=; %let flag5=; %let flag6=;
		%end;

		/* eMKF v2.4 revisions: clarified model-specific sample size requirements and added trend break scenario */
		%if %upcase(&checkSampleSize) = YES %then %do;
			%let uvar=; %let ui=0;
	        %do ui=1 %to %_counts_(&slopes);
				%let uvar = %scan(&slopes, &ui);
				%local minpts_&ARmodel._&uvar; %let minpts_&ARmodel._&uvar = 0;
				%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+7*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+6*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+5*&ug)/&ug));;
				%end;
				%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+6*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+5*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+4*&ug)/&ug));;
				%end;
				%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+5*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+4*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+3*&ug)/&ug));;
				%end;
				%if &breakPoint = %str() and &un < &&minpts_&ARmodel._&uvar %then %do;
				  %put ERROR: There are too few timepoints for a &uvar model with &ug &group groups, ;
				  %put ERROR- and the ARmodel=&ARmodel specification.; 
				  %put ERROR- At least &&minpts_&ARmodel._&uvar timepoints are recommended for a model with these specs.;
				  proc iml;
				    print "  Error Note:";
					print "  There are too few timepoints for a &uvar model with &ug &group groups and ARmodel=&ARmodel.";
					print "  At least &&minpts_&ARmodel._&uvar timepoints are recommended for a model with these specs.";
				  quit;
				  %return;
				%end;
				%if &breakPoint ^= %str() and (&uns1 < &&minpts_&ARmodel._&uvar or &uns2 < &&xtrpts_&breakType) %then %do;
				  %put ERROR: There are too few timepoints for a &uvar model with &ug &group groups, ;
				  %put ERROR- and the ARmodel=&ARmodel and breakType=&breakType specifications.; 
				  %put ERROR- Segment 1 should have at least &&minpts_&ARmodel._&uvar timepoints, ;
				  %put ERROR- and segment 2 at least &&xtrpts_&breakType timepoints, with these model specs.;
				  proc iml;
				    print "  Error Note:";
					print "  There are too few timepoints for a &uvar model with &ug &group groups, ";
					print "  and the ARmodel=&ARmodel and breakType=&breakType specifications.";
					print "  Segment 1 should have at least &&minpts_&ARmodel._&uvar timepoints, ";
					print "  and segment 2 at least &&xtrpts_&breakType timepoints, with these model specs.";
				  quit;
				  %return;
				%end;
				%let uvar=; 
			%end;
		%end;

		/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
		%put ;
		%put MKF macro will use maximum likelihood (ML) to estimate specified model(s).;

		/* Compute the estimation for all different slopes estimation the user desires*/
		%let uvar =; %let s2uvar=; %let toprint2=;
		%let uj = %eval(0 + %_counts_(&slopes));

		%if &uj=1 %then %do;

			%let uvar = &slopes;

			/* eMKF: Strings used to account for various combinations of available parameter estimates (up to cubic only) */
			%let emkfkeep = ; %let emkfrename = ;
			%if &outcome2 =%str() or &se2 =%str() %then %do; /* one outcome */
				/* eMKF v2.4: added option for dealing with break in trend */
				%if &breakPoint = %str() %then %do;
					%let emkfkeep = a; %let emkfrename = a=a_&uvar;
					%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
						%let emkfkeep = &emkfkeep b1 b2 b3;
						%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar b3=b3_&uvar;
					%end;
					%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
						%let emkfkeep =  &emkfkeep b1 b2;
						%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar;
					%end;
					%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
						%let emkfkeep = &emkfkeep b1;
						%let emkfrename = &emkfrename b1=b1_&uvar;
					%end;
				%end;
				%else %do;
					/* eMKF v2.4: common suffix for level break */
					%if %upcase(&breakType) = LEVEL_BREAK %then %let s2uvar = xlv;
					/* eMKF v2.4: set trend model for segment 2 based on timepoint availability */
					/*  To limit model combinations, disallow intercepts-only model in segment 2 unless it is also used in segment 1 */
					/*  Additionally, model type (common vs independent trend) is maintained for segment 2 */
					%if %upcase(&breakType) = FULL_BREAK %then %do;
						%if %upcase(&uvar) = INDEP_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = indep_cubic;
							%if &uns2 =  4 %then %let s2uvar = indep_quad;
							%if &uns2 =  3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = INDEP_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = indep_quad;
							%if &uns2 =  3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = INDEP_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = COMMON_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = common_cubic;
							%if &uns2 =  4 %then %let s2uvar = common_quad;
							%if &uns2 =  3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = COMMON_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = common_quad;
							%if &uns2 =  3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = COMMON_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = DROPPED %then %do;
							%if &uns2 ge 2 %then %let s2uvar = dropped;
						%end;
					%end;
					/* eMKF v2.4: coefficient labels depend on breakType */
					%if %upcase(&breakType) = LEVEL_BREAK %then %do;
						%let emkfkeep = s1a s2a; %let emkfrename = s1a=s1a_&uvar s2a=s2a_&uvar;
						%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
							%let emkfkeep = &emkfkeep b1 b2 b3;
							%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar b3=b3_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
							%let emkfkeep =  &emkfkeep b1 b2;
							%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
							%let emkfkeep = &emkfkeep b1;
							%let emkfrename = &emkfrename b1=b1_&uvar;
						%end;
					%end;
					%if %upcase(&breakType) = FULL_BREAK %then %do;
						%let emkfkeep = s1a s2a; %let emkfrename = s1a=s1a_&uvar s2a=s2a_&s2uvar;
						%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
							%let emkfkeep = &emkfkeep s1b1 s1b2 s1b3;
							%let emkfrename = &emkfrename s1b1=s1b1_&uvar s1b2=s1b2_&uvar s1b3=s1b3_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
							%let emkfkeep =  &emkfkeep s1b1 s1b2;
							%let emkfrename = &emkfrename s1b1=s1b1_&uvar s1b2=s1b2_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
							%let emkfkeep = &emkfkeep s1b1;
							%let emkfrename = &emkfrename s1b1=s1b1_&uvar;
						%end;
						%if %upcase(&s2uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
							%let emkfkeep = &emkfkeep s2b1 s2b2 s2b3;
							%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar s2b2=s2b2_&s2uvar s2b3=s2b3_&s2uvar;
						%end;
						%if %upcase(&s2uvar) in INDEP_QUAD COMMON_QUAD %then %do;
							%let emkfkeep =  &emkfkeep s2b1 s2b2;
							%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar s2b2=s2b2_&s2uvar;
						%end;
						%if %upcase(&s2uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
							%let emkfkeep = &emkfkeep s2b1;
							%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar;
						%end;
					%end;
				%end;
			%end;
			%else %do; /* two outcomes */
				%let emkfkeep = o1a o2a; %let emkfrename = o1a=o1a_&uvar o2a=o2a_&uvar;
				%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
					%let emkfkeep = &emkfkeep o1b1 o2b1 o1b2 o2b2 o1b3 o2b3;
					%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar o1b2=o1b2_&uvar o2b2=o2b2_&uvar o1b3=o1b3_&uvar o2b3=o2b3_&uvar;
				%end;
				%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
					%let emkfkeep =  &emkfkeep o1b1 o2b1 o1b2 o2b2;
					%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar o1b2=o1b2_&uvar o2b2=o2b2_&uvar;
				%end;
				%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
					%let emkfkeep = &emkfkeep o1b1 o2b1;
					%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar;
				%end;
			%end;

			/* eMKF: Simplified suffix assignment */
			%let newuvar = ; %let s2newuvar = ; %let s22uvar = ;
			%if %upcase(&uvar) = INDEP_CUBIC   %then %let newuvar = _GC;
			%if %upcase(&uvar) = INDEP_QUAD    %then %let newuvar = _GQ;
			%if %upcase(&uvar) = INDEP_LINEAR  %then %let newuvar = _GL;
			%if %upcase(&uvar) = COMMON_CUBIC  %then %let newuvar = _1C;
			%if %upcase(&uvar) = COMMON_QUAD   %then %let newuvar = _1Q;
			%if %upcase(&uvar) = COMMON_LINEAR %then %let newuvar = _1L;
			%if %upcase(&uvar) = DROPPED	   %then %let newuvar = _0;

			/* eMKF v2.4: Added suffix for segment 2 */
			%if &s2uvar ^= %str() %then %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %let s2newuvar = _XLV;
				%if %upcase(&breakType) = FULL_BREAK %then %do;
					%if %upcase(&s2uvar) = INDEP_CUBIC   %then %let s2newuvar = _GC;
					%if %upcase(&s2uvar) = INDEP_QUAD    %then %let s2newuvar = _GQ;
					%if %upcase(&s2uvar) = INDEP_LINEAR  %then %let s2newuvar = _GL;
					%if %upcase(&s2uvar) = COMMON_CUBIC  %then %let s2newuvar = _1C;
					%if %upcase(&s2uvar) = COMMON_QUAD   %then %let s2newuvar = _1Q;
					%if %upcase(&s2uvar) = COMMON_LINEAR %then %let s2newuvar = _1L;
					%if %upcase(&s2uvar) = DROPPED 		 %then %let s2newuvar = _0;
				%end;
			%end;

			/* eMKF v2.4: Version of segment 2 suffix for column labels in output datasets */
			%if &s2uvar ^= %str() %then %do;
				%if &s2uvar = xlv %then %let s22uvar = _xlv;
				%else %do;
					%if %upcase(%substr(&s2uvar, 1, 5)) = INDEP %then %let s22uvar = %substr(&s2uvar, 6, 4);
					%if %upcase(%substr(&s2uvar, 1, 6)) = COMMON %then %let s22uvar = %substr(&s2uvar, 7, 4);
					%if %upcase(&s2uvar) = DROPPED %then %let s22uvar = _&s2uvar;
				%end;
			%end;

			/* eMKF v2.4: Modified to add extra suffix for segment 2 if applicable */
			%let _thekeep1 = &_thekeep1 pred_&uvar&s22uvar=pred&newuvar&s2newuvar predse_&uvar&s22uvar=se&newuvar&s2newuvar;
			%let _thekeep2 = &_thekeep2 pred_&uvar&s22uvar predse_&uvar&s22uvar;
			%let _thekeep3 = &_thekeep3 &out.(keep=pred_&uvar&s22uvar) &out.(keep= predse_&uvar&s22uvar);
			%let _thekeeps = &_thekeeps pred&newuvar&s2newuvar=&_oo1_._pred&newuvar&s2newuvar se&newuvar&s2newuvar=&_oo1_._se&newuvar&s2newuvar;

			/* eMKF: corrected issue in original MKF with re-labeling pred and se using outcome label when there are two outcomes */
			%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
				%let _thekeep1 = &_thekeep1 pred2_&uvar&s22uvar=pred2&newuvar&s2newuvar pred2se_&uvar&s22uvar=se2&newuvar&s2newuvar;
				%let _thekeep2 = &_thekeep2 pred2_&uvar&s22uvar pred2se_&uvar&s22uvar;
				%let _thekeep3 = &_thekeep3 &out.(keep=pred2_&uvar&s22uvar) &out.(keep=pred2se_&uvar&s22uvar);
				%let _thekeeps = &_thekeeps pred2&newuvar&s2newuvar=&_oo2_._pred&newuvar&s2newuvar se2&newuvar&s2newuvar=&_oo2_._se&newuvar&s2newuvar;
			%end;

			/* eMKF v2.4: used toprint2=&uvar instead of toprint2=&slopes, and added segment 2 label if applicable */
			%let xtrakeep22= &xtrakeep &outcome &se &group &time impute inputorder &by;
			%if &by ^=%str() %then %let xtrakeep22= &xtrakeep22 imputeb;
			%let toprint2=&uvar&s22uvar;

			/* eMKF v2.4: Added user-facing status note */
			%put ;
			%put Start fitting model with suffix &newuvar&s2newuvar;

			/* eMKF v2.4: Modified single outcome method to allow for various trend breaks options */
			%if &outcome2 =%str() or &se2 =%str() %then %do;
				%if &breakPoint = %str() %then %do;
					%htrp(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby,
					  	xtrakeep=&xtrakeep22, orpoly=&orpoly, nlmixedDetails=&nlmixedDetails,	        /* eMKF v2.4 streamlining: fit details omitted by default */
					  	bvalue=&uvar, ARvalue=&ARmodel,  	 	 /* eMKF v2.4 now allows for heteroskedastic AR models: _rho_ and _tausq_ no longer user-supplied */
					  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech,   /* eMKF v2.4: user-selected optimization algorithm can now replace the default (QUANEW) */
					  	out=&out, print=&modelprint);
				%end;
				%else %do; 
					%if %upcase(&breakType) = LEVEL_BREAK %then %do;
						%htrpxptl(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby,
						  	xtrakeep=&xtrakeep22, orpoly=&orpoly, nlmixedDetails=&nlmixedDetails,
						  	xpt=&breakPoint, bvalue=&uvar, ARvalue=&ARmodel, 
						  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech,
						  	out=&out, print=&modelprint);
					%end; 
					%if %upcase(&breakType) = FULL_BREAK %then %do;
						%htrpxptf(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby,
						  	xtrakeep=&xtrakeep22, orpoly=&orpoly, nlmixedDetails=&nlmixedDetails,
						  	xpt=&breakPoint, bvalue1=&uvar, bvalue2=&s2uvar, ARvalue=&ARmodel, 
						  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech,
						  	out=&out, print=&modelprint);
					%end;
				%end;
				data &out._pred; 							/* eMKF v2.4: Modified to add extra suffix for segment 2 if applicable */
				  set &out._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar )
				                 drop=_2loglike _rho_ _tausq_ &emkfkeep 	/* eMKF: Additional quadratic and cubic terms to drop */
 									  );; 
				run;
			%end;
			%else %do;
				%htrp2d(data=_nlmixdata_, outcome=_y, se=_se, outcome2=_y2, se2=_se2, group=_groupnum, time=_time, by=&_ssby,
						xtrakeep=&xtrakeep22, orpoly=&orpoly, nlmixedDetails=&nlmixedDetails,         /* eMKF v2.4 streamlining: fit details omitted by default */
						bvalue=&uvar, ARvalue=&ARmodel, 	   /* eMKF v2.4 now allows for heteroskedastic AR models: _rho_ and _tausq_ no longer user-supplied */
					    nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech, /* eMKF v2.4: user-selected optimization algorithm can now replace the default (QUANEW) */
						out=&out, print=&modelprint);

				data &out._pred;
				  set &out._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar 
				                         prediction2=pred2_&uvar&s22uvar predMSE2=pred2MSE_&uvar&s22uvar predSE2=pred2SE_&uvar&s22uvar )
				                 drop=_2loglike _rho_ _tausq_ &emkfkeep  /* eMKF: Additional quadratic and cubic terms to drop */
									  moddelta _tausq2_ _rho2_ err3 _se3 gamma gamma2 gammaeff predeff predeff2 
									  gamma_blup gamma_se pred_blup pred_blup2 
				                );; 
				run;
			%end;

			/* eMKF v2.4: Added user-facing status note */
			%put ;
			%put End fitting model with suffix &newuvar&s2newuvar;

			/**************************************************************************************************************************************/
			/* eMKF v2.4 streamlining: clean-up of model-specific results now done within HTRP and HTRP2d by default (option nlmixedDetails = NO) */
			/**************************************************************************************************************************************/

		%end; /*End of condition if uj = 1 */

		/* If there are more than one type of estimation methods requested then conduct a model averaging estimation */
		/* eMKF: 1=indep_cubic, 2=indep_quad, 3=indep_linear, 4=common_cubic, 5=common_quad, 6=common_linear, 7=dropped */

		%let flag1 =; %let flag2 =; %let flag3 =; %let flag4=; %let flag5=; %let flag6=; %let flag7=;

 		%if &uj > 1 %then %do;

			/** eMKF: Check that a common reference/descendant model is included, and add to list if not:
			 ** - If both indep_quad   & common_cubic are selected, common_quad   will be added to the list if not already specified.
		  	 ** - If both indep_linear & common_cubic are selected, common_linear will be added to the list if not already specified.
		  	 ** - If both indep_linear & common_quad  are selected, common_linear will be added to the list if not already specified.
			 **/
			%let flag1=0; %let flag2=0; %let flag3=0; %let flag4=0; %let flag5=0; %let flag6=0; %let flag7=0;
			%let uvar=; %let ui = 0;
			%do ui=1 %to %_counts_(&slopes); /* eMKF: first pass to set flags */
				%let uvar=%scan(&slopes, &ui);
				%if %upcase(&uvar) = INDEP_CUBIC %then %let flag1 = 1;
				%if %upcase(&uvar) = INDEP_QUAD %then %let flag2 = 1;
				%if %upcase(&uvar) = INDEP_LINEAR %then %let flag3 = 1; 
				%if %upcase(&uvar) = COMMON_CUBIC %then %let flag4 = 1;
				%if %upcase(&uvar) = COMMON_QUAD %then %let flag5 = 1;
				%if %upcase(&uvar) = COMMON_LINEAR %then %let flag6 = 1; 
				%if %upcase(&uvar) = DROPPED %then %let flag7 = 1; 
				%let uvar=;
            %end;
			%let _slopes = &slopes;
			/* eMKF v2.4 streamlining: streamlined warning messages */
			%if &flag5 = 1 and &flag3 = 1 and &flag6 ^= 1 and &flag7 ^= 1 %then %do;
				%put WARNING: Both the common_quad and indep_linear models were specified with no shared descendant.;
				%put WARNING- Added the common_linear trend model to the list of requested models.;
			  	%let _slopes = &_slopes common_linear;
				%let flag6 = 1;
			%end;
            %if &flag4 = 1 and &flag3 = 1 and &flag6 ^= 1 and &flag7 ^= 1 %then %do;
				%put WARNING: Both the common_cubic and indep_linear models were specified with no shared descendant.;
				%put WARNING- Added the common_linear trend model to the list of requested models.;
			  	%let _slopes = &_slopes common_linear;
				%let flag6 = 1;
			%end;
            %if &flag4 = 1 and &flag2 = 1 and &flag5 ^= 1 and &flag6 ^= 1 and &flag7 ^= 1 %then %do;				
				%put WARNING: Both the common_cubic and indep_quad models were specified with no shared descendant.;
				%put WARNING- Added the common_quad trend model to the list of requested models.;
			  	%let _slopes = &_slopes common_quad;
				%let flag5 = 1;
			%end;
			/* eMFK: End check for nested models */

			/* eMKF v2.4: modified model average suffix to handle trend break options with one outcome */
			%if &breakPoint = %str() %then %let uvar=ModelAvg;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %let uvar=ModelAvg_xlevel;
				%if %upcase(&breakType) = FULL_BREAK %then %let uvar=ModelAvg_xfull;
			%end;
			%let _thekeep1 = &_thekeep1 pred_&uvar =pred_MA predse_&uvar=se_MA;
			%let _thekeep2 = &_thekeep2 pred_&uvar predse_&uvar;
			%let _thekeep3 = &_thekeep3 &out.(keep= pred_&uvar) &out.(keep= predse_&uvar);
			%let _thekeeps = &_thekeeps pred_MA=&_oo1_._pred_MA se_MA=&_oo1_._se_MA;
			%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
				%let _thekeep1 = &_thekeep1 pred2_&uvar =pred2_MA pred2se_&uvar=se2_MA;
				%let _thekeep2 = &_thekeep2 pred2_&uvar pred2se_&uvar;
				%let _thekeep3 = &_thekeep3 &out.(keep= pred2_&uvar) &out.(keep= pred2se_&uvar);
				%let _thekeeps = &_thekeeps pred2_MA=&_oo2_._pred_MA se2_MA=&_oo2_._se_MA;
			%end;
			
			data &out._pred &out._ests _loglike_;
			run;

			%let uvar=; %let s2uvar=; %let ui=0;

			%do ui=1 %to %_counts_(&_slopes); 	/* eMKF: slopes replaced with _slopes */

				%let uvar = %scan(&_slopes, &ui);

				%let emkfkeep = ; %let emkfrename = ;
				%if &outcome2 =%str() or &se2 =%str() %then %do; /* one outcome */
					/* eMKF v2.4: added option for dealing with break in trend */
					%if &breakPoint = %str() %then %do;
						%let emkfkeep = a; %let emkfrename = a=a_&uvar;
						%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
							%let emkfkeep = &emkfkeep b1 b2 b3;
							%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar b3=b3_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
							%let emkfkeep =  &emkfkeep b1 b2;
							%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar;
						%end;
						%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
							%let emkfkeep = &emkfkeep b1;
							%let emkfrename = &emkfrename b1=b1_&uvar;
						%end;
					%end;
					%else %do;
						/* eMKF v2.4: common suffix for level break */
						%if %upcase(&breakType) = LEVEL_BREAK %then %let s2uvar = xlv;
						/* eMKF v2.4: set trend model for segment 2 based on timepoint availability */
						/*  To limit model combinations, disallow intercepts-only model in segment 2 unless it is also used in segment 1 */
						/*  Additionally, model type (common vs independent trend) is maintained for segment 2 */
						%if %upcase(&breakType) = FULL_BREAK %then %do;
							%if %upcase(&uvar) = INDEP_CUBIC %then %do;
								%if &uns2 ge 5 %then %let s2uvar = indep_cubic;
								%if &uns2 =  4 %then %let s2uvar = indep_quad;
								%if &uns2 =  3 %then %let s2uvar = indep_linear;
							%end;
							%if %upcase(&uvar) = INDEP_QUAD %then %do;
								%if &uns2 ge 4 %then %let s2uvar = indep_quad;
								%if &uns2 =  3 %then %let s2uvar = indep_linear;
							%end;
							%if %upcase(&uvar) = INDEP_LINEAR %then %do;
								%if &uns2 ge 3 %then %let s2uvar = indep_linear;
							%end;
							%if %upcase(&uvar) = COMMON_CUBIC %then %do;
								%if &uns2 ge 5 %then %let s2uvar = common_cubic;
								%if &uns2 =  4 %then %let s2uvar = common_quad;
								%if &uns2 =  3 %then %let s2uvar = common_linear;
							%end;
							%if %upcase(&uvar) = COMMON_QUAD %then %do;
								%if &uns2 ge 4 %then %let s2uvar = common_quad;
								%if &uns2 =  3 %then %let s2uvar = common_linear;
							%end;
							%if %upcase(&uvar) = COMMON_LINEAR %then %do;
								%if &uns2 ge 3 %then %let s2uvar = common_linear;
							%end;
							%if %upcase(&uvar) = DROPPED %then %do;
								%if &uns2 ge 2 %then %let s2uvar = dropped;
							%end;
						%end;
						/* eMKF v2.4: coefficient labels depend on breakType */
						%if %upcase(&breakType) = LEVEL_BREAK %then %do;
							%let emkfkeep = s1a s2a; %let emkfrename = s1a=s1a_&uvar s2a=s2a_&uvar;
							%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
								%let emkfkeep = &emkfkeep b1 b2 b3;
								%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar b3=b3_&uvar;
							%end;
							%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
								%let emkfkeep =  &emkfkeep b1 b2;
								%let emkfrename = &emkfrename b1=b1_&uvar b2=b2_&uvar;
							%end;
							%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
								%let emkfkeep = &emkfkeep b1;
								%let emkfrename = &emkfrename b1=b1_&uvar;
							%end;
						%end;
						%if %upcase(&breakType) = FULL_BREAK %then %do;
							%let emkfkeep = s1a s2a; %let emkfrename = s1a=s1a_&uvar s2a=s2a_&s2uvar;
							%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
								%let emkfkeep = &emkfkeep s1b1 s1b2 s1b3;
								%let emkfrename = &emkfrename s1b1=s1b1_&uvar s1b2=s1b2_&uvar s1b3=s1b3_&uvar;
							%end;
							%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
								%let emkfkeep =  &emkfkeep s1b1 s1b2;
								%let emkfrename = &emkfrename s1b1=s1b1_&uvar s1b2=s1b2_&uvar;
							%end;
							%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
								%let emkfkeep = &emkfkeep s1b1;
								%let emkfrename = &emkfrename s1b1=s1b1_&uvar;
							%end;
							%if %upcase(&s2uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
								%let emkfkeep = &emkfkeep s2b1 s2b2 s2b3;
								%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar s2b2=s2b2_&s2uvar s2b3=s2b3_&s2uvar;
							%end;
							%if %upcase(&s2uvar) in INDEP_QUAD COMMON_QUAD %then %do;
								%let emkfkeep =  &emkfkeep s2b1 s2b2;
								%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar s2b2=s2b2_&s2uvar;
							%end;
							%if %upcase(&s2uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
								%let emkfkeep = &emkfkeep s2b1;
								%let emkfrename = &emkfrename s2b1=s2b1_&s2uvar;
							%end;
						%end;
					%end;
				%end;
				%else %do; /* two outcomes */
					%let emkfkeep = o1a o2a; %let emkfrename = o1a=o1a_&uvar o2a=o2a_&uvar;
					%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC %then %do;
						%let emkfkeep = &emkfkeep o1b1 o2b1 o1b2 o2b2 o1b3 o2b3;
						%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar o1b2=o1b2_&uvar o2b2=o2b2_&uvar o1b3=o1b3_&uvar o2b3=o2b3_&uvar;
					%end;
					%if %upcase(&uvar) in INDEP_QUAD COMMON_QUAD %then %do;
						%let emkfkeep =  &emkfkeep o1b1 o2b1 o1b2 o2b2;
						%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar o1b2=o1b2_&uvar o2b2=o2b2_&uvar;
					%end;
					%if %upcase(&uvar) in INDEP_LINEAR COMMON_LINEAR %then %do;
						%let emkfkeep = &emkfkeep o1b1 o2b1;
						%let emkfrename = &emkfrename o1b1=o1b1_&uvar o2b1=o2b1_&uvar;
					%end;
				%end;

				/* eMKF: Simplified suffix assignment */
				%let newuvar = ; %let s2newuvar = ; %let s22uvar = ;
				%if %upcase(&uvar) = INDEP_CUBIC   %then %let newuvar = _GC;
				%if %upcase(&uvar) = INDEP_QUAD    %then %let newuvar = _GQ;
				%if %upcase(&uvar) = INDEP_LINEAR  %then %let newuvar = _GL;
				%if %upcase(&uvar) = COMMON_CUBIC  %then %let newuvar = _1C;
				%if %upcase(&uvar) = COMMON_QUAD   %then %let newuvar = _1Q;
				%if %upcase(&uvar) = COMMON_LINEAR %then %let newuvar = _1L;
				%if %upcase(&uvar) = DROPPED	   %then %let newuvar = _0;

				/* eMKF v2.4: Added suffix for segment 2 */
				%if &s2uvar ^= %str() %then %do;
					%if &s2uvar = xlv %then %let s2newuvar = _XLV;
					%else %do;
						%if %upcase(&s2uvar) = INDEP_CUBIC   %then %let s2newuvar = _GC;
						%if %upcase(&s2uvar) = INDEP_QUAD    %then %let s2newuvar = _GQ;
						%if %upcase(&s2uvar) = INDEP_LINEAR  %then %let s2newuvar = _GL;
						%if %upcase(&s2uvar) = COMMON_CUBIC  %then %let s2newuvar = _1C;
						%if %upcase(&s2uvar) = COMMON_QUAD   %then %let s2newuvar = _1Q;
						%if %upcase(&s2uvar) = COMMON_LINEAR %then %let s2newuvar = _1L;
						%if %upcase(&s2uvar) = DROPPED		 %then %let s2newuvar = _0;
					%end;
				%end;

				/* eMKF v2.4: Version of segment 2 suffix for column labels in output datasets */
				%if &s2uvar ^= %str() %then %do;
					%if &s2uvar = xlv %then %let s22uvar = _xlv;
					%else %do;
						%if %upcase(%substr(&s2uvar, 1, 5)) = INDEP %then %let s22uvar = %substr(&s2uvar, 6, 4);
						%if %upcase(%substr(&s2uvar, 1, 6)) = COMMON %then %let s22uvar = %substr(&s2uvar, 7, 4);
						%if %upcase(&s2uvar) = DROPPED %then %let s22uvar = _&s2uvar;
					%end;
				%end;

				/* eMKF v2.4: Modified to add extra suffix for segment 2 if applicable */
				%let _thekeep1 = &_thekeep1 pred_&uvar&s22uvar =pred&newuvar&s2newuvar predse_&uvar&s22uvar=rmse&newuvar&s2newuvar;
				%let _thekeep2 = &_thekeep2 pred_&uvar&s22uvar predse_&uvar&s22uvar;
				%let _thekeep3 = &_thekeep3 &out.(keep= pred_&uvar&s22uvar) &out.(keep= predse_&uvar&s22uvar);
				%let _thekeeps = &_thekeeps pred&newuvar&s2newuvar=&_oo1_._pred&newuvar&s2newuvar rmse&newuvar&s2newuvar=&_oo1_._se&newuvar&s2newuvar;
				%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
					%let _thekeep1 = &_thekeep1 pred2_&uvar&s22uvar =pred2&newuvar&s2newuvar pred2se_&uvar&s22uvar=rmse2&newuvar&s2newuvar;
					%let _thekeep2 = &_thekeep2 pred2_&uvar&s22uvar pred2se_&uvar&s22uvar;
					%let _thekeep3 = &_thekeep3 &out.(keep= pred2_&uvar&s22uvar) &out.(keep= pred2se_&uvar&s22uvar);
					%let _thekeeps = &_thekeeps pred2&newuvar&s2newuvar=&_oo2_._pred&newuvar&s2newuvar rmse2&newuvar&s2newuvar=&_oo2_._se&newuvar&s2newuvar;
				%end;
				%let xtrakeep22= &xtrakeep &outcome &se &group &time impute inputorder &by;
				%if &by ^=%str() %then %let xtrakeep22= &xtrakeep22 imputeb;
				%if &outcome2 ^=%str() and &se2 ^=%str() %then %let xtrakeep22= &xtrakeep22 &outcome2 &se2;;

				/* eMKF v2.4: modified model average suffix to handle trend break options with one outcome */
				%if &breakPoint = %str() %then %let toprint2=ModelAvg;
				%else %do;
					%if %upcase(&breakType) = LEVEL_BREAK %then %let toprint2=ModelAvg_xlevel;
					%if %upcase(&breakType) = FULL_BREAK %then %let toprint2=ModelAvg_xfull;
				%end;

				%if %upcase(&uvar)=INDEP_CUBIC   %then %let flag1=YES;
				%if %upcase(&uvar)=INDEP_QUAD    %then %let flag2=YES;
				%if %upcase(&uvar)=INDEP_LINEAR  %then %let flag3=YES;
				%if %upcase(&uvar)=COMMON_CUBIC  %then %let flag4=YES;
				%if %upcase(&uvar)=COMMON_QUAD   %then %let flag5=YES;
				%if %upcase(&uvar)=COMMON_LINEAR %then %let flag6=YES;
				%if %upcase(&uvar)=DROPPED       %then %let flag7=YES;

				/* eMKF v2.4 streamlining: revised used-facing status note */
				%put ;
				%put Start fitting model with suffix &newuvar&s2newuvar;

				/* eMKF v2.4: Modified single outcome method to allow for various trend breaks options */
				%if &outcome2 =%str() or &se2 =%str() %then %do;
					%if &breakPoint = %str() %then %do;
						%htrp(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby, xtrakeep=&xtrakeep22, orpoly=&orpoly,
						  	nlmixedDetails=&nlmixedDetails,	        		/* eMKF v2.4 streamlining: fit details omitted by default */
						  	bvalue=&uvar, ARvalue=&ARmodel,  	 			/* eMKF v2.4 now allows for heteroskedastic AR models: _rho_ and _tausq_ no longer user-supplied */
						  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech, /* eMKF v2.4: user-selected optimization algorithm can now replace the default (QUANEW) */
						  	out=_KF_&uvar&s22uvar, print=&modelprint);
					%end;
					%else %do; 
						%if %upcase(&breakType) = LEVEL_BREAK %then %do;
							%htrpxptl(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby, xtrakeep=&xtrakeep22, orpoly=&orpoly,
							  	nlmixedDetails=&nlmixedDetails, xpt=&breakPoint, bvalue=&uvar, ARvalue=&ARmodel, 
							  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech, out=_KF_&uvar&s22uvar, print=&modelprint);
						%end; 
						%if %upcase(&breakType) = FULL_BREAK %then %do;
							%htrpxptf(data=_nlmixdata_, outcome=_y, se=_se, group=_groupnum, time=_time, by=&_ssby, xtrakeep=&xtrakeep22, orpoly=&orpoly, 
							  	nlmixedDetails=&nlmixedDetails, xpt=&breakPoint, bvalue1=&uvar, bvalue2=&s2uvar, ARvalue=&ARmodel, 
							  	nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech, out=_KF_&uvar&s22uvar, print=&modelprint); 
						%end;
					%end;
				%end;
				%else %do;
					%htrp2d(data=_nlmixdata_, outcome=_y, se=_se, outcome2=_y2, se2=_se2, group=_groupnum, time=_time, by=&_ssby, xtrakeep=&xtrakeep22, orpoly=&orpoly,
							nlmixedDetails=&nlmixedDetails,	 	  			/* eMKF v2.4 streamlining: fit details omitted by default */
							bvalue=&uvar, ARvalue=&ARmodel,  	   			/* eMKF v2.4 now allows for heteroskedastic AR models: _rho_ and _tausq_ no longer user-supplied */
							nlmixedDF=&nlmixedDF, nlmixedTech=&nlmixedTech, /* eMKF v2.4: user-selected optimization algorithm can now replace the default (QUANEW) */
							out=_KF_&uvar&s22uvar, print=&modelprint);

					data _KF_&uvar&s22uvar._pred;
				 	  set _KF_&uvar&s22uvar._pred(drop=moddelta err3 _se3 gamma gamma2 gammaeff predeff predeff2 gamma_blup gamma_se pred_blup pred_blup2);
					run;
			   	%end;

				/* eMKF v2.4 streamlining: revised used-facing status note */
				%put ;
		       	%put End fitting model with suffix &newuvar&s2newuvar;

				/* eMKF: From this point on, _groupnum and _reps have been dropped: will work with generic _group_ and _rep directly */

			   	proc sort data=_KF_&uvar&s22uvar._pred;
				  by _rep _group_ _time;
				run;
				data _junk_;
				run;
				proc sort data=_KF_&uvar&s22uvar._pred out=_junk_ nodupkey;
				  by _rep _group_ ;
				run;
				proc sort data=_KF_&uvar&s22uvar._ests;
				  by _rep _group_ ;
				run;
				data _KF_&uvar&s22uvar._ests;
				  merge _KF_&uvar&s22uvar._ests _junk_(keep= _rep _group_);
				  by _rep _group_;
				run;
		 		proc sort data=_KF_&uvar&s22uvar._ests;
		  		  by _rep _group_;
		 		run;

		    	%if &ui = 1 %then %do;
					%if &outcome2 =%str() or &se2 =%str() %then %do;
			  			data &out._pred;
			    		  set _KF_&uvar&s22uvar._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar )
		                  		              		  drop=_2loglike _rho_ _tausq_ &emkfkeep /* eMKF: additional quadratic and cubic terms to drop */
											 		  );; 
			   			run;
			  			data &out._ests;
			    		  set _KF_&uvar&s22uvar._ests(rename=(_2loglike=_2ll&uvar&s22uvar _rho_=_rho_&uvar&s22uvar._ _tausq_=_tausq_&uvar&s22uvar._  
													 		  &emkfrename  /* eMKF: additional quadratic and cubic terms to rename */
											 		  ));;  
			  			run;
					%end;
					%else %do;
			  			data &out._pred;
			    		  set _KF_&uvar&s22uvar._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar 
		                                        	 		  prediction2=pred2_&uvar&s22uvar predMSE2=pred2MSE_&uvar&s22uvar predSE2=pred2SE_&uvar&s22uvar)
		                            		  		  drop=_2loglike _rho_ _rho2_ _tausq_ _tausq2_ &emkfkeep
										 	 		  );; 
			  			run;
			  			data &out._ests;
			    		  set _KF_&uvar&s22uvar._ests(rename=(_2loglike=_2ll&uvar&s22uvar _rho_=_rho_&uvar&s22uvar._ _tausq_=_tausq_&uvar&s22uvar._  
													 		  &emkfrename
											 		  ));; 
			  			run;
					%end;
					/* eMKF: Keep the log likelihood estimate for the type of model into llike1, 2, 3, 4, 5, 6, and 7*/
					/* eMKF v2.4: Model combinations in full trend break scenario are kept into llike11, 12, 13, 22, 23, 33, 44, 45, 46, 55, 56, 66, and 77*/
					data  _loglike_;
					   /* modified for eMKF to allow for quad and cubic trend models and eMKF v2.4 to allow trend break options */
					   set _KF_&uvar&s22uvar._ests(keep= _rep _2loglike );
					   %if &s2uvar = %str() or &s2uvar = xlv %then %do;	
						   llike1=.;
						   llike2=.;
						   llike3=.;
						   llike4=.;
						   llike5=.;
						   llike6=.;
						   llike7=.;
						   %if %upcase(&uvar)=INDEP_CUBIC  	%then llike1 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD 	%then llike2 = _2loglike ;; 
						   %if %upcase(&uvar)=INDEP_LINEAR 	%then llike3 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC 	%then llike4 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_QUAD  	%then llike5 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_LINEAR %then llike6 = _2loglike ;;
						   %if %upcase(&uvar)=DROPPED      	%then llike7 = _2loglike ;;
					   %end;
					   %else %do;
						   llike11=.;
						   llike12=.;
						   llike13=.;
						   llike22=.;
						   llike23=.;
						   llike33=.;
						   llike44=.;
						   llike45=.;
						   llike46=.;
						   llike55=.;
						   llike56=.;
						   llike66=.;
						   llike77=.;
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_CUBIC  	%then llike11 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_QUAD		%then llike12 = _2loglike ;; 
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_LINEAR 	%then llike13 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD and %upcase(&s2uvar)=INDEP_QUAD 		%then llike22 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD and %upcase(&s2uvar)=INDEP_LINEAR 		%then llike23 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_LINEAR and %upcase(&s2uvar)=INDEP_LINEAR 	%then llike33 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC and %upcase(&s2uvar)=COMMON_CUBIC 	%then llike44 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC and %upcase(&s2uvar)=COMMON_QUAD		%then llike45 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC  and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike46 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_QUAD and %upcase(&s2uvar)=COMMON_QUAD		%then llike55 = _2loglike ;; 
						   %if %upcase(&uvar)=COMMON_QUAD and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike56 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_LINEAR and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike66 = _2loglike ;;
						   %if %upcase(&uvar)=DROPPED and %upcase(&s2uvar)=DROPPED  			%then llike77 = _2loglike ;;
					   %end;
					   if _2loglike ne .;
					run;
					proc sort data=_loglike_ nodupkey;
					   by _rep _2loglike;
					run;
					data _loglike_;
					   set _loglike_;
					   drop _2loglike;
					run;
				%end;

				%if &ui > 1 %then %do;
					data  _loglike2_;
					run;
					%if &outcome2 =%str() or &se2 =%str() %then %do;
			  			data &out._pred;
			    			merge &out._pred _KF_&uvar&s22uvar._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar )
		              							                     drop=_2loglike _rho_ _tausq_ &emkfkeep   /* eMKF: additional quadratic and cubic terms to drop */
															 		 );; 
							by _rep _group_ _time;
			  			run;
			  			data &out._ests;
			    			merge &out._ests _KF_&uvar&s22uvar._ests(rename=(_2loglike=_2ll&uvar&s22uvar _rho_=_rho_&uvar&s22uvar._ _tausq_=_tausq_&uvar&s22uvar._  
																	         &emkfrename /* eMKF: additional quadratic and cubic terms to rename */
																	 ));; 
							by _rep _group_;
			  			run;
					%end;
					%else %do;
			  			data &out._pred;
			    			merge &out._pred _KF_&uvar&s22uvar._pred(rename=(prediction=pred_&uvar&s22uvar predMSE=predMSE_&uvar&s22uvar predSE=predSE_&uvar&s22uvar 
		         					                                 		 prediction2=pred2_&uvar&s22uvar predMSE2=pred2MSE_&uvar&s22uvar predSE2=pred2SE_&uvar&s22uvar )
		              							                     drop= _2loglike _rho_ _rho2_ _tausq_ _tausq2_ &emkfkeep  
															 		 );;
							by _rep _group_ _time;
			  			run;
			  			data &out._ests;
			    			merge &out._ests _KF_&uvar&s22uvar._ests(rename=(_2loglike=_2ll&uvar&s22uvar _rho_=_rho_&uvar&s22uvar._ _tausq_=_tausq_&uvar&s22uvar._  
																            &emkfrename
               														 ));; 
							by _rep _group_;
			  			run;
					%end;
					/* eMKF: Keep the log likelihood estimate for the type of model into llike1, 2, 3, 4, 5, 6, and 7 */
					/* eMKF v2.4: Model combinations in full trend break scenario are kept into llike11, 12, 13, 22, 23, 33, 44, 45, 46, 55, 56, 66, and 77*/
			  		data  _loglike2_;
					   /* modified for eMKF to allow for quad and cubic trend models and eMKF v2.4 to allow trend break options */
			   		   set _KF_&uvar&s22uvar._ests(keep= _rep _2loglike);
					   %if &s2uvar = %str() or &s2uvar = xlv %then %do;	
						   %if %upcase(&uvar)=INDEP_CUBIC  	%then llike1 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD 	%then llike2 = _2loglike ;; 
						   %if %upcase(&uvar)=INDEP_LINEAR 	%then llike3 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC 	%then llike4 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_QUAD  	%then llike5 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_LINEAR %then llike6 = _2loglike ;;
						   %if %upcase(&uvar)=DROPPED      	%then llike7 = _2loglike ;;
					   %end;
					   %else %do;
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_CUBIC  	%then llike11 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_QUAD		%then llike12 = _2loglike ;; 
						   %if %upcase(&uvar)=INDEP_CUBIC and %upcase(&s2uvar)=INDEP_LINEAR 	%then llike13 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD and %upcase(&s2uvar)=INDEP_QUAD 		%then llike22 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_QUAD and %upcase(&s2uvar)=INDEP_LINEAR 		%then llike23 = _2loglike ;;
						   %if %upcase(&uvar)=INDEP_LINEAR and %upcase(&s2uvar)=INDEP_LINEAR 	%then llike33 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC and %upcase(&s2uvar)=COMMON_CUBIC 	%then llike44 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC and %upcase(&s2uvar)=COMMON_QUAD		%then llike45 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_CUBIC  and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike46 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_QUAD and %upcase(&s2uvar)=COMMON_QUAD		%then llike55 = _2loglike ;; 
						   %if %upcase(&uvar)=COMMON_QUAD and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike56 = _2loglike ;;
						   %if %upcase(&uvar)=COMMON_LINEAR and %upcase(&s2uvar)=COMMON_LINEAR 	%then llike66 = _2loglike ;;
						   %if %upcase(&uvar)=DROPPED and %upcase(&s2uvar)=DROPPED  			%then llike77 = _2loglike ;;
					   %end;
			   		   if _2loglike ne .;
			  		run;
			  		proc sort data=_loglike2_ nodupkey;
			   			by _rep _2loglike;
			  		run;
			  		data _loglike2_;
			   			set _loglike2_;
			   			drop _2loglike;
			  		run;
		      		data _loglike_;
			   			merge _loglike_ _loglike2_;
			   			by _rep;
			  		run;
				%end;

				%let uvar=; %let s2uvar=;

 			%end; /*End of do ui loop */

			/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
			%put ;
			%put MKF macro is now approximating Bayes factors using the BIC.;

			/* eMKF v2.4: when no breakpoint is specified, for a level shift only, or with two outcomes, proceed as in previous eMKF version */
			%if &breakPoint = %str() or (&breakPoint ^= %str() and %upcase(&breakType) = LEVEL_BREAK) %then %do;

			    data _loglike_; 	/* eMKF: modified to allow for quad and cubic trend models */
					 set _loglike_;

					 df1 = 3 * &ug; 
					 df2 = 2 * &ug;
					 df3 = 1 * &ug;
					 /* eMKF v2.4 streamlining: with only 1 group, common trend models are redundant */
					 df4 = .; 
					 df5 = .; 
					 df6 = .; 
					 %if &ug > 1 %then %do; 
						df4 = 3; 
					 	df5 = 2;
					 	df6 = 1;
					 %end; 
					 df7 = 0; 

					 ntime=&un;

					 /* eMFK v2.4 streamlining: recall that difll** = simpler minus more complex model, and llikeX = - twice loglikelihood for model X */
					 /* Additionally, when &ug = 1, llike4, llike5, and llike6 will remain  = . and not enter into calculations */
					 difll67=llike7 - llike6;
					 difll57=llike7 - llike5;
					 difll47=llike7 - llike4;
					 difll37=llike7 - llike3;
					 difll27=llike7 - llike2;
					 difll17=llike7 - llike1;

					 difll56=llike6 - llike5;
					 difll46=llike6 - llike4;
					 difll36=llike6 - llike3;
					 difll26=llike6 - llike2;
					 difll16=llike6 - llike1;

					 difll45=llike5 - llike4;						 
					 difll35=llike5 - llike3; 
					 difll25=llike5 - llike2;
					 difll15=llike5 - llike1;

					 /* eMFK v2.4 streamlining: for &ug=2 groups, common_cubic is more complex than indep_linear */
					 difll34 = .;
					 %if &ug > 2 %then difll34=llike4 - llike3;; 
					 difll24=llike4 - llike2;
					 difll14=llike4 - llike1;

					 difll43 = .;
					 %if &ug = 2 %then difll43=llike3 - llike4;; 
					 difll23=llike3 - llike2;
					 difll13=llike3 - llike1;

					 difll12=llike2 - llike1;
					 
					 /* eMKF v2.4 streamlining: recall that difference in loglikelihood is set to zero if simpler model has larger likelihood */
					 if difll67 < 0 and difll67 ne . then difll67=0;
					 if difll57 < 0 and difll57 ne . then difll57=0;
					 if difll47 < 0 and difll47 ne . then difll47=0;
					 if difll37 < 0 and difll37 ne . then difll37=0;
					 if difll27 < 0 and difll27 ne . then difll27=0;
					 if difll17 < 0 and difll17 ne . then difll17=0;

					 if difll56 < 0 and difll56 ne . then difll56=0;
					 if difll46 < 0 and difll46 ne . then difll46=0;
					 if difll36 < 0 and difll36 ne . then difll36=0;
					 if difll26 < 0 and difll26 ne . then difll26=0;
					 if difll16 < 0 and difll16 ne . then difll16=0;

					 if difll45 < 0 and difll45 ne . then difll45=0;
					 if difll35 < 0 and difll35 ne . then difll35=0; 
					 if difll25 < 0 and difll25 ne . then difll25=0;
					 if difll15 < 0 and difll15 ne . then difll15=0;

					 %if &ug > 2 %then if difll34 < 0 and difll34 ne . then difll34=0;; 
					 if difll24 < 0 and difll24 ne . then difll24=0;
					 if difll14 < 0 and difll14 ne . then difll14=0;

					 %if &ug = 2 %then if difll43 < 0 and difll43 ne . then difll43=0;; 
					 if difll23 < 0 and difll23 ne . then difll23=0;
					 if difll13 < 0 and difll13 ne . then difll13=0;

					 if difll12 < 0 and difll12 ne . then difll12=0;

					 df67=df6-df7;
					 df57=df5-df7;
					 df47=df4-df7;
					 df37=df3-df7;
					 df27=df2-df7;
					 df17=df1-df7;

					 df56=df5-df6;
					 df46=df4-df6;
					 df36=df3-df6;
					 df26=df2-df6;
					 df16=df1-df6;

					 df45=df4-df5;
					 df35=df3-df5;
					 df25=df2-df5;
					 df15=df1-df5;

					 df34=.;
					 %if &ug > 2 %then df34=df3-df4;;
					 df24=df2-df4;
					 df14=df1-df4;

					 df43=.;
					 %if &ug = 2 %then df43=df4-df3;;
					 df23=df2-df3;
					 df13=df1-df3;

					 df12=df1-df2;

					 bic67= df67*log(&ug * &un) - difll67;
					 bic57= df57*log(&ug * &un) - difll57; 
					 bic47= df47*log(&ug * &un) - difll47;
					 bic37= df37*log(&ug * &un) - difll37;
					 bic27= df27*log(&ug * &un) - difll27;
					 bic17= df17*log(&ug * &un) - difll17;

					 bic56= df56*log(&ug * &un) - difll56;
					 bic46= df46*log(&ug * &un) - difll46;
					 bic36= df36*log(&ug * &un) - difll36;
					 bic26= df26*log(&ug * &un) - difll26;
					 bic16= df16*log(&ug * &un) - difll16;

					 bic45= df45*log(&ug * &un) - difll45;
					 bic35= df35*log(&ug * &un) - difll35;
					 bic25= df25*log(&ug * &un) - difll25;
					 bic15= df15*log(&ug * &un) - difll15;

					 bic34=.;
					 %if &ug > 2 %then bic34= df34*log(&ug * &un) - difll34;;
					 bic24= df24*log(&ug * &un) - difll24;
					 bic14= df14*log(&ug * &un) - difll14;

					 bic43=.;
					 %if &ug = 2 %then bic43= df43*log(&ug * &un) - difll43;;
					 bic23= df23*log(&ug * &un) - difll23;
					 bic13= df13*log(&ug * &un) - difll13;

					 bic12= df12*log(&ug * &un) - difll12;

					 /* eMKF: Use coalesce to force the Bayes factor to 0 when missing */
					 bf67 = coalesce(exp(-0.5*bic67), 0);
					 bf57 = coalesce(exp(-0.5*bic57), 0);
					 bf47 = coalesce(exp(-0.5*bic47), 0);
					 bf37 = coalesce(exp(-0.5*bic37), 0);
					 bf27 = coalesce(exp(-0.5*bic27), 0);
					 bf17 = coalesce(exp(-0.5*bic17), 0);

					 bf56 = coalesce(exp(-0.5*bic56), 0);
					 bf46 = coalesce(exp(-0.5*bic46), 0);
					 bf36 = coalesce(exp(-0.5*bic36), 0);
					 bf26 = coalesce(exp(-0.5*bic26), 0);
					 bf16 = coalesce(exp(-0.5*bic16), 0);

					 bf45 = coalesce(exp(-0.5*bic45), 0);
					 bf35 = coalesce(exp(-0.5*bic35), 0); 
					 bf25 = coalesce(exp(-0.5*bic25), 0);
					 bf15 = coalesce(exp(-0.5*bic15), 0);

					 bf34=0;
					 %if &ug > 2 %then bf34 = coalesce(exp(-0.5*bic34), 0);;
					 bf24 = coalesce(exp(-0.5*bic24), 0);
					 bf14 = coalesce(exp(-0.5*bic14), 0);

					 bf43=0;
					 %if &ug = 2 %then bf43 = coalesce(exp(-0.5*bic43), 0);;
					 bf23 = coalesce(exp(-0.5*bic23), 0);
					 bf13 = coalesce(exp(-0.5*bic13), 0);

					 bf12 = coalesce(exp(-0.5*bic12), 0);

					 /* Let's setup something in case one of the models did not converge */
					 /* eMKF: Expanded to account for various combinations up to 7 models */
					 /* eMKF: Instead of working through all the combinatorial sequences, BF was set to 0 when missing */

					 /* eMKF: Identify simplest available model and use it as reference for the Bayes factor-based weight calculations. */ 

					 /* eMKF: Model 7 was requested, is the simplest, and at least one other model was requested and converged */
					 if difll67 ne . or difll57 ne . or difll47 ne . or difll37 ne . or difll27 ne . or difll17 ne . then do; 
					 	p1 = bf17 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 	p2 = bf27 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 	p3 = bf37 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 	p4 = bf47 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 	p5 = bf57 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 	p6 = bf67 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
						p7 =    1 /(1+bf17+bf27+bf37+bf47+bf57+bf67);
					 end;
					 else do;
					 	/* eMKF: Model 6 was requested, is the simplest, and at least one other model was requested and converged */
						if difll56 ne . or difll46 ne . or difll36 ne . or difll26 ne . or difll16 ne . then do; 
							p1 = bf16 /(1+bf16+bf26+bf36+bf46+bf56);
						 	p2 = bf26 /(1+bf16+bf26+bf36+bf46+bf56);
						 	p3 = bf36 /(1+bf16+bf26+bf36+bf46+bf56);
						 	p4 = bf46 /(1+bf16+bf26+bf36+bf46+bf56);
						 	p5 = bf56 /(1+bf16+bf26+bf36+bf46+bf56);
						 	p6 =    1 /(1+bf16+bf26+bf36+bf46+bf56);
							p7 =    0;
						end;
						else do;
							/* eMKF: Model 5 was requested, is the simplest, and at least one other model was requested and converged.
						     * This will be superseded by the previous clauses when both models 3 and 5 are selected 
							 * because the code ensure models 6 or 7 are included 
							 */
							if difll45 ne . or difll35 ne . or difll25 ne . or difll15 ne . then do; 
								p1 = bf15 /(1+bf15+bf25+bf35+bf45);
								p2 = bf25 /(1+bf15+bf25+bf35+bf45);
							 	p3 = bf35 /(1+bf15+bf25+bf35+bf45);
							 	p4 = bf45 /(1+bf15+bf25+bf35+bf45);
							 	p5 =    1 /(1+bf15+bf25+bf35+bf45);
							 	p6 =    0;
								p7 =    0;
							end;
					 		else do;
								/* eMKF: Model 4 was requested, is the simplest, and at least one other model was requested and converged.
							 	 * This will be superseded by the previous clauses when both models 2 and 4 are selected 
								 *  because the code will ensure models 5, 6 or 7 is included.
							 	 * Similarly if both models 3 and 4 had been selected 
							 	 */
								if difll34 ne . or difll24 ne . or difll14 ne . or difll43 ne . or difll23 ne . or difll13 ne . then do; 
									%if &ug > 2 %then %do;
										if difll34 ne . or difll24 ne . or difll14 ne . then do; 
										 	p1 = bf14 /(1+bf14+bf24+bf34);
										 	p2 = bf24 /(1+bf14+bf24+bf34);
										 	p3 = bf34 /(1+bf14+bf24+bf34);
										 	p4 = 	1 /(1+bf14+bf24+bf34);
										 	p5 =    0;
										 	p6 =    0;
											p7 =    0;
										end;
										else do; 
									 		/* eMKF: Model 3 was requested, is the simplest, and at least one other model was requested and converged */
											if difll23 ne . or difll13 ne . then do; 
										 		p1 = bf13 /(1+bf13+bf23);
										 		p2 = bf23 /(1+bf13+bf23);
										 		p3 = 	1 /(1+bf13+bf23);
										 		p4 = 	0;
										 		p5 =    0;
										 		p6 =    0;
												p7 =    0;
										 	end;
										end;
									%end;
 									/* eMFK v2.4 streamlining: for &ug=2 groups, common_cubic is more complex than indep_linear (swap models 4 and 3) */
									%if &ug = 2 %then %do;
										if difll43 ne . or difll23 ne . or difll13 ne . then do; 
										 	p1 = bf13 /(1+bf13+bf23+bf43);
										 	p2 = bf23 /(1+bf13+bf23+bf43);
										 	p3 = 	1 /(1+bf13+bf23+bf43);
										 	p4 = bf43 /(1+bf13+bf23+bf43);
										 	p5 =    0;
										 	p6 =    0;
											p7 =    0;
										end;
										else do; 
											if difll24 ne . or difll14 ne . then do; 
										 		p1 = bf14 /(1+bf14+bf24);
										 		p2 = bf24 /(1+bf14+bf24);
										 		p3 = 	0;
										 		p4 = 	1 /(1+bf14+bf24);
										 		p5 =    0;
										 		p6 =    0;
												p7 =    0;
										 	end;
										end;
									%end;
								end;
						 	 	else do;
						 	 		/* eMKF: Models 2 and 1 were requested and converged */
								 	if difll12 ne . then do; 
								 		p1 = bf12 /(1+bf12);
								 		p2 =    1 /(1+bf12);
								 		p3 = 	0;
								 		p4 = 	0;
								 		p5 =    0;
								 		p6 =    0;
										p7 =    0;
									end;
				 				end;
							end;
						end;
					end;
			    run; /* eMKF: runs data step */
			%end;

			/* eMKF v2.4: For a full break with a single outcome, account for trend in segment 2 */
			/* eMKF v2.4: Note that the dropped (intercepts-only) model in segment 2 is disallowed, unless it is also used in segment 1 */
			%if &breakPoint ^= %str() and %upcase(&breakType) = FULL_BREAK %then %do;

			    data _loglike_;
					 set _loglike_;

					 df11 = 6 * &ug; 
					 df12 = 5 * &ug;
					 df13 = 4 * &ug; 
					 df22 = 4 * &ug;
					 df23 = 3 * &ug; 
					 df33 = 2 * &ug;
					 df44 = .; 
					 df45 = .;
					 df46 = .; 
					 df55 = .; 
					 df56 = .;
					 df66 = .; 
					 %if &ug > 1 %then %do;
						 df44 = 6; 
						 df45 = 5;
						 df46 = 4; 
						 df55 = 4; 
						 df56 = 3;
						 df66 = 2; 
					 %end;
					 df77 = 0;

					 ntime=&un;

					 difll6677=llike77 - llike66;
					 difll5677=llike77 - llike56;
					 difll5577=llike77 - llike55;
					 difll4677=llike77 - llike46;
					 difll4577=llike77 - llike45;
					 difll4477=llike77 - llike44;
					 difll3377=llike77 - llike33;
					 difll2377=llike77 - llike23;
					 difll2277=llike77 - llike22;
					 difll1377=llike77 - llike13;
					 difll1277=llike77 - llike12;
					 difll1177=llike77 - llike11;

					 difll5666=llike66 - llike56;
					 difll5566=llike66 - llike55;
					 difll4666=llike66 - llike46;
					 difll4566=llike66 - llike45;
					 difll4466=llike66 - llike44;
					 difll3366=llike66 - llike33;
					 difll2366=llike66 - llike23;
					 difll2266=llike66 - llike22;
					 difll1366=llike66 - llike13;
					 difll1266=llike66 - llike12;
					 difll1166=llike66 - llike11;

					 difll5556=llike56 - llike55;
					 difll4656=llike56 - llike46;
					 difll4556=llike56 - llike45;
					 difll4456=llike56 - llike44;
					 difll3356=llike56 - llike33;
					 difll2356=llike56 - llike23;
					 difll2256=llike56 - llike22;
					 difll1356=llike56 - llike13;
					 difll1256=llike56 - llike12;
					 difll1156=llike56 - llike11;

					 difll4655=llike55 - llike46;
					 difll4555=llike55 - llike45;
					 difll4455=llike55 - llike44;
					 difll3355=llike55 - llike33;
					 difll2355=llike55 - llike23;
					 difll2255=llike55 - llike22;
					 difll1355=llike55 - llike13;
					 difll1255=llike55 - llike12;
					 difll1155=llike55 - llike11;

					 difll4546=llike46 - llike45;
					 difll4446=llike46 - llike44;
					 difll3346 = .;
					 %if &ug > 2 %then difll3346=llike46 - llike33;; 
					 difll2346=llike46 - llike23;
					 difll2246=llike46 - llike22;
					 difll1346=llike46 - llike13;
					 difll1246=llike46 - llike12;
					 difll1146=llike46 - llike11;

					 difll4445=llike45 - llike44;
					 difll3345 = .;
					 %if &ug > 2 %then difll3345=llike45 - llike33;; 
					 difll2345=llike45 - llike23;
					 difll2245=llike45 - llike22;
					 difll1345=llike45 - llike13;
					 difll1245=llike45 - llike12;
					 difll1145=llike45 - llike11;

					 difll3344 = .;
					 %if &ug > 2 %then difll3344=llike44 - llike33;; 
					 difll2344=llike44 - llike23;
					 difll2244=llike44 - llike22;
					 difll1344=llike44 - llike13;
					 difll1244=llike44 - llike12;
					 difll1144=llike44 - llike11;

					 difll4633 = .;
					 %if &ug = 2 %then difll4633=llike33 - llike46;;
					 difll4533 = .;
					 %if &ug = 2 %then difll4533=llike33 - llike45;;
					 difll4433 = .;
					 %if &ug = 2 %then difll4433=llike33 - llike44;;
					 difll2333=llike33 - llike23;
					 difll2233=llike33 - llike22;
					 difll1333=llike33 - llike13;
					 difll1233=llike33 - llike12;
					 difll1133=llike33 - llike11;

					 difll2223=llike23 - llike22;
					 difll1323=llike23 - llike13;
					 difll1223=llike23 - llike12;
					 difll1123=llike23 - llike11;

					 difll1322=llike22 - llike13;
					 difll1222=llike22 - llike12;
					 difll1122=llike22 - llike11;

					 difll1213=llike13 - llike12;
					 difll1113=llike13 - llike11;

					 difll1112=llike12 - llike11;
					 
					 if difll6677 < 0 and difll6677 ne . then difll6677=0;
					 if difll5677 < 0 and difll5677 ne . then difll5677=0;
					 if difll5577 < 0 and difll5577 ne . then difll5577=0;
					 if difll4677 < 0 and difll4677 ne . then difll4677=0;
					 if difll4577 < 0 and difll4577 ne . then difll4577=0;
					 if difll4477 < 0 and difll4477 ne . then difll4477=0;
					 if difll3377 < 0 and difll3377 ne . then difll3377=0;
					 if difll2377 < 0 and difll2377 ne . then difll2377=0;
					 if difll2277 < 0 and difll2277 ne . then difll2277=0;
					 if difll1377 < 0 and difll1377 ne . then difll1377=0;
					 if difll1277 < 0 and difll1277 ne . then difll1277=0;
					 if difll1177 < 0 and difll1177 ne . then difll1177=0;

					 if difll5666 < 0 and difll5666 ne . then difll5666=0;
					 if difll5566 < 0 and difll5566 ne . then difll5566=0;
					 if difll4666 < 0 and difll4666 ne . then difll4666=0;
					 if difll4566 < 0 and difll4566 ne . then difll4566=0;
					 if difll4466 < 0 and difll4466 ne . then difll4466=0;
					 if difll3366 < 0 and difll3366 ne . then difll3366=0;
					 if difll2366 < 0 and difll2366 ne . then difll2366=0;
					 if difll2266 < 0 and difll2266 ne . then difll2266=0;
					 if difll1366 < 0 and difll1366 ne . then difll1366=0;
					 if difll1266 < 0 and difll1266 ne . then difll1266=0;
					 if difll1166 < 0 and difll1166 ne . then difll1166=0;

					 if difll5556 < 0 and difll5556 ne . then difll5556=0;
					 if difll4656 < 0 and difll4656 ne . then difll4656=0;
					 if difll4556 < 0 and difll4556 ne . then difll4556=0;
					 if difll4456 < 0 and difll4456 ne . then difll4456=0;
					 if difll3356 < 0 and difll3356 ne . then difll3356=0;
					 if difll2356 < 0 and difll2356 ne . then difll2356=0;
					 if difll2256 < 0 and difll2256 ne . then difll2256=0;
					 if difll1356 < 0 and difll1356 ne . then difll1356=0;
					 if difll1256 < 0 and difll1256 ne . then difll1256=0;
					 if difll1156 < 0 and difll1156 ne . then difll1156=0;

					 if difll4655 < 0 and difll4655 ne . then difll4655=0;
					 if difll4555 < 0 and difll4555 ne . then difll4555=0;
					 if difll4455 < 0 and difll4455 ne . then difll4455=0;
					 if difll3355 < 0 and difll3355 ne . then difll3355=0;
					 if difll2355 < 0 and difll2355 ne . then difll2355=0;
					 if difll2255 < 0 and difll2255 ne . then difll2255=0;
					 if difll1355 < 0 and difll1355 ne . then difll1355=0;
					 if difll1255 < 0 and difll1255 ne . then difll1255=0;
					 if difll1155 < 0 and difll1155 ne . then difll1155=0;

					 if difll4546 < 0 and difll4546 ne . then difll4546=0;
					 if difll4446 < 0 and difll4446 ne . then difll4446=0;
					 %if &ug > 2 %then if difll3346 < 0 and difll3346 ne . then difll3346=0;;
					 if difll2346 < 0 and difll2346 ne . then difll2346=0;
					 if difll2246 < 0 and difll2246 ne . then difll2246=0;
					 if difll1346 < 0 and difll1346 ne . then difll1346=0;
					 if difll1246 < 0 and difll1246 ne . then difll1246=0;
					 if difll1146 < 0 and difll1146 ne . then difll1146=0;

					 if difll4445 < 0 and difll4445 ne . then difll4445=0;
					 %if &ug > 2 %then if difll3345 < 0 and difll3345 ne . then difll3345=0;;
					 if difll2345 < 0 and difll2345 ne . then difll2345=0;
					 if difll2245 < 0 and difll2245 ne . then difll2245=0;
					 if difll1345 < 0 and difll1345 ne . then difll1345=0;
					 if difll1245 < 0 and difll1245 ne . then difll1245=0;
					 if difll1145 < 0 and difll1145 ne . then difll1145=0;

					 %if &ug > 2 %then if difll3344 < 0 and difll3344 ne . then difll3344=0;;
					 if difll2344 < 0 and difll2344 ne . then difll2344=0;
					 if difll2244 < 0 and difll2244 ne . then difll2244=0;
					 if difll1344 < 0 and difll1344 ne . then difll1344=0;
					 if difll1244 < 0 and difll1244 ne . then difll1244=0;
					 if difll1144 < 0 and difll1144 ne . then difll1144=0;

					 %if &ug = 2 %then if difll4633 < 0 and difll4633 ne . then difll4633=0;;
					 %if &ug = 2 %then if difll4533 < 0 and difll4533 ne . then difll4533=0;;
					 %if &ug = 2 %then if difll4433 < 0 and difll4433 ne . then difll4433=0;;
					 if difll2333 < 0 and difll2333 ne . then difll2333=0;
					 if difll2233 < 0 and difll2233 ne . then difll2233=0;
					 if difll1333 < 0 and difll1333 ne . then difll1333=0;
					 if difll1233 < 0 and difll1233 ne . then difll1233=0;
					 if difll1133 < 0 and difll1133 ne . then difll1133=0;

					 if difll2223 < 0 and difll2223 ne . then difll2223=0;
					 if difll1323 < 0 and difll1323 ne . then difll1323=0;
					 if difll1223 < 0 and difll1223 ne . then difll1223=0;
					 if difll1123 < 0 and difll1123 ne . then difll1123=0;

					 if difll1322 < 0 and difll1322 ne . then difll1322=0; 
					 if difll1222 < 0 and difll1222 ne . then difll1222=0;
					 if difll1122 < 0 and difll1122 ne . then difll1122=0;

					 if difll1213 < 0 and difll1213 ne . then difll1213=0;
					 if difll1113 < 0 and difll1113 ne . then difll1113=0;

					 if difll1112 < 0 and difll1112 ne . then difll1112=0;

					 df6677=df66-df77;
					 df5677=df56-df77;
					 df5577=df55-df77;
					 df4677=df46-df77;
					 df4577=df45-df77;
					 df4477=df44-df77;
					 df3377=df33-df77;
					 df2377=df23-df77;
					 df2277=df22-df77;
					 df1377=df13-df77;
					 df1277=df12-df77;
					 df1177=df11-df77;

					 df5666=df56-df66;
					 df5566=df55-df66;
					 df4666=df46-df66;
					 df4566=df45-df66;
					 df4466=df44-df66;
					 df3366=df33-df66;
					 df2366=df23-df66;
					 df2266=df22-df66;
					 df1366=df13-df66;
					 df1266=df12-df66;
					 df1166=df11-df66;

					 df5556=df55-df56;
					 df4656=df46-df56;
					 df4556=df45-df56;
					 df4456=df44-df56;
					 df3356=df33-df56;
					 df2356=df23-df56;
					 df2256=df22-df56;
					 df1356=df13-df56;
					 df1256=df12-df56;
					 df1156=df11-df56;

					 df4655=df46-df55;
					 df4555=df45-df55;
					 df4455=df44-df55;
					 df3355=df33-df55;
					 df2355=df23-df55;
					 df2255=df22-df55;
					 df1355=df13-df55;
					 df1255=df12-df55;
					 df1155=df11-df55;

					 df4546=df45-df46;
					 df4446=df44-df46;
					 df3346=.;
					 %if &ug > 2 %then df3346=df33-df46;;
					 df2346=df23-df46;
					 df2246=df22-df46;
					 df1346=df13-df46;
					 df1246=df12-df46;
					 df1146=df11-df46;

					 df4445=df44-df45;
					 df3345=.;
					 %if &ug > 2 %then df3345=df33-df45;;
					 df2345=df23-df45;
					 df2245=df22-df45;
					 df1345=df13-df45;
					 df1245=df12-df45;
					 df1145=df11-df45;

					 df3344=.;
					 %if &ug > 2 %then df3344=df33-df44;;
					 df2344=df23-df44;
					 df2244=df22-df44;
					 df1344=df13-df44;
					 df1244=df12-df44;
					 df1144=df11-df44;

					 df4633=.;
					 %if &ug = 2 %then df4633=df46-df33;;
					 df4533=.;
					 %if &ug = 2 %then df4533=df45-df33;;
					 df4433=.;
					 %if &ug = 2 %then df4433=df44-df33;;
					 df2333=df23-df33;
					 df2233=df22-df33;
					 df1333=df13-df33;
					 df1233=df12-df33;
					 df1133=df11-df33;

					 df2223=df22-df23;
					 df1323=df13-df23;
					 df1223=df12-df23;
					 df1123=df11-df23;

					 df1322=df13-df22;
					 df1222=df12-df22;
					 df1122=df11-df22;

					 df1213=df12-df13;
					 df1113=df11-df13;

					 df1112=df11-df12;

					 bic6677= df6677*log(&ug * &un) - difll6677;
					 bic5677= df5677*log(&ug * &un) - difll5677; 
					 bic5577= df5577*log(&ug * &un) - difll5577; 
					 bic4677= df4677*log(&ug * &un) - difll4677;
					 bic4577= df4577*log(&ug * &un) - difll4577;
					 bic4477= df4477*log(&ug * &un) - difll4477;
					 bic3377= df3377*log(&ug * &un) - difll3377;
					 bic2377= df2377*log(&ug * &un) - difll2377;
					 bic2277= df2277*log(&ug * &un) - difll2277;
					 bic1377= df1377*log(&ug * &un) - difll1377;
					 bic1277= df1277*log(&ug * &un) - difll1277;
					 bic1177= df1177*log(&ug * &un) - difll1177;

					 bic5666= df5666*log(&ug * &un) - difll5666; 
					 bic5566= df5566*log(&ug * &un) - difll5566; 
					 bic4666= df4666*log(&ug * &un) - difll4666;
					 bic4566= df4566*log(&ug * &un) - difll4566;
					 bic4466= df4466*log(&ug * &un) - difll4466;
					 bic3366= df3366*log(&ug * &un) - difll3366;
					 bic2366= df2366*log(&ug * &un) - difll2366;
					 bic2266= df2266*log(&ug * &un) - difll2266;
					 bic1366= df1366*log(&ug * &un) - difll1366;
					 bic1266= df1266*log(&ug * &un) - difll1266;
					 bic1166= df1166*log(&ug * &un) - difll1166;

					 bic5556= df5556*log(&ug * &un) - difll5556; 
					 bic4656= df4656*log(&ug * &un) - difll4656;
					 bic4556= df4556*log(&ug * &un) - difll4556;
					 bic4456= df4456*log(&ug * &un) - difll4456;
					 bic3356= df3356*log(&ug * &un) - difll3356;
					 bic2356= df2356*log(&ug * &un) - difll2356;
					 bic2256= df2256*log(&ug * &un) - difll2256;
					 bic1356= df1356*log(&ug * &un) - difll1356;
					 bic1256= df1256*log(&ug * &un) - difll1256;
					 bic1156= df1156*log(&ug * &un) - difll1156;

					 bic4655= df4655*log(&ug * &un) - difll4655;
					 bic4555= df4555*log(&ug * &un) - difll4555;
					 bic4455= df4455*log(&ug * &un) - difll4455;
					 bic3355= df3355*log(&ug * &un) - difll3355;
					 bic2355= df2355*log(&ug * &un) - difll2355;
					 bic2255= df2255*log(&ug * &un) - difll2255;
					 bic1355= df1355*log(&ug * &un) - difll1355;
					 bic1255= df1255*log(&ug * &un) - difll1255;
					 bic1155= df1155*log(&ug * &un) - difll1155;

					 bic4546= df4546*log(&ug * &un) - difll4546;
					 bic4446= df4446*log(&ug * &un) - difll4446;
					 bic3346=.;
					 %if &ug > 2 %then bic3346= df3346*log(&ug * &un) - difll3346;;
					 bic2346= df2346*log(&ug * &un) - difll2346;
					 bic2246= df2246*log(&ug * &un) - difll2246;
					 bic1346= df1346*log(&ug * &un) - difll1346;
					 bic1246= df1246*log(&ug * &un) - difll1246;
					 bic1146= df1146*log(&ug * &un) - difll1146;

					 bic4445= df4445*log(&ug * &un) - difll4445;
					 bic3345=.;
					 %if &ug > 2 %then bic3345= df3345*log(&ug * &un) - difll3345;;
					 bic2345= df2345*log(&ug * &un) - difll2345;
					 bic2245= df2245*log(&ug * &un) - difll2245;
					 bic1345= df1345*log(&ug * &un) - difll1345;
					 bic1245= df1245*log(&ug * &un) - difll1245;
					 bic1145= df1145*log(&ug * &un) - difll1145;

					 bic3344=.;
					 %if &ug > 2 %then bic3344= df3344*log(&ug * &un) - difll3344;;
					 bic2344= df2344*log(&ug * &un) - difll2344;
					 bic2244= df2244*log(&ug * &un) - difll2244;
					 bic1344= df1344*log(&ug * &un) - difll1344;
					 bic1244= df1244*log(&ug * &un) - difll1244;
					 bic1144= df1144*log(&ug * &un) - difll1144;

					 bic4633=.;
					 %if &ug = 2 %then bic4633= df4633*log(&ug * &un) - difll4633;;
					 bic4533=.;
					 %if &ug = 2 %then bic4533= df4533*log(&ug * &un) - difll4533;;
					 bic4433=.;
					 %if &ug = 2 %then bic4433= df4433*log(&ug * &un) - difll4433;;
					 bic2333= df2333*log(&ug * &un) - difll2333;
					 bic2233= df2233*log(&ug * &un) - difll2233;
					 bic1333= df1333*log(&ug * &un) - difll1333;
					 bic1233= df1233*log(&ug * &un) - difll1233;
					 bic1133= df1133*log(&ug * &un) - difll1133;

					 bic2223= df2223*log(&ug * &un) - difll2223;
					 bic1323= df1323*log(&ug * &un) - difll1323;
					 bic1223= df1223*log(&ug * &un) - difll1223;
					 bic1123= df1123*log(&ug * &un) - difll1123;

					 bic1322= df1322*log(&ug * &un) - difll1322;
					 bic1222= df1222*log(&ug * &un) - difll1222;
					 bic1122= df1122*log(&ug * &un) - difll1122;

					 bic1213= df1213*log(&ug * &un) - difll1213;
					 bic1113= df1113*log(&ug * &un) - difll1113;

					 bic1112= df1112*log(&ug * &un) - difll1112;

					 bf6677 = coalesce(exp(-0.5*bic6677), 0);
					 bf5677 = coalesce(exp(-0.5*bic5677), 0);
					 bf5577 = coalesce(exp(-0.5*bic5577), 0);
					 bf4677 = coalesce(exp(-0.5*bic4677), 0);
					 bf4577 = coalesce(exp(-0.5*bic4577), 0);
					 bf4477 = coalesce(exp(-0.5*bic4477), 0);
					 bf3377 = coalesce(exp(-0.5*bic3377), 0);
					 bf2377 = coalesce(exp(-0.5*bic2377), 0);
					 bf2277 = coalesce(exp(-0.5*bic2277), 0);
					 bf1377 = coalesce(exp(-0.5*bic1377), 0);
					 bf1277 = coalesce(exp(-0.5*bic1277), 0);
					 bf1177 = coalesce(exp(-0.5*bic1177), 0);

					 bf5666 = coalesce(exp(-0.5*bic5666), 0);
					 bf5566 = coalesce(exp(-0.5*bic5566), 0);
					 bf4666 = coalesce(exp(-0.5*bic4666), 0);
					 bf4566 = coalesce(exp(-0.5*bic4566), 0);
					 bf4466 = coalesce(exp(-0.5*bic4466), 0);
					 bf3366 = coalesce(exp(-0.5*bic3366), 0);
					 bf2366 = coalesce(exp(-0.5*bic2366), 0);
					 bf2266 = coalesce(exp(-0.5*bic2266), 0);
					 bf1366 = coalesce(exp(-0.5*bic1366), 0);
					 bf1266 = coalesce(exp(-0.5*bic1266), 0);
					 bf1166 = coalesce(exp(-0.5*bic1166), 0);

					 bf5556 = coalesce(exp(-0.5*bic5556), 0);
					 bf4656 = coalesce(exp(-0.5*bic4656), 0);
					 bf4556 = coalesce(exp(-0.5*bic4556), 0);
					 bf4456 = coalesce(exp(-0.5*bic4456), 0);
					 bf3356 = coalesce(exp(-0.5*bic3356), 0);
					 bf2356 = coalesce(exp(-0.5*bic2356), 0);
					 bf2256 = coalesce(exp(-0.5*bic2256), 0);
					 bf1356 = coalesce(exp(-0.5*bic1356), 0);
					 bf1256 = coalesce(exp(-0.5*bic1256), 0);
					 bf1156 = coalesce(exp(-0.5*bic1156), 0);

					 bf4655 = coalesce(exp(-0.5*bic4655), 0);
					 bf4555 = coalesce(exp(-0.5*bic4555), 0);
					 bf4455 = coalesce(exp(-0.5*bic4455), 0);
					 bf3355 = coalesce(exp(-0.5*bic3355), 0);
					 bf2355 = coalesce(exp(-0.5*bic2355), 0);
					 bf2255 = coalesce(exp(-0.5*bic2255), 0);
					 bf1355 = coalesce(exp(-0.5*bic1355), 0);
					 bf1255 = coalesce(exp(-0.5*bic1255), 0);
					 bf1155 = coalesce(exp(-0.5*bic1155), 0);

					 bf4546 = coalesce(exp(-0.5*bic4546), 0);
					 bf4446 = coalesce(exp(-0.5*bic4446), 0);
					 bf3346=0;
					 %if &ug > 2 %then bf3346 = coalesce(exp(-0.5*bic3346), 0);;
					 bf2346 = coalesce(exp(-0.5*bic2346), 0);
					 bf2246 = coalesce(exp(-0.5*bic2246), 0);
					 bf1346 = coalesce(exp(-0.5*bic1346), 0);
					 bf1246 = coalesce(exp(-0.5*bic1246), 0);
					 bf1146 = coalesce(exp(-0.5*bic1146), 0);

					 bf4445 = coalesce(exp(-0.5*bic4445), 0);
					 bf3345=0;
					 %if &ug > 2 %then bf3345 = coalesce(exp(-0.5*bic3345), 0);;
					 bf2345 = coalesce(exp(-0.5*bic2345), 0);
					 bf2245 = coalesce(exp(-0.5*bic2245), 0);
					 bf1345 = coalesce(exp(-0.5*bic1345), 0);
					 bf1245 = coalesce(exp(-0.5*bic1245), 0);
					 bf1145 = coalesce(exp(-0.5*bic1145), 0);

					 bf3344=0;
					 %if &ug > 2 %then bf3344 = coalesce(exp(-0.5*bic3344), 0);;
					 bf2344 = coalesce(exp(-0.5*bic2344), 0);
					 bf2244 = coalesce(exp(-0.5*bic2244), 0);
					 bf1344 = coalesce(exp(-0.5*bic1344), 0);
					 bf1244 = coalesce(exp(-0.5*bic1244), 0);
					 bf1144 = coalesce(exp(-0.5*bic1144), 0);

					 bf4633=0;
					 %if &ug = 2 %then bf4633= coalesce(exp(-0.5*bic4633), 0);;
					 bf4533=0;
					 %if &ug = 2 %then bf4533= coalesce(exp(-0.5*bic4533), 0);;
					 bf4433=0;
					 %if &ug = 2 %then bf4433= coalesce(exp(-0.5*bic4433), 0);;
					 bf2333 = coalesce(exp(-0.5*bic2333), 0);
					 bf2233 = coalesce(exp(-0.5*bic2233), 0);
					 bf1333 = coalesce(exp(-0.5*bic1333), 0);
					 bf1233 = coalesce(exp(-0.5*bic1233), 0);
					 bf1133 = coalesce(exp(-0.5*bic1133), 0);

					 bf2223 = coalesce(exp(-0.5*bic2223), 0);
					 bf1323 = coalesce(exp(-0.5*bic1323), 0);
					 bf1223 = coalesce(exp(-0.5*bic1223), 0);
					 bf1123 = coalesce(exp(-0.5*bic1123), 0);

					 bf1322 = coalesce(exp(-0.5*bic1322), 0);
					 bf1222 = coalesce(exp(-0.5*bic1222), 0);
					 bf1122 = coalesce(exp(-0.5*bic1122), 0);

					 bf1213 = coalesce(exp(-0.5*bic1213), 0);
					 bf1113 = coalesce(exp(-0.5*bic1113), 0);

					 bf1112 = coalesce(exp(-0.5*bic1112), 0);

					 /* eMKF v2.4: Model 77 was requested, is the simplest, and at least one other model was requested and converged */
					 if difll6677 ne . or difll5677 ne . or difll5577 ne . or difll4677 ne . or difll4577 ne . or difll4477 ne . or 
						difll3377 ne . or difll2377 ne . or difll2277 ne . or difll1377 ne . or difll1277 ne . or difll1177 ne . then do; 
					 	p11 = bf1177 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p12 = bf1277 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p13 = bf1377 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p22 = bf2277 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p23 = bf2377 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p33 = bf3377 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p44 = bf4477 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p45 = bf4577 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p46 = bf4677 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p55 = bf5577 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p56 = bf5677 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 	p66 = bf6677 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
						p77 =      1 /(1+bf1177+bf1277+bf1377+bf2277+bf2377+bf3377+bf4477+bf4577+bf4677+bf5577+bf5677+bf6677);
					 end;
					 else do;
					 	/* eMKF v2.4: Model 66 was requested, is the simplest, and at least one other model was requested and converged */
						if difll5666 ne . or difll5566 ne . or difll4666 ne . or difll4566 ne . or difll4466 ne . or difll3366 ne . or 
						   difll2366 ne . or difll2266 ne . or difll1366 ne . or difll1266 ne . or difll1166 ne . then do; 
						 	p11 = bf1166 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p12 = bf1266 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p13 = bf1366 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p22 = bf2266 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p23 = bf2366 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p33 = bf3366 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p44 = bf4466 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p45 = bf4566 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p46 = bf4666 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p55 = bf5566 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p56 = bf5666 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
						 	p66 =      1 /(1+bf1166+bf1266+bf1366+bf2266+bf2366+bf3366+bf4466+bf4566+bf4666+bf5566+bf5666);
							p77 =      0;
						end;
						else do;
						 	/* eMKF v2.4: Model 56 was requested, is the simplest, and at least one other model was requested and converged */
							if difll5556 ne . or difll4656 ne . or difll4556 ne . or difll4456 ne . or difll3356 ne . or difll2356 ne . or 
							   difll2256 ne . or difll1356 ne . or difll1256 ne . or difll1156 ne . then do; 
							 	p11 = bf1156 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p12 = bf1256 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p13 = bf1356 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p22 = bf2256 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p23 = bf2356 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p33 = bf3356 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p44 = bf4456 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p45 = bf4556 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p46 = bf4656 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p55 = bf5556 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p56 =      1 /(1+bf1156+bf1256+bf1356+bf2256+bf2356+bf3356+bf4456+bf4556+bf4656+bf5556);
							 	p66 =      0;
								p77 =      0;
							end;
					 		else do;
							 	/* eMKF v2.4: Model 55 was requested, is the simplest, and at least one other model was requested and converged */
								if difll4655 ne . or difll4555 ne . or difll4455 ne . or difll3355 ne . or difll2355 ne . or difll2255 ne . or 
								   difll1355 ne . or difll1255 ne . or difll1155 ne . then do; 
								 	p11 = bf1155 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p12 = bf1255 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p13 = bf1355 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p22 = bf2255 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p23 = bf2355 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p33 = bf3355 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p44 = bf4455 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p45 = bf4555 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p46 = bf4655 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p55 =      1 /(1+bf1155+bf1255+bf1355+bf2255+bf2355+bf3355+bf4455+bf4555+bf4655);
								 	p56 =      0;
								 	p66 =      0;
									p77 =      0;
								end;
								else do;
									if difll4546 ne . or difll4446 ne . or difll3346 ne . or difll2346 ne . or difll2246 ne . or difll1346 ne . or 
									   difll1246 ne . or difll1146 ne . or difll4445 ne . or difll3345 ne . or difll2345 ne . or difll2245 ne . or  
									   difll1345 ne . or difll1245 ne . or difll1145 ne . or difll3344 ne . or difll2344 ne . or difll2244 ne . or  
									   difll1344 ne . or difll1244 ne . or difll1144 ne . or difll2333 ne . or difll2233 ne . or difll1333 ne . or 
									   difll1233 ne . or difll1133 ne . or difll4633 ne . or difll4533 ne . or difll4433 ne . then do;
									   %if &ug > 2 %then %do;
										 	/* eMKF v2.4: Model 46 was requested, is the simplest, and at least one other model was requested and converged */
											if difll4546 ne . or difll4446 ne . or difll3346 ne . or difll2346 ne . or difll2246 ne . or difll1346 ne . or 
											   difll1246 ne . or difll1146 ne . then do; 
											 	p11 = bf1146 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p12 = bf1246 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p13 = bf1346 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p22 = bf2246 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p23 = bf2346 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p33 = bf3346 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p44 = bf4446 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p45 = bf4546 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p46 =      1 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf3346+bf4446+bf4546);
											 	p55 =      0;
											 	p56 =      0;
											 	p66 =      0;
												p77 =      0;
											end;
									 	 	else do;
											 	/* eMKF v2.4: Model 45 was requested, is the simplest, and at least one other model was requested and converged */
												if difll4445 ne . or difll3345 ne . or difll2345 ne . or difll2245 ne . or  difll1345 ne . or difll1245 ne . or 
												   difll1145 ne . then do; 
												 	p11 = bf1145 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p12 = bf1245 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p13 = bf1345 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p22 = bf2245 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p23 = bf2345 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p33 = bf3345 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p44 = bf4445 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p45 =      1 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf3345+bf4445);
												 	p46 =      0;
												 	p55 =      0;
												 	p56 =      0;
												 	p66 =      0;
													p77 =      0;
												end;
										 	 	else do;
												 	/* eMKF v2.4: Model 44 was requested, is the simplest, and at least one other model was requested and converged */
													if difll3344 ne . or difll2344 ne . or difll2244 ne . or  difll1344 ne . or difll1244 ne . or difll1144 ne . then do; 
													 	p11 = bf1144 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p12 = bf1244 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p13 = bf1344 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p22 = bf2244 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p23 = bf2344 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p33 = bf3344 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p44 =      1 /(1+bf1144+bf1244+bf1344+bf2244+bf2344+bf3344);
													 	p45 =      0;
													 	p46 =      0;
													 	p55 =      0;
													 	p56 =      0;
													 	p66 =      0;
														p77 =      0;
													end;
											 	 	else do;
													 	/* eMKF v2.4: Model 33 was requested, is the simplest, and at least one other model was requested and converged */
														if difll2333 ne . or difll2233 ne . or  difll1333 ne . or difll1233 ne . or difll1133 ne . then do; 
														 	p11 = bf1133 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p12 = bf1233 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p13 = bf1333 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p22 = bf2233 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p23 = bf2333 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p33 =      1 /(1+bf1133+bf1233+bf1333+bf2233+bf2333);
														 	p44 =      0;
														 	p45 =      0;
														 	p46 =      0;
														 	p55 =      0;
														 	p56 =      0;
														 	p66 =      0;
															p77 =      0;
														end;
													end;
												end;
											end;
									   %end;
									   %if &ug = 2 %then %do;
										 	/* eMKF v2.4: Model 33 was requested, is the simplest, and at least one other model was requested and converged */
											if difll4633 ne . or difll4533 ne . or difll4433 ne . or difll2333 ne . or difll2233 ne . or difll1333 ne . or 
											   difll1233 ne . or difll1133 ne . then do; 
											 	p11 = bf1133 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p12 = bf1233 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p13 = bf1333 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p22 = bf2233 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p23 = bf2333 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p33 = 	   1 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p44 = bf4433 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p45 = bf4533 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p46 = bf4633 /(1+bf1133+bf1233+bf1333+bf2233+bf2333+bf4433+bf4533+bf4633);
											 	p55 =      0;
											 	p56 =      0;
											 	p66 =      0;
												p77 =      0;
											end;
									 	 	else do;
											 	/* eMKF v2.4: Model 46 was requested, is the simplest, and at least one other model was requested and converged */
												if difll4546 ne . or difll4446 ne . or difll2346 ne . or difll2246 ne . or  difll1346 ne . or difll1246 ne . or 
												   difll1146 ne . then do; 
												 	p11 = bf1146 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p12 = bf1246 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p13 = bf1346 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p22 = bf2246 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p23 = bf2346 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p33 =      0;
												 	p44 = bf4446 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p45 = bf4546 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p46 =      1 /(1+bf1146+bf1246+bf1346+bf2246+bf2346+bf4446+bf4546);
												 	p55 =      0;
												 	p56 =      0;
												 	p66 =      0;
													p77 =      0;
												end;
										 	 	else do;
												 	/* eMKF v2.4: Model 45 was requested, is the simplest, and at least one other model was requested and converged */
													if difll4445 ne . or difll2345 ne . or difll2245 ne . or  difll1345 ne . or difll1245 ne . or difll1145 ne . then do; 
													 	p11 = bf1145 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p12 = bf1245 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p13 = bf1345 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p22 = bf2245 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p23 = bf2345 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p33 =      0;
													 	p44 = bf4445 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p45 =      1 /(1+bf1145+bf1245+bf1345+bf2245+bf2345+bf4445);
													 	p46 =      0;
													 	p55 =      0;
													 	p56 =      0;
													 	p66 =      0;
														p77 =      0;
													end;
											 	 	else do;
													 	/* eMKF v2.4: Model 44 was requested, is the simplest, and at least one other model was requested and converged */
														if difll2344 ne . or difll2244 ne . or  difll1344 ne . or difll1244 ne . or difll1144 ne . then do; 
														 	p11 = bf1144 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p12 = bf1244 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p13 = bf1344 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p22 = bf2244 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p23 = bf2344 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p33 =      0;
														 	p44 =      1 /(1+bf1144+bf1244+bf1344+bf2244+bf2344);
														 	p45 =      0;
														 	p46 =      0;
														 	p55 =      0;
														 	p56 =      0;
														 	p66 =      0;
															p77 =      0;
														end;
													end;
												end;
											end;
									   %end;
									end;
							 	 	else do;
									 	/* eMKF v2.4: Model 23 was requested, is the simplest, and at least one other model was requested and converged */
										if difll2223 ne . or  difll1323 ne . or difll1223 ne . or difll1123 ne . then do; 
										 	p11 = bf1123 /(1+bf1123+bf1223+bf1323+bf2223);
										 	p12 = bf1223 /(1+bf1123+bf1223+bf1323+bf2223);
										 	p13 = bf1323 /(1+bf1123+bf1223+bf1323+bf2223);
										 	p22 = bf2223 /(1+bf1123+bf1223+bf1323+bf2223);
										 	p23 =      1 /(1+bf1123+bf1223+bf1323+bf2223);
										 	p33 =      0;
										 	p44 =      0;
										 	p45 =      0;
										 	p46 =      0;
										 	p55 =      0;
										 	p56 =      0;
										 	p66 =      0;
											p77 =      0;
										end;
								 	 	else do;
										 	/* eMKF v2.4: Model 22 was requested, is the simplest, and at least one other model was requested and converged */
											if difll1322 ne . or difll1222 ne . or difll1122 ne . then do; 
											 	p11 = bf1122 /(1+bf1122+bf1222+bf1322);
											 	p12 = bf1222 /(1+bf1122+bf1222+bf1322);
											 	p13 = bf1322 /(1+bf1122+bf1222+bf1322);
											 	p22 =      1 /(1+bf1122+bf1222+bf1322);
											 	p23 =      0;
											 	p33 =      0;
											 	p44 =      0;
											 	p45 =      0;
											 	p46 =      0;
											 	p55 =      0;
											 	p56 =      0;
											 	p66 =      0;
												p77 =      0;
											end;
									 	 	else do;
											 	/* eMKF v2.4: Model 13 was requested, is the simplest, and at least one other model was requested and converged */
												if difll1213 ne . or difll1113 ne . then do; 
												 	p11 = bf1113 /(1+bf1113+bf1213);
												 	p12 = bf1213 /(1+bf1113+bf1213);
												 	p13 =      1 /(1+bf1113+bf1213);
												 	p22 =      0;
												 	p23 =      0;
												 	p33 =      0;
												 	p44 =      0;
												 	p45 =      0;
												 	p46 =      0;
												 	p55 =      0;
												 	p56 =      0;
												 	p66 =      0;
													p77 =      0;
												end;
										 	 	else do;
												 	/* eMKF v2.4: Models 12 and 11 were requested and converged */
													if difll1112 ne . then do; 
													 	p11 = bf1112 /(1+bf1112);
													 	p12 =      1 /(1+bf1112);
													 	p13 =      0;;
													 	p22 =      0;
													 	p23 =      0;
													 	p33 =      0;
													 	p44 =      0;
													 	p45 =      0;
													 	p46 =      0;
													 	p55 =      0;
													 	p56 =      0;
													 	p66 =      0;
														p77 =      0;
													end;
												end;
											end;
										end;
									end;
								end;
							end;
						end;
					end;
			    run;
			%end;

			/*******************************************************************************************/
			/* eMKF v2.4 streamlining: _KF_covY no longer tracked.                                     */
			/* User can inspect model-specific _covY by calling HTRP with option nlmixedDetails = YES. */
			/*******************************************************************************************/

			proc sort data=_loglike_;
			  by _rep;
			run;
			proc sort data= &out._pred;
			  by _rep;
			run;

			/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
			%put ;
			%put MKF macro is now calculating model-averaged predictions.;

			/* eMKF v2.4: revised averaging to account for allowed model combinations before and after the trend break */
			/* eMKF: revised averaging to account for re-numbering of models and up to 7 models requested */
			/* eMKF: used coalesce to force to 0 when missing instead of dealing with combinatorial number of model combinations */

			data &out._pred;		
			  merge &out._pred _loglike_(keep= _rep p:); /* eMKF v2.4 streamlining: used p: to denote all probability columns to keep */
			  by _rep;
			  /* eMKF v2.4: when no breakpoint is specified, or with two outcomes, proceed as in previous eMKF version */
			  %if &breakPoint = %str() %then %do;
	              pred_INDEP_CUBIC  	= coalesce(pred_INDEP_CUBIC, 0); 
				  pred_INDEP_QUAD   	= coalesce(pred_INDEP_QUAD, 0);
				  pred_INDEP_LINEAR  	= coalesce(pred_INDEP_LINEAR, 0);
	              pred_COMMON_CUBIC 	= coalesce(pred_COMMON_CUBIC, 0);
				  pred_COMMON_QUAD  	= coalesce(pred_COMMON_QUAD, 0);
				  pred_COMMON_LINEAR 	= coalesce(pred_COMMON_LINEAR, 0);
				  pred_DROPPED      	= coalesce(pred_DROPPED, 0);
	              predMSE_INDEP_CUBIC  	= coalesce(predMSE_INDEP_CUBIC, 0);
				  predMSE_INDEP_QUAD   	= coalesce(predMSE_INDEP_QUAD, 0);
				  predMSE_INDEP_LINEAR  = coalesce(predMSE_INDEP_LINEAR, 0);
	              predMSE_COMMON_CUBIC 	= coalesce(predMSE_COMMON_CUBIC, 0);
				  predMSE_COMMON_QUAD  	= coalesce(predMSE_COMMON_QUAD, 0);
				  predMSE_COMMON_LINEAR = coalesce(predMSE_COMMON_LINEAR, 0);
				  predMSE_DROPPED      	= coalesce(predMSE_DROPPED, 0);
	              pred_ModelAvg    = p1*pred_INDEP_CUBIC  + p2*pred_INDEP_QUAD  + p3*pred_INDEP_LINEAR  + 
			 						 p4*pred_COMMON_CUBIC + p5*pred_COMMON_QUAD + p6*pred_COMMON_LINEAR + p7*pred_DROPPED;
	              predMSE_ModelAvg = p1*predMSE_INDEP_CUBIC  + p2*predMSE_INDEP_QUAD  + p3*predMSE_INDEP_LINEAR  + 
									 p4*predMSE_COMMON_CUBIC + p5*predMSE_COMMON_QUAD + p6*predMSE_COMMON_LINEAR + p7*predMSE_DROPPED;
              	  predSE_ModelAvg= sqrt(predMSE_ModelAvg);
			  %end;
			  %else %do;
				  /* eMKF v2.4: For a level shift with a single outcome, use different nomenclature */
				  %if %upcase(&breakType) = LEVEL_BREAK %then %do;
		              pred_INDEP_CUBIC_XLV   = coalesce(pred_INDEP_CUBIC_XLV, 0); 
					  pred_INDEP_QUAD_XLV    = coalesce(pred_INDEP_QUAD_XLV, 0);
					  pred_INDEP_LINEAR_XLV  = coalesce(pred_INDEP_LINEAR_XLV, 0);
		              pred_COMMON_CUBIC_XLV  = coalesce(pred_COMMON_CUBIC_XLV, 0);
					  pred_COMMON_QUAD_XLV   = coalesce(pred_COMMON_QUAD_XLV, 0);
					  pred_COMMON_LINEAR_XLV = coalesce(pred_COMMON_LINEAR_XLV, 0);
					  pred_DROPPED_XLV       = coalesce(pred_DROPPED_XLV, 0);
		              predMSE_INDEP_CUBIC_XLV   = coalesce(predMSE_INDEP_CUBIC_XLV, 0);
					  predMSE_INDEP_QUAD_XLV    = coalesce(predMSE_INDEP_QUAD_XLV, 0);
					  predMSE_INDEP_LINEAR_XLV  = coalesce(predMSE_INDEP_LINEAR_XLV, 0);
		              predMSE_COMMON_CUBIC_XLV  = coalesce(predMSE_COMMON_CUBIC_XLV, 0);
					  predMSE_COMMON_QUAD_XLV   = coalesce(predMSE_COMMON_QUAD_XLV, 0);
					  predMSE_COMMON_LINEAR_XLV = coalesce(predMSE_COMMON_LINEAR_XLV, 0);
					  predMSE_DROPPED_XLV       = coalesce(predMSE_DROPPED_XLV, 0);
		              pred_ModelAvg_xlevel    = p1*pred_INDEP_CUBIC_XLV  + p2*pred_INDEP_QUAD_XLV  + p3*pred_INDEP_LINEAR_XLV  + 
				 						        p4*pred_COMMON_CUBIC_XLV + p5*pred_COMMON_QUAD_XLV + p6*pred_COMMON_LINEAR_XLV + p7*pred_DROPPED_XLV;
		              predMSE_ModelAvg_xlevel = p1*predMSE_INDEP_CUBIC_XLV  + p2*predMSE_INDEP_QUAD_XLV  + p3*predMSE_INDEP_LINEAR_XLV  + 
										        p4*predMSE_COMMON_CUBIC_XLV + p5*predMSE_COMMON_QUAD_XLV + p6*predMSE_COMMON_LINEAR_XLV + p7*predMSE_DROPPED_XLV;
		              predSE_ModelAvg_xlevel= sqrt(predMSE_ModelAvg_xlevel);
				  %end;
				  /* eMKF v2.4: For a full break with a single outcome, account for trend in segment 2 */
				  %if %upcase(&breakType) = FULL_BREAK %then %do;
		              pred_INDEP_CUBIC_CUB   = coalesce(pred_INDEP_CUBIC_CUB, 0); 
		              pred_INDEP_CUBIC_QUA   = coalesce(pred_INDEP_CUBIC_QUA, 0); 
		              pred_INDEP_CUBIC_LIN   = coalesce(pred_INDEP_CUBIC_LIN, 0); 
					  pred_INDEP_QUAD_QUA    = coalesce(pred_INDEP_QUAD_QUA, 0);
					  pred_INDEP_QUAD_LIN    = coalesce(pred_INDEP_QUAD_LIN, 0);
					  pred_INDEP_LINEAR_LIN  = coalesce(pred_INDEP_LINEAR_LIN, 0);
		              pred_COMMON_CUBIC_CUB  = coalesce(pred_COMMON_CUBIC_CUB, 0);
		              pred_COMMON_CUBIC_QUA  = coalesce(pred_COMMON_CUBIC_QUA, 0);
		              pred_COMMON_CUBIC_LIN  = coalesce(pred_COMMON_CUBIC_LIN, 0);
					  pred_COMMON_QUAD_QUA   = coalesce(pred_COMMON_QUAD_QUA, 0);
					  pred_COMMON_QUAD_LIN   = coalesce(pred_COMMON_QUAD_LIN, 0);
					  pred_COMMON_LINEAR_LIN = coalesce(pred_COMMON_LINEAR_LIN, 0);
					  pred_DROPPED_DROPPED   = coalesce(pred_DROPPED_DROPPED, 0);
		              predMSE_INDEP_CUBIC_CUB   = coalesce(predMSE_INDEP_CUBIC_CUB, 0); 
		              predMSE_INDEP_CUBIC_QUA   = coalesce(predMSE_INDEP_CUBIC_QUA, 0); 
		              predMSE_INDEP_CUBIC_LIN   = coalesce(predMSE_INDEP_CUBIC_LIN, 0); 
					  predMSE_INDEP_QUAD_QUA    = coalesce(predMSE_INDEP_QUAD_QUA, 0);
					  predMSE_INDEP_QUAD_LIN    = coalesce(predMSE_INDEP_QUAD_LIN, 0);
					  predMSE_INDEP_LINEAR_LIN  = coalesce(predMSE_INDEP_LINEAR_LIN, 0);
		              predMSE_COMMON_CUBIC_CUB  = coalesce(predMSE_COMMON_CUBIC_CUB, 0);
		              predMSE_COMMON_CUBIC_QUA  = coalesce(predMSE_COMMON_CUBIC_QUA, 0);
		              predMSE_COMMON_CUBIC_LIN  = coalesce(predMSE_COMMON_CUBIC_LIN, 0);
					  predMSE_COMMON_QUAD_QUA   = coalesce(predMSE_COMMON_QUAD_QUA, 0);
					  predMSE_COMMON_QUAD_LIN   = coalesce(predMSE_COMMON_QUAD_LIN, 0);
					  predMSE_COMMON_LINEAR_LIN = coalesce(predMSE_COMMON_LINEAR_LIN, 0);
					  predMSE_DROPPED_DROPPED   = coalesce(predMSE_DROPPED_DROPPED, 0);
		              pred_ModelAvg_xfull = p11*pred_INDEP_CUBIC_CUB  + p12*pred_INDEP_CUBIC_QUA  + p13*pred_INDEP_CUBIC_LIN   + 
				 						    p22*pred_INDEP_QUAD_QUA   + p23*pred_INDEP_QUAD_LIN   + p33*pred_INDEP_LINEAR_LIN  +
										    p44*pred_COMMON_CUBIC_CUB + p45*pred_COMMON_CUBIC_QUA + p46*pred_COMMON_CUBIC_LIN  + 
				 						    p55*pred_COMMON_QUAD_QUA  + p56*pred_COMMON_QUAD_LIN  + p66*pred_COMMON_LINEAR_LIN +
									        p77*pred_DROPPED_DROPPED;
		              predMSE_ModelAvg_xfull = p11*predMSE_INDEP_CUBIC_CUB  + p12*predMSE_INDEP_CUBIC_QUA  + p13*predMSE_INDEP_CUBIC_LIN   + 
				 						       p22*predMSE_INDEP_QUAD_QUA   + p23*predMSE_INDEP_QUAD_LIN   + p33*predMSE_INDEP_LINEAR_LIN  +
										       p44*predMSE_COMMON_CUBIC_CUB + p45*predMSE_COMMON_CUBIC_QUA + p46*predMSE_COMMON_CUBIC_LIN  + 
				 						       p55*predMSE_COMMON_QUAD_QUA  + p56*predMSE_COMMON_QUAD_LIN  + p66*predMSE_COMMON_LINEAR_LIN +
									           p77*predMSE_DROPPED_DROPPED;
		              predSE_ModelAvg_xfull = sqrt(predMSE_ModelAvg_xfull);
				  %end;
			  %end;
			run;

			/* eMKF v2.4: with two outcomes, proceed as in previous eMKF version */
			%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
				data &out._pred;
				  set &out._pred;
				  pred2_INDEP_CUBIC  	 = coalesce(pred2_INDEP_CUBIC, 0);
			 	  pred2_INDEP_QUAD   	 = coalesce(pred2_INDEP_QUAD, 0);
			 	  pred2_INDEP_LINEAR  	 = coalesce(pred2_INDEP_LINEAR, 0);
                  pred2_COMMON_CUBIC 	 = coalesce(pred2_COMMON_CUBIC, 0);
			 	  pred2_COMMON_QUAD  	 = coalesce(pred2_COMMON_QUAD, 0);
			 	  pred2_COMMON_LINEAR    = coalesce(pred2_COMMON_LINEAR, 0);
			 	  pred2_DROPPED      	 = coalesce(pred2_DROPPED, 0);
                  pred2MSE_INDEP_CUBIC   = coalesce(pred2MSE_INDEP_CUBIC, 0);
			 	  pred2MSE_INDEP_QUAD    = coalesce(pred2MSE_INDEP_QUAD, 0);
			 	  pred2MSE_INDEP_LINEAR  = coalesce(pred2MSE_INDEP_LINEAR, 0);
                  pred2MSE_COMMON_CUBIC  = coalesce(pred2MSE_COMMON_CUBIC, 0);
			 	  pred2MSE_COMMON_QUAD   = coalesce(pred2MSE_COMMON_QUAD, 0);
			 	  pred2MSE_COMMON_LINEAR = coalesce(pred2MSE_COMMON_LINEAR, 0);
			 	  pred2MSE_DROPPED       = coalesce(pred2MSE_DROPPED, 0);
				  pred2_ModelAvg    = p1*pred2_INDEP_CUBIC  + p2*pred2_INDEP_QUAD  + p3*pred2_INDEP_LINEAR  + 
				   				      p4*pred2_COMMON_CUBIC + p5*pred2_COMMON_QUAD + p6*pred2_COMMON_LINEAR + p7*pred2_DROPPED;
                  pred2MSE_ModelAvg = p1*pred2MSE_INDEP_CUBIC  + p2*pred2MSE_INDEP_QUAD  + p3*pred2MSE_INDEP_LINEAR  + 
								      p4*pred2MSE_COMMON_CUBIC + p5*pred2MSE_COMMON_QUAD + p6*pred2MSE_COMMON_LINEAR + p7*pred2MSE_DROPPED;
				  pred2SE_ModelAvg= sqrt(pred2MSE_ModelAvg);
				run;
			%end;

			/* eMKF v2.4 streamlining: clean-up of model-specific details other than _ests and _pred now done within HTRP and HTRP2d by default (option nlmixedDetails = NO) */
			proc datasets nolist;
			  delete _junk_ _loglike_ _loglike2_ 
			  	  /* eMKF v2.4 streamlining: Deleting any remaining model-specific output using wildcard notation */
			      %if %upcase(&nlmixedDetails) ^= YES %then %do;
					 %if %upcase(&flag1)=YES %then _KF_INDEP_CUBIC_: ;
		             %if %upcase(&flag2)=YES %then _KF_INDEP_QUAD_: ;
	                 %if %upcase(&flag3)=YES %then _KF_INDEP_LINEAR_: ;
	                 %if %upcase(&flag4)=YES %then _KF_COMMON_CUBIC_: ;
					 %if %upcase(&flag5)=YES %then _KF_COMMON_QUAD_: ;
					 %if %upcase(&flag6)=YES %then _KF_COMMON_LINEAR_: ;
					 %if %upcase(&flag7)=YES %then _KF_DROPPED_: ;
				  %end;
			      ;
			run;
			quit;

		%end; /*End of condition if uj>1 */

		/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
		%put ;
		%put MKF macro completed ML-based estimation and is now wrapping up.;

	%end;  /*End of slopes estimations using MLE */

    /*********************************/
	/* Estimate the Bayesian model(s)*/
	/*********************************/

	%if %upcase(&Bayesian) = YES %then %do;

		/* eMKF v2.4 streamlining: check for repeated models and remove */
		/* eMKF v2.4 streamlining: with only 1 group, common trend models are redundant */
		%if &ug > 1 %then %let Bayesmodel = %_unique_(&Bayesmodel);
		%else %do;
			%let flag4=0; %let flag5=0; %let flag6=0; %let uvar=; %let ui = 0;
			%do ui=1 %to %_counts_(&Bayesmodel); /* eMKF v2.4: set flags */
				%let uvar=%scan(&Bayesmodel, &ui);
				%if %upcase(&uvar) = COMMON_CUBIC %then %let flag4 = 1;
				%if %upcase(&uvar) = COMMON_QUAD %then %let flag5 = 1;
				%if %upcase(&uvar) = COMMON_LINEAR %then %let flag6 = 1; 
			%end;
			%if &flag4 = 1 or &flag5 = 1 or &flag6 = 1 %then %do;
				%put WARNING: As there is only one &group group, common trend models are redundant.;
				%put WARNING- Corresponding independent trend models will be assumed instead.;
				%local bwrem bwadd; %let bwrem=; %let bwadd=;
				%if &flag4 = 1 %then %do; %let bwrem = &bwrem common_cubic; %let bwadd = &bwadd indep_cubic; %end;
				%if &flag5 = 1 %then %do; %let bwrem = &bwrem common_quad; %let bwadd = &bwadd indep_quad; %end;
				%if &flag6 = 1 %then %do; %let bwrem = &bwrem common_linear; %let bwadd = &bwadd indep_linear; %end;
				%let Bayesmodel = %_unique_(&Bayesmodel, remove=&bwrem, add=&bwadd);
			%end;
			%let uvar=; %let flag4=; %let flag5=; %let flag6=;
		%end;

		/* eMKF v2.4 streamlined: Total number of unique Bayesian models requested */
		%let uii = %_counts_(&Bayesmodel);

		/* eMKF v2.4: clarified model-specific sample size requirements and added trend break scenario */
		%if %upcase(&checkSampleSize) = YES %then %do;
			%let uvar=; %let ui=0;
			%do ui=1 %to &uii;
				%let uvar = %scan(&Bayesmodel, &ui);
				%local minpts_&ARmodel._&uvar; %let minpts_&ARmodel._&uvar = 0;
				%if %upcase(&uvar) in INDEP_CUBIC COMMON_CUBIC FULL_CUBIC BMA_CUBIC %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+7*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+6*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+5*&ug)/&ug));;
				%end;
				%if %upcase(&uvar) = INDEP_QUAD COMMON_QUAD FULL_QUAD BMA_QUAD %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+6*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+5*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+4*&ug)/&ug));;
				%end;
				%if %upcase(&uvar) = INDEP_LINEAR COMMON_LINEAR FULL_LINEAR BMA_LINEAR %then %do;
					%if %upcase(&ARmodel) = INDEP_AR   %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((0+5*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_ARH %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((1+4*&ug)/&ug));;
					%if %upcase(&ARmodel) = COMMON_AR  %then %let minpts_&ARmodel._&uvar = %sysfunc(ceil((2+3*&ug)/&ug));;
				%end;
				%if &breakPoint = %str() and &un < &&minpts_&ARmodel._&uvar %then %do;
				  %put ERROR: There are too few timepoints for a &uvar model with &ug &group groups, ;
				  %put ERROR- and the ARmodel=&ARmodel specification.; 
				  %put ERROR- At least &&minpts_&ARmodel._&uvar timepoints are recommended for a model with these specs.;
				  proc iml;
				    print "  Error Note:";
					print "  There are too few timepoints for a &uvar model with &ug &group groups and ARmodel=&ARmodel.";
					print "  At least &&minpts_&ARmodel._&uvar timepoints are recommended for a model with these specs.";
				  quit;
				  %return;
				%end;
				%if &breakPoint ^= %str() and (&uns1 < &&minpts_&ARmodel._&uvar or &uns2 < &&xtrpts_&breakType) %then %do;
				  %put ERROR: There are too few timepoints for a &uvar model with &ug &group groups, ;
				  %put ERROR- and the ARmodel=&ARmodel and breakType=&breakType specifications.; 
				  %put ERROR- Segment 1 should have at least &&minpts_&ARmodel._&uvar timepoints, ;
				  %put ERROR- and segment 2 at least &&xtrpts_&breakType timepoints, with these model specs.;
				  proc iml;
				    print "  Error Note:";
					print "  There are too few timepoints for a &uvar model with &ug &group groups, ";
					print "  and the ARmodel=&ARmodel and breakType=&breakType specifications.";
					print "  Segment 1 should have at least &&minpts_&ARmodel._&uvar timepoints, ";
					print "  and segment 2 at least &&xtrpts_&breakType timepoints, with these model specs.";
				  quit;
				  %return;
				%end;
				%let uvar=;
			%end;
		%end;

		/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
		%put ;
		%put MKF macro will use MCMC/Gibbs sampling to estimate specified model(s).;

		/* eMKF: Loop through sequence of requested model(s) to set model flag(s) */
		%let flag1a=0; %let flag2a=0; %let flag3a=0; %let flag1f=0; %let flag2f=0; %let flag3f=0;
		%let flag1=0; %let flag2=0; %let flag3=0; %let flag4=0; %let flag5=0; %let flag6=0; %let flag7=0;
		%let uvar=; %let ui=0; 
		%do ui=1 %to &uii;
			%let uvar = %scan(&Bayesmodel, &ui);
			%if %upcase(&uvar) = BMA_CUBIC     %then %let flag1a = 1;
			%if %upcase(&uvar) = BMA_QUAD      %then %let flag2a = 1;
			%if %upcase(&uvar) = BMA_LINEAR    %then %let flag3a = 1; 
			%if %upcase(&uvar) = FULL_CUBIC    %then %let flag1f = 1;
			%if %upcase(&uvar) = FULL_QUAD     %then %let flag2f = 1;
			%if %upcase(&uvar) = FULL_LINEAR   %then %let flag3f = 1; 
			%if %upcase(&uvar) = INDEP_CUBIC   %then %let flag1 = 1;
			%if %upcase(&uvar) = INDEP_QUAD    %then %let flag2 = 1;
			%if %upcase(&uvar) = INDEP_LINEAR  %then %let flag3 = 1; 
			%if %upcase(&uvar) = COMMON_CUBIC  %then %let flag4 = 1;
			%if %upcase(&uvar) = COMMON_QUAD   %then %let flag5 = 1;
			%if %upcase(&uvar) = COMMON_LINEAR %then %let flag6 = 1; 
			%if %upcase(&uvar) = DROPPED 	   %then %let flag7 = 1; 
			%let uvar=;
        %end;

		/* eMKF: If there are multiple Bayesian models requested and BayesmodelAvg = YES, 
		         or if bma_*** models are requested, then conduct a model averaging estimation.
				 Also over-rides BMA if fully Bayesian models are listed */

		%let _BMAmodel = ; %if &BayesmodelAvg = %str() %then %let BayesmodelAvg = NO;
		%if %upcase(&BayesmodelAvg) = YES and (&flag1f = 1 or &flag2f = 1 or &flag3f = 1) %then %do;
		    %put ;
			%put Because a fully Bayesian model was requested, no model averaging will be applied.;
			%let BayesmodelAvg = NO;
		%end;
		%if %upcase(&BayesmodelAvg) = YES and &flag1a ^= 1 and &flag2a ^= 1 and &flag3a ^= 1 and &uii = 1 %then %do;
		    %put ;
			%put Because only one Bayesian model was specified, no model averaging will be applied.;
			%let BayesmodelAvg = NO;
		%end;
		%if &flag1a = 1 or ((&flag1 = 1 or &flag4 = 1) and (&BayesmodelAvg = YES)) %then %do;
		    %put ;	
			%if %upcase(&BayesmodelAvg) = YES %then %do;
				%put Because a cubic trend model was requested, all applicable models up to cubic will be included in Bayesian model averaging.;
			%end;
			%let _BMAmodel = BMA_CUBIC; %let flag1a = 1; %let BayesmodelAvg = YES;
		%end;
		%if &flag1a ^= 1 and &flag1f ^= 1 and &flag1 ^= 1 and &flag4 ^= 1 and 
			(&flag2a = 1 or ((&flag2 = 1 or &flag5 = 1) and (&BayesmodelAvg = YES))) %then %do;
		    %put ;	
			%if %upcase(&BayesmodelAvg) = YES %then %do;
				%put Because a quadratic trend model was requested, all applicable models up to quadratic will be included in Bayesian model averaging.;
			%end;
			%let _BMAmodel = BMA_QUAD; %let flag2a = 1; %let BayesmodelAvg = YES;
		%end;
		%if &flag1a ^= 1 and &flag1f ^= 1 and &flag1 ^= 1 and &flag4 ^= 1 and 
			&flag2a ^= 1 and &flag2f ^= 1 and &flag2 ^= 1 and &flag5 ^= 1 and 
			(&flag3a = 1 or ((&flag3 = 1 or &flag6 = 1) and (&BayesmodelAvg = YES))) %then %do;		
		    %put ;	
			%if %upcase(&BayesmodelAvg) = YES %then %do;
				%put Because a linear trend model was requested, all applicable models up to linear will be included in Bayesian model averaging.;
			%end;
			%let _BMAmodel = BMA_LINEAR; %let flag3a = 1; %let BayesmodelAvg = YES;
		%end;
		%if &flag1a ^= 1 and &flag1f ^= 1 and &flag1 ^= 1 and &flag4 ^= 1 and 
			&flag2a ^= 1 and &flag2f ^= 1 and &flag2 ^= 1 and &flag5 ^= 1 and 
			&flag3a ^= 1 and &flag3f ^= 1 and &flag3 ^= 1 and &flag6 ^= 1 %then %do;		
		    %put ;	
			%if %upcase(&BayesmodelAvg) = YES %then %do;
				%put Because no trend model was requested, an intercepts-only model will be fit.;
			%end;
			%let _BMAmodel = DROPPED; %let flag7 = 1; %let BayesmodelAvg = NO;
		%end;

		/* eMKF v2.4: set up flags for allowed models in segment 2 in full trend break scenario */
		%let s2flag1a=; %let s2flag2a=; %let s2flag3a=; %let s2flag1f=; %let s2flag2f=; %let s2flag3f=;
		%let s2flag1=; %let s2flag2=; %let s2flag3=; %let s2flag4=; %let s2flag5=; %let s2flag6=; %let s2flag7=;

		%if %upcase(&breakType) = FULL_BREAK %then %do;
			%let s2flag1a=0; %let s2flag2a=0; %let s2flag3a=0; %let s2flag1f=0; %let s2flag2f=0; %let s2flag3f=0;
			%let s2flag1=0; %let s2flag2=0; %let s2flag3=0; %let s2flag4=0; %let s2flag5=0; %let s2flag6=0; %let s2flag7=0;
			%if &flag1a = 1 %then %do;
				%if &uns2 ge 5 %then %let s2flag1a = 1;
				%if &uns2 =  4 %then %let s2flag2a = 1;
				%if &uns2 =  3 %then %let s2flag3a = 1;
			%end;
			%if &flag2a = 1 %then %do;
				%if &uns2 ge 4 %then %let s2flag2a = 1;
				%if &uns2 =  3 %then %let s2flag3a = 1;
			%end;
			%if &flag3a = 1 %then %do;
				%if &uns2 ge 3 %then %let s2flag3a = 1;
			%end;
			%if &flag1f = 1 %then %do;
				%if &uns2 ge 5 %then %let s2flag1f = 1;
				%if &uns2 =  4 %then %let s2flag2f = 1;
				%if &uns2 =  3 %then %let s2flag3f = 1;
			%end;
			%if &flag2f = 1 %then %do;
				%if &uns2 ge 4 %then %let s2flag2f = 1;
				%if &uns2 =  3 %then %let s2flag3f = 1;
			%end;
			%if &flag3f = 1 %then %do;
				%if &uns2 ge 3 %then %let s2flag3f = 1;
			%end;
			%if &flag1 = 1 %then %do;
				%if &uns2 ge 5 %then %let s2flag1 = 1;
				%if &uns2 =  4 %then %let s2flag2 = 1;
				%if &uns2 =  3 %then %let s2flag3 = 1;
			%end;
			%if &flag2 = 1 %then %do;
				%if &uns2 ge 4 %then %let s2flag2 = 1;
				%if &uns2 =  3 %then %let s2flag3 = 1;
			%end;
			%if &flag3 = 1 %then %do;
				%if &uns2 ge 3 %then %let s2flag3 = 1;
			%end;
			%if &flag4 = 1 %then %do;
				%if &uns2 ge 5 %then %let s2flag4 = 1;
				%if &uns2 =  4 %then %let s2flag5 = 1;
				%if &uns2 =  3 %then %let s2flag6 = 1;
			%end;
			%if &flag5 = 1 %then %do;
				%if &uns2 ge 4 %then %let s2flag5 = 1;
				%if &uns2 =  3 %then %let s2flag6 = 1;
			%end;
			%if &flag6 = 1 %then %do;
				%if &uns2 ge 3 %then %let s2flag6 = 1;
			%end;
			%if &flag7 = 1 %then %do;
				%if &uns2 ge 2 %then %let s2flag7 = 1;
			%end;
		%end;

		/* eMKF v2.4 note: Recall that only the last Bayesian model estimated will be printed */
		%let toprint=;

		/* eMKF: Find the number of replications (from stratification variable _rep) */
		%let crep=0;
		data _freq_;
		run;
		proc freq data=_bayesdata_ noprint;
		  tables _rep /list out=_freq_;
		run;
		data _null_;
		  set _freq_;
		  _crep_ +1;
		  call symput('crep',_crep_);
		  keep _rep _crep_;
		run;
		%let crep= %eval(0 + &crep);

		proc datasets nolist;
  			delete _freq_;
		run ;

		/* eMKF: nmc and thin macro variables are needed below outside of call to PROC MCMC */
		%if &thin = %str() %then %let thin = 1; 	 /* set to proc mcmc default if missing */ 
		%if &nbi = %str() %then %let nbi = 1000; 	 /* set to proc mcmc default if missing */
		%if &nmc = %str() %then %let nmc = 1000; 	 /* set to proc mcmc default if missing */

		/***********************************************************************************/
		/* eMKF: Pre-compile appropriate Gibbs sampler subroutine(s) for selected model(s) */
 		/***********************************************************************************/

		/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
		%put ;
		%put MKF macro now compiling model-specific Gibbs samplers to specified CMP library.;

		/* eMKF: Set CMP library if not provided. Could also use sasuser.funcs if user has write-permission */
		%if &cmploc = %str() %then %let cmploc = work.funcs; 

		/* eMKF v2.4: function to sample from truncated normal distribution, based on algorithm of Robert (1995) */
		/* Uses cutoffs of %sysevalf(1e15) for infinity (MCMC default for INF) and %sysevalf(1e-11) for zero (MCMC default for SINGDEN) */
		%gibbs_uds_compile_TNORM(loc=&cmploc, infty=%sysevalf(1e15), zero=%sysevalf(1e-11), method=reject);

		/* eMKF: true states */
		%gibbs_uds_compile_EP(g=&ug, n=&un, loc=&cmploc);

		/* eMKF: variance parameters */
		%if %upcase(&randomVars) = YES %then %gibbs_uds_compile_RP(g=&ug, n=&un, loc=&cmploc);; 

		/* eMKF v2.4: mean hyperparameters + mbetag/Dbetag arrays in fully Bayesian models */
		%if &flag1f = 1 or &flag2f = 1 or &flag3f = 1 %then %do;
			%if &breakPoint = %str() %then %do;
				%if &flag1f = 1 %then %gibbs_uds_compile_MP(uvar=full_cubic,  g=&ug, loc=&cmploc);;
				%if &flag2f = 1 %then %gibbs_uds_compile_MP(uvar=full_quad,   g=&ug, loc=&cmploc);;
				%if &flag3f = 1 %then %gibbs_uds_compile_MP(uvar=full_linear, g=&ug, loc=&cmploc);;
			%end;
			%else %do; 
				%if %upcase(&breakType) = LEVEL_BREAK %then %do; /* eMKF v2.4: with level break */
					%if &flag1f = 1 %then %gibbs_uds_compile_MP_xptl(uvar=full_cubic,  g=&ug, loc=&cmploc);;
					%if &flag2f = 1 %then %gibbs_uds_compile_MP_xptl(uvar=full_quad,   g=&ug, loc=&cmploc);;
					%if &flag3f = 1 %then %gibbs_uds_compile_MP_xptl(uvar=full_linear, g=&ug, loc=&cmploc);;
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;  /* eMKF v2.4: with full break */
					%if &flag1f = 1 and &s2flag1f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_cubic,  s2uvar=full_cubic,  g=&ug, loc=&cmploc);;
					%if &flag1f = 1 and &s2flag2f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_cubic,  s2uvar=full_quad,   g=&ug, loc=&cmploc);;
					%if &flag1f = 1 and &s2flag3f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_cubic,  s2uvar=full_linear, g=&ug, loc=&cmploc);;
					%if &flag2f = 1 and &s2flag2f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_quad,   s2uvar=full_quad,   g=&ug, loc=&cmploc);;
					%if &flag2f = 1 and &s2flag3f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_quad,   s2uvar=full_linear, g=&ug, loc=&cmploc);;
					%if &flag3f = 1 and &s2flag3f = 1 %then %gibbs_uds_compile_MP_xptf(uvar=full_linear, s2uvar=full_linear, g=&ug, loc=&cmploc);;
				%end;
			%end;
		%end;

		/* eMKF v2.4: regression coefficients and predictions */
		%if &breakPoint = %str() %then %do;
			%if &flag1a = 1 			  %then %gibbs_uds_compile_CP(uvar=bma_cubic,     g=&ug, n=&un, loc=&cmploc);; 
			%if &flag2a = 1 			  %then %gibbs_uds_compile_CP(uvar=bma_quad,      g=&ug, n=&un, loc=&cmploc);; 
			%if &flag3a = 1 			  %then %gibbs_uds_compile_CP(uvar=bma_linear,    g=&ug, n=&un, loc=&cmploc);; 
			%if &flag1 = 1 or &flag1f = 1 %then %gibbs_uds_compile_CP(uvar=indep_cubic,   g=&ug, n=&un, loc=&cmploc);; 
			%if &flag2 = 1 or &flag2f = 1 %then %gibbs_uds_compile_CP(uvar=indep_quad,    g=&ug, n=&un, loc=&cmploc);; 
			%if &flag3 = 1 or &flag3f = 1 %then %gibbs_uds_compile_CP(uvar=indep_linear,  g=&ug, n=&un, loc=&cmploc);; 
			%if &flag4 = 1 				  %then %gibbs_uds_compile_CP(uvar=common_cubic,  g=&ug, n=&un, loc=&cmploc);; 
			%if &flag5 = 1 				  %then %gibbs_uds_compile_CP(uvar=common_quad,   g=&ug, n=&un, loc=&cmploc);; 
			%if &flag6 = 1 				  %then %gibbs_uds_compile_CP(uvar=common_linear, g=&ug, n=&un, loc=&cmploc);; 
			%if &flag7 = 1 				  %then %gibbs_uds_compile_CP(uvar=dropped, 	  g=&ug, n=&un, loc=&cmploc);; 
		%end;
		%else %do;
			%if %upcase(&breakType) = LEVEL_BREAK %then %do; /* eMKF v2.4: with level break */
				%if &flag1a = 1 			  %then %gibbs_uds_compile_CP_xptl(uvar=bma_cubic,     g=&ug, n=&un, loc=&cmploc);; 
				%if &flag2a = 1 			  %then %gibbs_uds_compile_CP_xptl(uvar=bma_quad,      g=&ug, n=&un, loc=&cmploc);; 
				%if &flag3a = 1 			  %then %gibbs_uds_compile_CP_xptl(uvar=bma_linear,    g=&ug, n=&un, loc=&cmploc);; 
				%if &flag1 = 1 or &flag1f = 1 %then %gibbs_uds_compile_CP_xptl(uvar=indep_cubic,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag2 = 1 or &flag2f = 1 %then %gibbs_uds_compile_CP_xptl(uvar=indep_quad,    g=&ug, n=&un, loc=&cmploc);; 
				%if &flag3 = 1 or &flag3f = 1 %then %gibbs_uds_compile_CP_xptl(uvar=indep_linear,  g=&ug, n=&un, loc=&cmploc);; 
				%if &flag4 = 1 				  %then %gibbs_uds_compile_CP_xptl(uvar=common_cubic,  g=&ug, n=&un, loc=&cmploc);; 
				%if &flag5 = 1 				  %then %gibbs_uds_compile_CP_xptl(uvar=common_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag6 = 1 				  %then %gibbs_uds_compile_CP_xptl(uvar=common_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag7 = 1 				  %then %gibbs_uds_compile_CP_xptl(uvar=dropped, 	   g=&ug, n=&un, loc=&cmploc);; 
			%end;
			%if %upcase(&breakType) = FULL_BREAK %then %do;  /* eMKF v2.4: with full break */
				%if &flag1a = 1 and &s2flag1a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_cubic,  s2uvar=bma_cubic,  g=&ug, n=&un, loc=&cmploc);; 
				%if &flag1a = 1 and &s2flag2a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_cubic,  s2uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag1a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_cubic,  s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag2a = 1 and &s2flag2a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_quad,   s2uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag2a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_quad,   s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag3a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_CP_xptf(uvar=bma_linear, s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag1=1 or &flag1f=1) and (&s2flag1=1 or &s2flag1f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_cubic,  s2uvar=indep_cubic,  g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag1=1 or &flag1f=1) and (&s2flag2=1 or &s2flag2f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_cubic,  s2uvar=indep_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag1=1 or &flag1f=1) and (&s2flag3=1 or &s2flag3f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_cubic,  s2uvar=indep_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag2=1 or &flag2f=1) and (&s2flag2=1 or &s2flag2f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_quad,   s2uvar=indep_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag2=1 or &flag2f=1) and (&s2flag3=1 or &s2flag3f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_quad,   s2uvar=indep_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if (&flag3=1 or &flag3f=1) and (&s2flag3=1 or &s2flag3f=1) %then %gibbs_uds_compile_CP_xptf(uvar=indep_linear, s2uvar=indep_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag4 = 1 and &s2flag4 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_cubic,  s2uvar=common_cubic,  g=&ug, n=&un, loc=&cmploc);; 
				%if &flag4 = 1 and &s2flag5 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_cubic,  s2uvar=common_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag4 = 1 and &s2flag6 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_cubic,  s2uvar=common_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag5 = 1 and &s2flag5 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_quad,   s2uvar=common_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag5 = 1 and &s2flag6 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_quad,   s2uvar=common_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag6 = 1 and &s2flag6 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=common_linear, s2uvar=common_linear, g=&ug, n=&un, loc=&cmploc);; 
				%if &flag7 = 1 and &s2flag7 = 1 %then %gibbs_uds_compile_CP_xptf(uvar=dropped, 	     s2uvar=dropped, 	   g=&ug, n=&un, loc=&cmploc);; 
			%end;
		%end;

		/* eMKF: model indicators in Bayesian model averaging */
		%if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then %do;
			%if &breakPoint = %str() %then %do;
				%if &flag1a = 1 %then %gibbs_uds_compile_FP(uvar=bma_cubic,  g=&ug, n=&un, loc=&cmploc);; 
				%if &flag2a = 1 %then %gibbs_uds_compile_FP(uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
				%if &flag3a = 1 %then %gibbs_uds_compile_FP(uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
			%end;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %do; /* eMKF v2.4: with level break */
					%if &flag1a = 1 %then %gibbs_uds_compile_FP_xptl(uvar=bma_cubic,  g=&ug, n=&un, loc=&cmploc);; 
					%if &flag2a = 1 %then %gibbs_uds_compile_FP_xptl(uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
					%if &flag3a = 1 %then %gibbs_uds_compile_FP_xptl(uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;  /* eMKF v2.4: with full break */
					%if &flag1a = 1 and &s2flag1a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_cubic,  s2uvar=bma_cubic,  g=&ug, n=&un, loc=&cmploc);; 
					%if &flag1a = 1 and &s2flag2a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_cubic,  s2uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
					%if &flag1a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_cubic,  s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
					%if &flag2a = 1 and &s2flag2a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_quad,   s2uvar=bma_quad,   g=&ug, n=&un, loc=&cmploc);; 
					%if &flag2a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_quad,   s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);; 
					%if &flag3a = 1 and &s2flag3a = 1 %then %gibbs_uds_compile_FP_xptf(uvar=bma_linear, s2uvar=bma_linear, g=&ug, n=&un, loc=&cmploc);;
				%end; 
			%end;
		%end;

		/* eMKF: Start model fitting loop(s) (tuning loop from original MKF is now incorporated in the call to proc mcmc) */
		%put ;	
		%put Start Bayesian model fitting loop(s); 

		/* eMKF: to avoid larger dataset size than necessary, initialize one posterior log file per replication */
		data _bayesdata1_ &out._bayes &out._bayesparm &out._bayeslogGR ;
		run;
		%let uj=0;
		%do uj=1 %to &crep; 
			data &out._bayeslog_rep&uj; 
			run;
		%end; 

		/* eMKF: additional log file to hold posterior model weights in Bayesian model averaging */
		%if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then %do;
			data &out._bayeslogmod;
			run;
		%end;

		/* eMKF: Total number of models to loop through */
		%let uii=0;
		%if %upcase(&BayesmodelAvg) ^= YES %then %let uii = %_counts_(&Bayesmodel);;
		%if %upcase(&BayesmodelAvg) = YES  %then %let uii = %_counts_(&_BMAmodel);;

		/* Loop over replications */
		%let uj=0;
		%do uj=1 %to &crep;
			data _bayesdata1_;
			  set _bayesdata_;
			  if _rep= &uj;
			run;

			data _bayesfit2_ _bayesparam2_ _bayeslog2_ _bayeslogGR2_ ;
			run;

			%if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then %do;
				data _bayeslogmod2_;
				run;
			%end;

			/* Loop over the sequence of specified trend models */
			%let uvar= ; %let newuvar= ; %let s2uvar= ; %let s2newuvar= ; %let s22uvar= ; %let ui= 0; 
			%do ui=1 %to &uii;

				/* eMKF: Disabled option from original MKF that allowed user to include F, say, instead of FULL_LINEAR in Bayesmodel */
				%if %upcase(&BayesmodelAvg) ^= YES %then %let uvar= %scan(&Bayesmodel, &ui);;
				%if %upcase(&BayesmodelAvg) = YES %then %let uvar= %scan(&_BMAmodel, &ui);;

				%if &breakPoint ^= %str() %then %do;
					/* eMKF v2.4: common suffix for level break */
					%if %upcase(&breakType) = LEVEL_BREAK %then %let s2uvar = xlv;
					/* eMKF v2.4: set trend model for segment 2 based on timepoint availability */
					/*  To limit model combinations, disallow intercepts-only model in segment 2 unless it is also used in segment 1 */
					/*  Additionally, model type (common vs independent trend) is maintained for segment 2 */
					%if %upcase(&breakType) = FULL_BREAK %then %do;
						%if %upcase(&uvar) = BMA_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = bma_cubic;
							%if &uns2 =  4 %then %let s2uvar = bma_quad;
							%if &uns2 =  3 %then %let s2uvar = bma_linear;
						%end;
						%if %upcase(&uvar) = BMA_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = bma_quad;
							%if &uns2 =  3 %then %let s2uvar = bma_linear;
						%end;
						%if %upcase(&uvar) = BMA_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = bma_linear;
						%end;
						%if %upcase(&uvar) = FULL_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = full_cubic;
							%if &uns2 =  4 %then %let s2uvar = full_quad;
							%if &uns2 =  3 %then %let s2uvar = full_linear;
						%end;
						%if %upcase(&uvar) = FULL_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = full_quad;
							%if &uns2 =  3 %then %let s2uvar = full_linear;
						%end;
						%if %upcase(&uvar) = FULL_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = full_linear;
						%end;
						%if %upcase(&uvar) = INDEP_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = indep_cubic;
							%if &uns2 =  4 %then %let s2uvar = indep_quad;
							%if &uns2 =  3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = INDEP_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = indep_quad;
							%if &uns2 =  3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = INDEP_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = indep_linear;
						%end;
						%if %upcase(&uvar) = COMMON_CUBIC %then %do;
							%if &uns2 ge 5 %then %let s2uvar = common_cubic;
							%if &uns2 =  4 %then %let s2uvar = common_quad;
							%if &uns2 =  3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = COMMON_QUAD %then %do;
							%if &uns2 ge 4 %then %let s2uvar = common_quad;
							%if &uns2 =  3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = COMMON_LINEAR %then %do;
							%if &uns2 ge 3 %then %let s2uvar = common_linear;
						%end;
						%if %upcase(&uvar) = DROPPED %then %do;
							%if &uns2 ge 2 %then %let s2uvar = dropped;
						%end;
					%end;
				%end;

				/* eMKF: Simplified suffix construction for _thekeep* variables */
				%if %upcase(&uvar) = BMA_CUBIC     %then %let newuvar = _BMAC;
				%if %upcase(&uvar) = FULL_CUBIC    %then %let newuvar = _BFC;
				%if %upcase(&uvar) = INDEP_CUBIC   %then %let newuvar = _BGC;
				%if %upcase(&uvar) = COMMON_CUBIC  %then %let newuvar = _B1C;
				%if %upcase(&uvar) = BMA_QUAD      %then %let newuvar = _BMAQ;
				%if %upcase(&uvar) = FULL_QUAD     %then %let newuvar = _BFQ;
				%if %upcase(&uvar) = INDEP_QUAD    %then %let newuvar = _BGQ;
				%if %upcase(&uvar) = COMMON_QUAD   %then %let newuvar = _B1Q;
				%if %upcase(&uvar) = BMA_LINEAR    %then %let newuvar = _BMAL;
				%if %upcase(&uvar) = FULL_LINEAR   %then %let newuvar = _BFL;
				%if %upcase(&uvar) = INDEP_LINEAR  %then %let newuvar = _BGL;
				%if %upcase(&uvar) = COMMON_LINEAR %then %let newuvar = _B1L;
				%if %upcase(&uvar) = DROPPED	   %then %let newuvar = _B0;

				/* eMKF v2.4: Added suffix for segment 2 */
				%if &s2uvar ^= %str() %then %do;
					%if &s2uvar = xlv %then %let s2newuvar = _XLV;
					%else %do;
						%if %upcase(&s2uvar) = BMA_CUBIC     %then %let s2newuvar = _BMAC;
						%if %upcase(&s2uvar) = FULL_CUBIC    %then %let s2newuvar = _BFC;
						%if %upcase(&s2uvar) = INDEP_CUBIC   %then %let s2newuvar = _BGC;
						%if %upcase(&s2uvar) = COMMON_CUBIC  %then %let s2newuvar = _B1C;
						%if %upcase(&s2uvar) = BMA_QUAD      %then %let s2newuvar = _BMAQ;
						%if %upcase(&s2uvar) = FULL_QUAD     %then %let s2newuvar = _BFQ;
						%if %upcase(&s2uvar) = INDEP_QUAD    %then %let s2newuvar = _BGQ;
						%if %upcase(&s2uvar) = COMMON_QUAD   %then %let s2newuvar = _B1Q;
						%if %upcase(&s2uvar) = BMA_LINEAR    %then %let s2newuvar = _BMAL;
						%if %upcase(&s2uvar) = FULL_LINEAR   %then %let s2newuvar = _BFL;
						%if %upcase(&s2uvar) = INDEP_LINEAR  %then %let s2newuvar = _BGL;
						%if %upcase(&s2uvar) = COMMON_LINEAR %then %let s2newuvar = _B1L;
						%if %upcase(&s2uvar) = DROPPED 		 %then %let s2newuvar = _B0;
					%end;
				%end;

				/* eMKF v2.4: Version of segment 2 suffix for column labels in output datasets */
				%if &s2uvar ^= %str() %then %do;
					%if &s2uvar = xlv %then %let s22uvar = _xlv;
					%else %do;
						%if %upcase(%substr(&s2uvar, 1, 3)) = BMA %then %let s22uvar = %substr(&s2uvar, 4, 4);
						%if %upcase(%substr(&s2uvar, 1, 4)) = FULL %then %let s22uvar = %substr(&s2uvar, 5, 4);
						%if %upcase(%substr(&s2uvar, 1, 5)) = INDEP %then %let s22uvar = %substr(&s2uvar, 6, 4);
						%if %upcase(%substr(&s2uvar, 1, 6)) = COMMON %then %let s22uvar = %substr(&s2uvar, 7, 4);
						%if %upcase(&s2uvar) = DROPPED %then %let s22uvar = _&s2uvar;
					%end;
				%end;

				/* eMKF v2.4: Modified to add extra suffix for segment 2 if applicable */
				%if &uj = 1 %then %do;
					%let _thekeep1 = &_thekeep1 pred_Bayes_&uvar&s22uvar =pred&newuvar&s2newuvar predse_Bayes_&uvar&s22uvar=rmse&newuvar&s2newuvar;
					%let _thekeep1b = &_thekeep1b pred_Bayes_&uvar&s22uvar =pred&newuvar&s2newuvar predse_Bayes_&uvar&s22uvar=rmse&newuvar&s2newuvar;
					%let _thekeeps = &_thekeeps  pred&newuvar&s2newuvar=&_oo1_._pred&newuvar&s2newuvar  rmse&newuvar&s2newuvar=&_oo1_._se&newuvar&s2newuvar;
					%let _thekeepsb = &_thekeepsb  pred&newuvar&s2newuvar=&_oo1_._pred&newuvar&s2newuvar  rmse&newuvar&s2newuvar=&_oo1_._se&newuvar&s2newuvar;
					%let _thekeep2 = &_thekeep2 pred_Bayes_&uvar&s22uvar predse_Bayes_&uvar&s22uvar;
					%let _thekeep3 = &_thekeep3 &out.(keep= pred_Bayes_&uvar&s22uvar) &out.(keep= predse_Bayes_&uvar&s22uvar);
				%end;

				/* eMKF v2.4: Update toprint suffix with latest Bayesian model */
				%let toprint = &uvar&s22uvar;

				/* Run the Bayesian model for each chain */
				data _bayesfit_ _bayesparam_ _bayeslog_ ;
				run;

				%let _chainseed=; %let uk=0;
				%do uk=1 %to &chains;
					
					%let _chainseed = %eval(&seed + &uk - 1); /* eMKF: start seed numbering from &seed instead of &seed + 1 */

					data _bayeslogc_;
					run;

					/* eMKF: modified put statements */
					%put ;
					%put Replication _rep = &uj of &crep;
					%put Bayesian model suffix is &newuvar&s2newuvar;
					%put Chain &uk of &chains;

					/* eMKF: macro bayesfit is the workhorse for Bayesian inference, completely revamped in eMKF to use proc mcmc instead of pre-compiled C code */
					/* eMKF: added BMA version of MCMC for Bayesian model averaging uses mixture priors */
					%if %upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %do; 
						%if &breakPoint = %str() %then %do;
							%bayesBMA(	bdata = _bayesdata1_, blog = _bayeslogc_, btype = &uvar, 
										bgroup = _group_, btime = _time, boutcome = _y, bse = _se, 
										bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
										bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler,
										binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
										bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
										bmalpha = &malpha, bpalpha = &palpha, bmbeta1 = &mbeta1, bpbeta1 = &pbeta1,
										bmbeta2 = &mbeta2, bpbeta2 = &pbeta2, bmbeta3 = &mbeta3, bpbeta3 = &pbeta3,
							    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu, bvshape = &vshape, bvscale = &vscale,
										bdirichlet = &wdirichlet, bwshape = &wshape, bcmploc = &cmploc);
						%end;
						%else %do;
							%if %upcase(&breakType) = LEVEL_BREAK %then %do; /* eMKF v2.4: version of bayesBMA with level break in trend */
								%bayesBMAxptl(bdata = _bayesdata1_, blog = _bayeslogc_, btype = &uvar, 
										bgroup = _group_, btime = _time, bxpt = &breakPoint, boutcome = _y, bse = _se, 
										bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
										bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler, 
										binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
										bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
										s1bmalpha = &malpha, s1bpalpha = &palpha, s2bmalpha = &s2malpha, s2bpalpha = &s2palpha,
										bmbeta1 = &mbeta1, bpbeta1 = &pbeta1, bmbeta2 = &mbeta2, bpbeta2 = &pbeta2, bmbeta3 = &mbeta3, bpbeta3 = &pbeta3,
							    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu, bvshape = &vshape, bvscale = &vscale,
										bdirichlet = &wdirichlet, bwshape = &wshape, bcmploc = &cmploc);
							%end;
							%if %upcase(&breakType) = FULL_BREAK %then %do; /* eMKF v2.4: version of bayesBMA with full break in trend */
								%bayesBMAxptf(bdata = _bayesdata1_, blog = _bayeslogc_, s1btype = &uvar, s2btype = &s2uvar,
										bgroup = _group_, btime = _time, bxpt = &breakPoint, boutcome = _y, bse = _se, 
										bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
										bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler, 
										binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
										bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
										s1bmalpha = &malpha, s1bpalpha = &palpha, s2bmalpha = &s2malpha, s2bpalpha = &s2palpha,
										s1bmbeta1 = &mbeta1, s1bpbeta1 = &pbeta1, s2bmbeta1 = &s2mbeta1, s2bpbeta1 = &s2pbeta1,
										s1bmbeta2 = &mbeta2, s1bpbeta2 = &pbeta2, s2bmbeta2 = &s2mbeta2, s2bpbeta2 = &s2pbeta2,
										s1bmbeta3 = &mbeta3, s1bpbeta3 = &pbeta3, s2bmbeta3 = &s2mbeta3, s2bpbeta3 = &s2pbeta3,
							    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu, bvshape = &vshape, bvscale = &vscale,
										bdirichlet = &wdirichlet, bwshape = &wshape, bcmploc = &cmploc);
							%end;
						%end;
					%end;
					%else %do; 
						%if &breakPoint = %str() %then %do;
							%bayesfit(bdata = _bayesdata1_, blog = _bayeslogc_, btype = &uvar, 
									bgroup = _group_, btime = _time, boutcome = _y, bse = _se, 
									bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
									bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler, 
									binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
									bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
									bmalpha = &malpha, bpalpha = &palpha,
									bmbeta1 = &mbeta1, bpbeta1 = &pbeta1, bbeta1l = &beta1l, bbeta1u = &beta1u,
									bmbeta2 = &mbeta2, bpbeta2 = &pbeta2, bbeta2l = &beta2l, bbeta2u = &beta2u,
									bmbeta3 = &mbeta3, bpbeta3 = &pbeta3, bbeta3l = &beta3l, bbeta3u = &beta3u,
						    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu,
									bvshape = &vshape, bvscale = &vscale, bcmploc = &cmploc);
						%end;
						%else %do;
							%if %upcase(&breakType) = LEVEL_BREAK %then %do; /* eMKF v2.4: version of bayesfit with level break in trend */
								%bayesfitxptl(bdata = _bayesdata1_, blog = _bayeslogc_, btype = &uvar, 
										bgroup = _group_, btime = _time, bxpt = &breakPoint, boutcome = _y, bse = _se, 
										bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
										bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler, 
										binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
										bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
										s1bmalpha = &malpha, s1bpalpha = &palpha, s2bmalpha = &s2malpha, s2bpalpha = &s2palpha,
										bmbeta1 = &mbeta1, bpbeta1 = &pbeta1, bbeta1l = &beta1l, bbeta1u = &beta1u,
										bmbeta2 = &mbeta2, bpbeta2 = &pbeta2, bbeta2l = &beta2l, bbeta2u = &beta2u,
										bmbeta3 = &mbeta3, bpbeta3 = &pbeta3, bbeta3l = &beta3l, bbeta3u = &beta3u,
							    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu,
										bvshape = &vshape, bvscale = &vscale, bcmploc = &cmploc);
							%end;
							%if %upcase(&breakType) = FULL_BREAK %then %do; /* eMKF v2.4: version of bayesfit with full break in trend */
								%bayesfitxptf(bdata = _bayesdata1_, blog = _bayeslogc_, s1btype = &uvar, s2btype = &s2uvar,
										bgroup = _group_, btime = _time, bxpt = &breakPoint, boutcome = _y, bse = _se, 
										bn = &_ssn, brndvars = &randomVars, bARmodel = &ARmodel,
										bplot = &mcmcplot, bprint = &modelprint, bslicesampler = &slicesampler, 
										binit = &init, bprcov = &propcov, bmaxt = &maxtune, bttol = &targetaccept, batol = &accepttol,
										bseed = &_chainseed, btune = &ntu, bburn = &nbi, biter = &nmc, bthin = &thin, borpoly = &orpoly,
										s1bmalpha = &malpha, s1bpalpha = &palpha, s2bmalpha = &s2malpha, s2bpalpha = &s2palpha,
										s1bmbeta1 = &mbeta1, s1bpbeta1 = &pbeta1, s2bmbeta1 = &s2mbeta1, s2bpbeta1 = &s2pbeta1,
										s1bbeta1l = &beta1l, s1bbeta1u = &beta1u, s2bbeta1l = &s2beta1l, s2bbeta1u = &s2beta1u,
										s1bmbeta2 = &mbeta2, s1bpbeta2 = &pbeta2, s2bmbeta2 = &s2mbeta2, s2bpbeta2 = &s2pbeta2,
										s1bbeta2l = &beta2l, s1bbeta2u = &beta2u, s2bbeta2l = &s2beta2l, s2bbeta2u = &s2beta2u,
										s1bmbeta3 = &mbeta3, s1bpbeta3 = &pbeta3, s2bmbeta3 = &s2mbeta3, s2bpbeta3 = &s2pbeta3,
										s1bbeta3l = &beta3l, s1bbeta3u = &beta3u, s2bbeta3l = &s2beta3l, s2bbeta3u = &s2beta3u,
							    		bmrho = &mrho, bprho = &prho, btaul = &taul, btauu = &tauu,
										bvshape = &vshape, bvscale = &vscale, bcmploc = &cmploc);
							%end;
						%end;
					%end;

					/* eMKF: fitc dataset holds the posterior samples: start by splitting each chain in half */
					data _bayeslogc_; 
					  set _bayeslogc_;
					  chain = &uk;
					  half = 1;
					  if mod(floor(&nmc/&thin), 2) ne 0 then do;
						if _n_ = 1 then delete; 			  /* eMKF: drop first row if chain length is not even */
					  	if _n_ > (1 + floor(&nmc/&thin))/2 then half = 2;
					  end;
					  else do;
					  	if _n_ > floor(&nmc/&thin)/2 then half = 2;
					  end;
					run;
					data _bayeslog_;
					  set _bayeslog_ _bayeslogc_;
					  if chain ne .;
					run;
					    
					/* eMKF: local cleanup */
					proc datasets nolist;
					  delete _bayeslogc_  ;
					run ;
					quit;
 					
					%let _chainseed=;

				%end; /*End of &uk the chains */

				%put ;
				%put Start post-processing calculations across chains for _rep = &uj of &crep and Bayesian model suffix &newuvar&s2newuvar;

				/**********************************************************************************************/
				/* eMKF: Post-processing calculations of group differences/disparities at the last time point */ 
				/**********************************************************************************************/

				%if &comparedto ^=%str() %then %do;

					%let _idf=0; %let _jdf=0;

					data _bayeslog_;
					  set _bayeslog_;

					  /* eMKF: summary measures */
					  groupmin = min(of eta&un._1-eta&un._&ug) ; 						/* smallest rate */
					  groupmax = max(of eta&un._1-eta&un._&ug) ; 						/* largest rate */
					  groupmn1 = (sum(of eta&un._1-eta&un._&ug) - groupmin)/(&ug - 1);	/* average of all but smallest rate */
					  groupmn2 = (sum(of eta&un._1-eta&un._&ug) - groupmax)/(&ug - 1);  /* average of all but largest rate */
					  groupdif_MRD = groupmax - groupmin;								/* maximal rate difference */
					  if abs(groupmin) > 0 then grouprat_MRR = groupmax/groupmin;		/* maximal rate ratio */
					  else grouprat_MRR = .;
					  groupdif_SRD1 = groupmn1 - groupmin;								/* summary rate difference using min as reference */
					  if abs(groupmin) > 0 then grouprat_SRR1=groupmn1/groupmin;		/* summary rate ratio using min as reference */
					  else grouprat_SRR1 = .;
					  groupdif_SRD2 = groupmax - groupmn2;								/* summary rate difference using max as reference */
					  if abs(groupmn2) > 0 then grouprat_SRR2=groupmax/groupmn2;		/* summary rate ratio using max as reference */
					  else grouprat_SRR2 = .;

					  /* eMKF: all pairwise differences -- this differs from original MKF where only the unique pairs were tracked */
					  /*       this change is made, here, for consistency with the new ratio calculations, below */
					  %do _idf=1 %to &ug;   
					  	  %do _jdf=1 %to &ug;
						  	  groupdif_&_idf._&_jdf = eta&un._&_idf - eta&un._&_jdf ;
						  %end;
					  %end;

					  /* eMKF: all pairwise ratios */
					  %do _idf=1 %to &ug;   
					  	  %do _jdf=1 %to &ug; 
							  if abs(eta&un._&_jdf) > 0 then grouprat_&_idf._&_jdf = eta&un._&_idf / eta&un._&_jdf ;
							  else grouprat_&_idf._&_jdf = . ;
						  %end;
					  %end;

					  /* eMKF: differences relative to min */
					  %do _idf=1 %to &ug;   
						  groupdif_&_idf._MIN = eta&un._&_idf - groupmin ;
					  %end;

					  /* eMKF: ratios relative to min */
					  %do _idf=1 %to &ug;   
						  if abs(groupmin) > 0 then grouprat_&_idf._MIN = eta&un._&_idf / groupmin ;
						  else grouprat_&_idf._MIN =. ;
					  %end;

					  /* eMKF: differences relative to max */
					  %do _idf=1 %to &ug;   
						  groupdif_MAX_&_idf = groupmax - eta&un._&_idf ;
					  %end;

					  /* eMKF: ratios relative to max */
					  %do _idf=1 %to &ug;   
						  if abs(eta&un._&_idf) > 0 then grouprat_MAX_&_idf = groupmax / eta&un._&_idf ;
						  else grouprat_MAX_&_idf =. ;
					  %end;

					run;
	
				%end;

				/***************************************************************************************************/
				/* eMKF: Rank-normalized and folded Gelman-Rubin split-Rhat, aka. potential scale reduction factor */ 
				/*       (see Vehtari et al 2021; DOI 10.1214/20-BA1221)                                           */
				/***************************************************************************************************/

				data _bayeslogfl_ _bayeslogflrk_ _bayeslogflrkmn_ _bayeslogflrkvr_ _bayeslogflrkbv_ _bayeslogflrkwv_ _bayeslogflrkpv_
					 			  _bayeslogrk_   _bayeslogrkmn_   _bayeslogrkvr_   _bayeslogrkbv_   _bayeslogrkwv_   _bayeslogrkpv_
					 		      			     _bayeslogmn_     _bayeslogvr_     _bayeslogbv_     _bayeslogwv_     _bayeslogpv_
					 _bayeslogGR_ 					
				  ;
				run;

				/************************* eMKF: Posterior model weights in Bayesian model averaging ****************/

				%if %upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %do;

				    data _bayeslogmod_ _bayeslogmodb_ _bayeslogmodbm_ _bayeslogmodbv_ _bayeslogmodbw_;
					run;

					/* eMKF v2.4 streamlining: recode model flags using 1..7 for consistency with ML approach */
					%if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then %do;
						data _bayeslog_;
					  		set _bayeslog_;
					  	 	%if %upcase(&uvar) = BMA_QUAD %then %do;
								if flg = 5 then flg = 7;
								if flg = 4 then flg = 6;
								if flg = 3 then flg = 5;
								if flg = 2 then flg = 3;
								if flg = 1 then flg = 2;
						 	%end;
					  	 	%if %upcase(&uvar) = BMA_LINEAR %then %do;
								if flg = 3 then flg = 7;
								if flg = 2 then flg = 6;
								if flg = 1 then flg = 3;
						 	%end;
						run;
					%end;
					%else %do;
						data _bayeslog_;
					  		set _bayeslog_;
					  	 	%if %upcase(&uvar) = BMA_QUAD %then %do;
								if s1flg = 5 then s1flg = 7;
								if s1flg = 4 then s1flg = 6;
								if s1flg = 3 then s1flg = 5;
								if s1flg = 2 then s1flg = 3;
								if s1flg = 1 then s1flg = 2;
						 	%end;
					  	 	%if %upcase(&s2uvar) = BMA_QUAD %then %do;
								if s2flg = 5 then s2flg = 7;
								if s2flg = 4 then s2flg = 6;
								if s2flg = 3 then s2flg = 5;
								if s2flg = 2 then s2flg = 3;
								if s2flg = 1 then s2flg = 2;
						 	%end;
					  	 	%if %upcase(&uvar) = BMA_LINEAR %then %do;
								if s1flg = 3 then s1flg = 7;
								if s1flg = 2 then s1flg = 6;
								if s1flg = 1 then s1flg = 3;
						 	%end;
					  	 	%if %upcase(&s2uvar) = BMA_LINEAR %then %do;
								if s2flg = 3 then s2flg = 7;
								if s2flg = 2 then s2flg = 6;
								if s2flg = 1 then s2flg = 3;
						 	%end;
						run;
					%end;

					/* eMKF v2.4: tally model combinations -- modified for trend break model */
					%if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then %do;
						proc freq data=_bayeslog_ noprint;
						  by chain half;
						   tables flg /list out=_bayeslogmod_ ;
						run;
					%end;
					%else %do;
						proc freq data=_bayeslog_ noprint;
						  by chain half;
						  tables s1flg*s2flg /list out=_bayeslogmod_ ;
						run;
					%end;

					/* eMKF: within chain */
					data _bayeslogmod_;
					  set _bayeslogmod_;
					  pweight = percent/100;
					  if mod(floor(&nmc/&thin), 2) ne 0 then vweight = (percent/100)*(1-percent/100)/((floor(&nmc/&thin)-1)/2);
					  else vweight = (percent/100)*(1-percent/100)/(floor(&nmc/&thin)/2);
					  drop count percent;
					run;
					proc sort data=_bayeslogmod_;
 				 		by %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then flg; %else s1flg s2flg; ;
					run;

					/* eMKF: mean across chains */
					proc means data=_bayeslogmod_ noprint;
 				 	  by %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then flg; %else s1flg s2flg; ;
					  var pweight;
					  output out=_bayeslogmodbm_ mean=bpweight;
					run;

					/* eMKF: variance across chains */
					proc means data=_bayeslogmod_ noprint;
 				 	  by %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then flg; %else s1flg s2flg; ;
					  var pweight;
					  output out=_bayeslogmodbv_ var=bvweight;
					run;

					/* eMKF: average variance within chains */
					proc means data=_bayeslogmod_ noprint;
 				 	  by %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then flg; %else s1flg s2flg; ;
					  var vweight;
					  output out=_bayeslogmodbw_ mean=wvweight;
					run;

					/* eMKF: pooled posterior variances */
					data _bayeslogmodb_;
					  merge _bayeslogmodbm_ _bayeslogmodbv_ _bayeslogmodbw_;
 				 	  by %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then flg; %else s1flg s2flg; ;
					  drop _TYPE_ _FREQ_;
					  if mod(floor(&nmc/&thin), 2) ne 0 then pvrweight = bvweight + (1-1/((floor(&nmc/&thin)-1)/2))*wvweight;
					  else pvrweight = bvweight + (1-1/(floor(&nmc/&thin)/2))*wvweight;
					run;
				    data _bayeslogmod_;
					  set _bayeslogmodb_;
					  SD = sqrt(pvrweight);
					  rename bpweight=weight;
					  drop bvweight wvweight pvrweight;
					run;

					/* eMKF: clean-up */
					proc datasets nolist;
					  delete _bayeslogmodb_ _bayeslogmodbm_ _bayeslogmodbv_ _bayeslogmodbw_;
					run ;
					quit;

				%end;

				/*******************eMKF: Posterior means and variances and traditional split-Rhat *****************/

				/* eMKF: Means within (split) chains */
				/* eMKF v2.4 streamlining: omitted flg from mean/variance calculations below -- posterior model weights in _bayeslogmod_ above */
				proc means data=_bayeslog_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
					  %if &comparedto ^=%str() %then group: ;
				  ;
				  output out=_bayeslogmn_ mean= ;
				run;

				/* eMKF: Variances within (split) chains */
				proc means data=_bayeslog_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
					  %if &comparedto ^=%str() %then group: ;
				  ;
				  output out=_bayeslogvr_ var= ;
				run;

				/* eMKF: Within-chain variances */
				proc means data=_bayeslogvr_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
					  %if &comparedto ^=%str() %then group: ;
				  ;
				  output out=_bayeslogwv_ mean= ;
				run;

				/* eMKF: Between-chain variances */
				proc means data=_bayeslogmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
					  %if &comparedto ^=%str() %then group: ;
				  ;
				  output out=_bayeslogbv_ var= ;
				run;

				/* eMKF: Means across chains */
				proc means data=_bayeslogmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
					  %if &comparedto ^=%str() %then group: ;
				  ;
				  output out=_bayeslogmn_ mean= ;
				run;

				/* eMKF: Pooled posterior variances */
				data _bayeslogpv_;
				  set _bayeslogmn_ _bayeslogbv_ _bayeslogwv_ ;
				  drop _TYPE_ _FREQ_;
				run;
				proc transpose data=_bayeslogpv_ out = _bayeslogpv_;
				run;
				data _bayeslogpv_;
				  set  _bayeslogpv_(rename=(col1=pmn col2=bv col3=wv));
				  if mod(floor(&nmc/&thin), 2) ne 0 then pvr = bv + (1-1/((floor(&nmc/&thin)-1)/2))*wv;
				  else pvr = bv + (1-1/(floor(&nmc/&thin)/2))*wv;
				run;

				/*************eMKF: Repeat for the rank-normalized split-Rhat (with only the model parameters) ************/

				proc rank data=_bayeslog_(drop = %if &comparedto ^=%str() %then group: ;) /* eMKF: exclude disparities */
						  out=_bayeslogrk_ ties=mean normal=blom; 
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				run;

				proc means data=_bayeslogrk_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogrkmn_ mean= ;
				run;

				proc means data=_bayeslogrk_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogrkvr_ var= ;
				run;

				proc means data=_bayeslogrkvr_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogrkwv_ mean= ;
				run;

				proc means data=_bayeslogrkmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogrkbv_ var= ;
				run;

				proc means data=_bayeslogrkmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogrkmn_ mean= ;
				run;

				data _bayeslogrkpv_;
				  set _bayeslogrkmn_ _bayeslogrkbv_ _bayeslogrkwv_;
				  drop _TYPE_ _FREQ_;
				run;
				proc transpose data=_bayeslogrkpv_ out = _bayeslogrkpv_;
				run;
				data _bayeslogrkpv_;
				  set _bayeslogrkpv_(rename=(col1=rkpmn col2=rkbv col3=rkwv) drop=_LABEL_);
				  if mod(floor(&nmc/&thin), 2) ne 0 then rkpvr = rkbv + (1-1/((floor(&nmc/&thin)-1)/2))*rkwv;
				  else rkpvr = rkbv + (1-1/(floor(&nmc/&thin)/2))*rkwv;
				run;

				/**************eMKF: Repeat with rank-normalized split-Rhat computed on the folded draws *****************/

				/* eMKF: First, standardize selected variables relative to medians */
				proc stdize data=_bayeslog_(drop = %if &comparedto ^=%str() %then group: ;) /* eMKF: exclude disparities */
							out=_bayeslogfl_ method=median; 
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				run;

			   /* eMKF: Next, fold by applying absolute value on all numeric variables */
				data _bayeslogfl_;
				  set _bayeslogfl_;
				  array Nums[*] _numeric_;
				  do i = 1 to dim(Nums);
				    Nums[i] = abs(Nums[i]);
				  end;
				  drop i;
				run;

				/* eMKF: Now proceed as before using the folded draws */
				proc rank data=_bayeslogfl_ out=_bayeslogflrk_ ties=mean normal=blom;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				run;
				proc means data=_bayeslogflrk_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogflrkmn_ mean= ;
				run;
				proc means data=_bayeslogflrk_ noprint;
				  by chain half;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogflrkvr_ var= ;
				run;
				proc means data=_bayeslogflrkvr_ noprint; 
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogflrkwv_ mean= ;
				run;
				proc means data=_bayeslogflrkmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogflrkbv_ var= ;
				run;
				proc means data=_bayeslogflrkmn_ noprint;
				  var %if %upcase(&randomVars) = YES %then varr: ;
					  %if %upcase(&ARmodel) = INDEP_AR %then spsi mpsi ;
					  rho: tausq: 
					  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
					      %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then sb: mb: ; %else s1sb: s2sb: s1mb: s2mb: ;
					  %end;
					  %if &breakPoint = %str() %then ag: ; %else s1ag: s2ag: ;
					  %if %upcase(&uvar) ^= DROPPED %then %do;
						  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then b: ; %else s1b: s2b: ;
					  %end;
					  eta:
				  ;
				  output out=_bayeslogflrkmn_ mean= ;
				run;

				data _bayeslogflrkpv_;
				  set _bayeslogflrkmn_ _bayeslogflrkbv_ _bayeslogflrkwv_;
				  drop _TYPE_ _FREQ_;
				run;
				proc transpose data=_bayeslogflrkpv_ out = _bayeslogflrkpv_;
				run;
				data _bayeslogflrkpv_;
				  set _bayeslogflrkpv_(rename=(col1=flrkpmn col2=flrkbv col3=flrkwv) drop=_LABEL_);
				  if mod(floor(&nmc/&thin), 2) ne 0 then flrkpvr = flrkbv + (1-1/((floor(&nmc/&thin)-1)/2))*flrkwv;
				  else flrkpvr = flrkbv + (1-1/(floor(&nmc/&thin)/2))*flrkwv;
				run;

				/******** eMKF: Combine different split-Rhats, calculate diagnostic, and create flag for poor mixing ******/

				%let uk=1;
				%let GRthreshold = %sysevalf(&GRthreshold + 0);
				data _bayeslogGR_; 
				  merge %if &comparedto ^=%str() %then _bayeslogpv_(where=(substr(_NAME_,1,5) ne "group")); /* eMKF: exclude disparities */
						%if &comparedto =%str()  %then _bayeslogpv_; 
					    _bayeslogrkpv_ 
						_bayeslogflrkpv_
				  ;
				  if wv > 0 then splitRhat = sqrt(pvr/wv);
				  if rkwv > 0 then rksplitRhat = sqrt(rkpvr/rkwv);
				  if flrkwv > 0 then flrksplitRhat = sqrt(flrkpvr/flrkwv);
				  mixed = 1;
				  if rksplitRhat = . or flrksplitRhat = . or max(rksplitRhat, flrksplitRhat) ge &GRthreshold then do;
				  	mixed = 0;
				  	call symput("uk" , mixed);
				  end;
				  drop pmn rkpmn flrkpmn bv rkbv flrkbv;
				run;
				%let uk = %eval(&uk + 0);

				%put ;
				%put End post-processing calculations across chains for _rep = &uj of &crep and model suffix &newuvar&s2newuvar;

				/* eMKF: Issue warning message for poor mixing */
				%if &uk = 0 %then %do;
					%put WARNING: Gelman-Rubin diagnostics at the threshold &GRthreshold suggest poor mixing with &chains chains.;
					%put WARNING- Model predictions may be unreliable based on this threshold value: see dataset &out._bayeslogGR_ for more info.;
					%put WARNING- Consider investigating the chain-specific diagnostic plots, modifying MCMC options, or picking a simpler model.;
					proc iml;
				  print " Warning: Gelman-Rubin diagnostics at the threshold &GRthreshold suggest poor mixing with &chains chains.";
				  print "  		   Model predictions may unreliable based on this threshold value: see dataset &out._bayeslogGR_ for more info.";
				  print "          Consider investigating the chain-specific diagnostic plots, modifying MCMC options, or picking a simpler model.";
					quit;
			    %end;

				/* eMKF: Final MCMC estimates are the posterior means and corrected posterior variances across chains */
				data pmns pvrs;
				run;
				proc transpose data=_bayeslogpv_(drop = pvr) suffix=pmn out=pmns;
				  var pmn;
  				  ID _NAME_;
				run;
				proc transpose data=_bayeslogpv_(drop = pmn) suffix=pvr out=pvrs;
				  var pvr;
  				  ID _NAME_;
				run;
				data _bayesfit_;
				  merge pmns(drop=_NAME_) pvrs(drop=_NAME_);
				run;

				/* eMKF: param dataset will hold the model parameters + etas */
				data _bayesparam_; 
				  set _bayesfit_;
				  %if &comparedto ^=%str() %then drop group: ;
				;
				run; 

				/* eMKF: fitc dataset will hold the etas and group differences/disparities at the latest timepoint */
				data _bayesfit_; 
				  set _bayesfit_;
				  keep eta: %if &comparedto ^=%str() %then group: ;
 				;
				run;   

				/* eMKF: local cleanup */
				proc datasets nolist;
				  delete _bayeslogfl_ _bayeslogflrk_ _bayeslogflrkmn_ _bayeslogflrkvr_ _bayeslogflrkbv_ _bayeslogflrkwv_ _bayeslogflrkpv_
					     			  _bayeslogrk_   _bayeslogrkmn_   _bayeslogrkvr_   _bayeslogrkbv_   _bayeslogrkwv_   _bayeslogrkpv_
					 	 		      				 _bayeslogmn_     _bayeslogvr_     _bayeslogbv_     _bayeslogwv_     _bayeslogpv_
						 pmns pvrs
					  ;
				run;
				quit;

				/*********************************************************************************************************/
				/* eMKF: Revert to long format instead of wide format for compatibility with remainder of code from RAND */
				/*********************************************************************************************************/

				data _bayesparamt_ _bayesfitt_;
				run;

				/* eMKF v2.4: transposed parameter data set for no break point or level break only */
				%if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then %do;
					%let _igrp_ = 0; %let _t_ = 0;
					data _bayesparamt_ ;
					  set _bayesparam_;				  	  
					  %do _t_ = 1 %to &un;
					  	  %do _igrp_ = 1 %to &ug;
						  	  _group_ = &_igrp_;
						  	  _time = &_t_;
							  %if %upcase(&randomVars) = YES %then %do;
							      varrpmn&newuvar&s2newuvar = varr&_igrp_.pmn;
							      varrpvr&newuvar&s2newuvar = varr&_igrp_.pvr;
								  drop varr&_igrp_.pmn varr&_igrp_.pvr;
							  %end;
							  %if %upcase(&ARmodel) = INDEP_AR %then %do;
								  spsipmn&newuvar&s2newuvar = spsipmn;
								  spsipvr&newuvar&s2newuvar = spsipvr;
								  mpsipmn&newuvar&s2newuvar = mpsipmn;
								  mpsipvr&newuvar&s2newuvar = mpsipvr;
								  rhopmn&newuvar&s2newuvar = rho&_igrp_.pmn; 
								  rhopvr&newuvar&s2newuvar = rho&_igrp_.pvr; 
								  tausqpmn&newuvar&s2newuvar = tausq&_igrp_.pmn; 
								  tausqpvr&newuvar&s2newuvar = tausq&_igrp_.pvr;
								  drop rho&_igrp_.pmn rho&_igrp_.pvr tausq&_igrp_.pmn tausq&_igrp_.pvr mpsipmn mpsipvr spsipmn spsipvr ;
							  %end;
							  %if %upcase(&ARmodel) = COMMON_ARH %then %do; /* eMKF v2.4 new option */
								  rhopmn&newuvar&s2newuvar = rhopmn; 
								  rhopvr&newuvar&s2newuvar = rhopvr; 
								  tausqpmn&newuvar&s2newuvar = tausq&_igrp_.pmn; 
								  tausqpvr&newuvar&s2newuvar = tausq&_igrp_.pvr;
								  drop rhopmn rhopvr tausq&_igrp_.pmn tausq&_igrp_.pvr;
							  %end;
							  %if %upcase(&ARmodel) = COMMON_AR %then %do;
								  rhopmn&newuvar&s2newuvar = rhopmn; 
								  rhopvr&newuvar&s2newuvar = rhopvr; 
								  tausqpmn&newuvar&s2newuvar = tausqpmn; 
								  tausqpvr&newuvar&s2newuvar = tausqpvr;
								  drop rhopmn rhopvr tausqpmn tausqpvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
								  sb1pmn&newuvar&s2newuvar = sb1pmn; 
								  sb1pvr&newuvar&s2newuvar = sb1pvr;
							  	  mb1pmn&newuvar&s2newuvar = mb1pmn; 
								  mb1pvr&newuvar&s2newuvar = mb1pvr; 
								  drop mb1pmn mb1pvr sb1pmn sb1pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD %then %do;
								  sb2pmn&newuvar&s2newuvar = sb2pmn; 
								  sb2pvr&newuvar&s2newuvar = sb2pvr;
							  	  mb2pmn&newuvar&s2newuvar = mb2pmn; 
								  mb2pvr&newuvar&s2newuvar = mb2pvr; 
								  drop mb2pmn mb2pvr sb2pmn sb2pvr;
							  %end;
							  %if %upcase(&uvar) = FULL_CUBIC %then %do;
								  sb3pmn&newuvar&s2newuvar = sb3pmn; 
								  sb3pvr&newuvar&s2newuvar = sb3pvr;
							  	  mb3pmn&newuvar&s2newuvar = mb3pmn; 
								  mb3pvr&newuvar&s2newuvar = mb3pvr; 
								  drop mb3pmn mb3pvr sb3pmn sb3pvr;
							  %end;
							  %if &breakPoint = %str() %then %do;
							  	  apmn&newuvar&s2newuvar = ag&_igrp_.pmn;
								  apvr&newuvar&s2newuvar = ag&_igrp_.pvr;
								  drop ag&_igrp_.pmn ag&_igrp_.pvr;
							  %end;
							  %if &breakPoint ^= %str() %then %do;  /* eMKF v2.4 trend break option */
							  	  s1apmn&newuvar&s2newuvar = s1ag&_igrp_.pmn;
								  s1apvr&newuvar&s2newuvar = s1ag&_igrp_.pvr;
							  	  s2apmn&newuvar&s2newuvar = s2ag&_igrp_.pmn;
								  s2apvr&newuvar&s2newuvar = s2ag&_igrp_.pvr;
								  drop s1ag&_igrp_.pmn s1ag&_igrp_.pvr s2ag&_igrp_.pmn s2ag&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
						  	  	  b1pmn&newuvar&s2newuvar = b1pmn;
							  	  b1pvr&newuvar&s2newuvar = b1pvr;
								  drop b1pmn b1pvr;
							  %end;
							  %if not(%upcase(&uvar) in DROPPED COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
						  	  	  b1pmn&newuvar&s2newuvar = b1g&_igrp_.pmn;
							  	  b1pvr&newuvar&s2newuvar = b1g&_igrp_.pvr;
								  drop b1g&_igrp_.pmn b1g&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) in COMMON_QUAD COMMON_CUBIC %then %do;
						  	  	  b2pmn&newuvar&s2newuvar = b2pmn;
							  	  b2pvr&newuvar&s2newuvar = b2pvr;
								  drop b2pmn b2pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_QUAD INDEP_QUAD BMA_QUAD FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
						  	  	  b2pmn&newuvar&s2newuvar = b2g&_igrp_.pmn;
							  	  b2pvr&newuvar&s2newuvar = b2g&_igrp_.pvr;
								  drop b2g&_igrp_.pmn b2g&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) = COMMON_CUBIC %then %do;
						  	  	  b3pmn&newuvar&s2newuvar = b3pmn;
							  	  b3pvr&newuvar&s2newuvar = b3pvr;
								  drop b3pmn b3pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
						  	  	  b3pmn&newuvar&s2newuvar = b3g&_igrp_.pmn;
							  	  b3pvr&newuvar&s2newuvar = b3g&_igrp_.pvr;
								  drop b3g&_igrp_.pmn b3g&_igrp_.pvr;
							  %end;
							  etapmn&newuvar&s2newuvar = eta&_t_._&_igrp_.pmn;
							  etapvr&newuvar&s2newuvar = eta&_t_._&_igrp_.pvr;
							  drop eta&_t_._&_igrp_.pmn eta&_t_._&_igrp_.pvr;
							  output;
						  %end;
					  %end;
				    run; 
				%end;
				%else %do; 	  /* eMKF v2.4: transposed parameter data set for full trend break scenario */
					%let _igrp_ = 0; %let _t_ = 0;
					data _bayesparamt_ ;
					  set _bayesparam_;				  	  
					  %do _t_ = 1 %to &un;
					  	  %do _igrp_ = 1 %to &ug;
						  	  _group_ = &_igrp_;
						  	  _time = &_t_;
							  %if %upcase(&randomVars) = YES %then %do;
							      varrpmn&newuvar&s2newuvar = varr&_igrp_.pmn;
							      varrpvr&newuvar&s2newuvar = varr&_igrp_.pvr;
								  drop varr&_igrp_.pmn varr&_igrp_.pvr;
							  %end;
							  %if %upcase(&ARmodel) = INDEP_AR %then %do;
								  spsipmn&newuvar&s2newuvar = spsipmn;
								  spsipvr&newuvar&s2newuvar = spsipvr;
								  mpsipmn&newuvar&s2newuvar = mpsipmn;
								  mpsipvr&newuvar&s2newuvar = mpsipvr;
								  rhopmn&newuvar&s2newuvar = rho&_igrp_.pmn; 
								  rhopvr&newuvar&s2newuvar = rho&_igrp_.pvr; 
								  tausqpmn&newuvar&s2newuvar = tausq&_igrp_.pmn; 
								  tausqpvr&newuvar&s2newuvar = tausq&_igrp_.pvr;
								  drop rho&_igrp_.pmn rho&_igrp_.pvr tausq&_igrp_.pmn tausq&_igrp_.pvr mpsipmn mpsipvr spsipmn spsipvr ;
							  %end;
							  %if %upcase(&ARmodel) = COMMON_ARH %then %do; /* eMKF v2.4 new option */
								  rhopmn&newuvar&s2newuvar = rhopmn; 
								  rhopvr&newuvar&s2newuvar = rhopvr; 
								  tausqpmn&newuvar&s2newuvar = tausq&_igrp_.pmn; 
								  tausqpvr&newuvar&s2newuvar = tausq&_igrp_.pvr;
								  drop rhopmn rhopvr tausq&_igrp_.pmn tausq&_igrp_.pvr;
							  %end;
							  %if %upcase(&ARmodel) = COMMON_AR %then %do;
								  rhopmn&newuvar&s2newuvar = rhopmn; 
								  rhopvr&newuvar&s2newuvar = rhopvr; 
								  tausqpmn&newuvar&s2newuvar = tausqpmn; 
								  tausqpvr&newuvar&s2newuvar = tausqpvr;
								  drop rhopmn rhopvr tausqpmn tausqpvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do; /* eMKF v2.4: note this implies s2uvar is at least full_linear */
								  s1sb1pmn&newuvar&s2newuvar = s1sb1pmn; 
								  s1sb1pvr&newuvar&s2newuvar = s1sb1pvr;
							  	  s1mb1pmn&newuvar&s2newuvar = s1mb1pmn; 
								  s1mb1pvr&newuvar&s2newuvar = s1mb1pvr; 
								  s2sb1pmn&newuvar&s2newuvar = s2sb1pmn; 
								  s2sb1pvr&newuvar&s2newuvar = s2sb1pvr;
							  	  s2mb1pmn&newuvar&s2newuvar = s2mb1pmn; 
								  s2mb1pvr&newuvar&s2newuvar = s2mb1pvr; 
								  drop s1mb1pmn s1mb1pvr s1sb1pmn s1sb1pvr s2mb1pmn s2mb1pvr s2sb1pmn s2sb1pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC FULL_QUAD %then %do;
								  s1sb2pmn&newuvar&s2newuvar = s1sb2pmn; 
								  s1sb2pvr&newuvar&s2newuvar = s1sb2pvr;
							  	  s1mb2pmn&newuvar&s2newuvar = s1mb2pmn; 
								  s1mb2pvr&newuvar&s2newuvar = s1mb2pvr; 
								  %if %upcase(&s2uvar) in FULL_CUBIC FULL_QUAD %then %do;
									  s2sb2pmn&newuvar&s2newuvar = s2sb2pmn; 
									  s2sb2pvr&newuvar&s2newuvar = s2sb2pvr;
								  	  s2mb2pmn&newuvar&s2newuvar = s2mb2pmn; 
									  s2mb2pvr&newuvar&s2newuvar = s2mb2pvr; 
									  drop s2mb2pmn s2mb2pvr s2sb2pmn s2sb2pvr;
								  %end;
								  drop s1mb2pmn s1mb2pvr s1sb2pmn s1sb2pvr;
							  %end;
							  %if %upcase(&uvar) = FULL_CUBIC %then %do;
								  s1sb3pmn&newuvar&s2newuvar = s1sb3pmn; 
								  s1sb3pvr&newuvar&s2newuvar = s1sb3pvr;
							  	  s1mb3pmn&newuvar&s2newuvar = s1mb3pmn; 
								  s1mb3pvr&newuvar&s2newuvar = s1mb3pvr; 
								  %if %upcase(&s2uvar) = FULL_CUBIC %then %do;
									  s2sb3pmn&newuvar&s2newuvar = s2sb3pmn; 
									  s2sb3pvr&newuvar&s2newuvar = s2sb3pvr;
								  	  s2mb3pmn&newuvar&s2newuvar = s2mb3pmn; 
									  s2mb3pvr&newuvar&s2newuvar = s2mb3pvr; 
									  drop s2mb3pmn s2mb3pvr s2sb3pmn s2sb3pvr;
								  %end;
								  drop s1mb3pmn s1mb3pvr s1sb3pmn s1sb3pvr;
							  %end;
							  %if &breakPoint = %str() %then %do;
							  	  apmn&newuvar&s2newuvar = ag&_igrp_.pmn;
								  apvr&newuvar&s2newuvar = ag&_igrp_.pvr;
								  drop ag&_igrp_.pmn ag&_igrp_.pvr;
							  %end;
							  %if &breakPoint ^= %str() %then %do;  /* eMKF v2.4 trend break option */
							  	  s1apmn&newuvar&s2newuvar = s1ag&_igrp_.pmn;
								  s1apvr&newuvar&s2newuvar = s1ag&_igrp_.pvr;
							  	  s2apmn&newuvar&s2newuvar = s2ag&_igrp_.pmn;
								  s2apvr&newuvar&s2newuvar = s2ag&_igrp_.pvr;
								  drop s1ag&_igrp_.pmn s1ag&_igrp_.pvr s2ag&_igrp_.pmn s2ag&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do; /* eMKF v2.4: note this implies s2uvar is at least common_linear */
						  	  	  s1b1pmn&newuvar&s2newuvar = s1b1pmn;
							  	  s1b1pvr&newuvar&s2newuvar = s1b1pvr;
						  	  	  s2b1pmn&newuvar&s2newuvar = s2b1pmn;
							  	  s2b1pvr&newuvar&s2newuvar = s2b1pvr;
								  drop s1b1pmn s1b1pvr s2b1pmn s2b1pvr;
							  %end;
							  %if not(%upcase(&uvar) in DROPPED COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do; /* eMKF v2.4: note this implies is at least _linear */
						  	  	  s1b1pmn&newuvar&s2newuvar = s1b1g&_igrp_.pmn;
							  	  s1b1pvr&newuvar&s2newuvar = s1b1g&_igrp_.pvr;
						  	  	  s2b1pmn&newuvar&s2newuvar = s2b1g&_igrp_.pmn;
							  	  s2b1pvr&newuvar&s2newuvar = s2b1g&_igrp_.pvr;
								  drop s1b1g&_igrp_.pmn s1b1g&_igrp_.pvr s2b1g&_igrp_.pmn s2b1g&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) in COMMON_QUAD COMMON_CUBIC %then %do;
						  	  	  s1b2pmn&newuvar&s2newuvar = s1b2pmn;
							  	  s1b2pvr&newuvar&s2newuvar = s1b2pvr;
								  %if %upcase(&s2uvar) in COMMON_QUAD COMMON_CUBIC %then %do;
							  	  	  s2b2pmn&newuvar&s2newuvar = s2b2pmn;
								  	  s2b2pvr&newuvar&s2newuvar = s2b2pvr;
									  drop s2b2pmn s2b2pvr;
								  %end;
								  drop s1b2pmn s1b2pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_QUAD INDEP_QUAD BMA_QUAD FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
						  	  	  s1b2pmn&newuvar&s2newuvar = s1b2g&_igrp_.pmn;
							  	  s1b2pvr&newuvar&s2newuvar = s1b2g&_igrp_.pvr;
								  %if %upcase(&s2uvar) in FULL_QUAD INDEP_QUAD BMA_QUAD FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
							  	  	  s2b2pmn&newuvar&s2newuvar = s2b2g&_igrp_.pmn;
								  	  s2b2pvr&newuvar&s2newuvar = s2b2g&_igrp_.pvr;
									  drop s2b2g&_igrp_.pmn s2b2g&_igrp_.pvr;
								  %end;
								  drop s1b2g&_igrp_.pmn s1b2g&_igrp_.pvr;
							  %end;
							  %if %upcase(&uvar) = COMMON_CUBIC %then %do;
						  	  	  s1b3pmn&newuvar&s2newuvar = s1b3pmn;
							  	  s1b3pvr&newuvar&s2newuvar = s1b3pvr;
								  %if %upcase(&s2uvar) = COMMON_CUBIC %then %do;
							  	  	  s2b3pmn&newuvar&s2newuvar = s2b3pmn;
								  	  s2b3pvr&newuvar&s2newuvar = s2b3pvr;
									  drop s2b3pmn s2b3pvr;
								  %end;
								  drop s1b3pmn s1b3pvr;
							  %end;
							  %if %upcase(&uvar) in FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
						  	  	  s1b3pmn&newuvar&s2newuvar = s1b3g&_igrp_.pmn;
							  	  s1b3pvr&newuvar&s2newuvar = s1b3g&_igrp_.pvr;
								  %if %upcase(&s2uvar) in FULL_CUBIC INDEP_CUBIC BMA_CUBIC %then %do;
							  	  	  s2b3pmn&newuvar&s2newuvar = s2b3g&_igrp_.pmn;
								  	  s2b3pvr&newuvar&s2newuvar = s2b3g&_igrp_.pvr;
									  drop s2b3g&_igrp_.pmn s2b3g&_igrp_.pvr;
								  %end;
								  drop s1b3g&_igrp_.pmn s1b3g&_igrp_.pvr;
							  %end;
							  etapmn&newuvar&s2newuvar = eta&_t_._&_igrp_.pmn;
							  etapvr&newuvar&s2newuvar = eta&_t_._&_igrp_.pvr;
							  drop eta&_t_._&_igrp_.pmn eta&_t_._&_igrp_.pvr;
							  output;
						  %end;
					  %end;
				    run; 
				%end;

				proc sort data=_bayesparamt_ out=_bayesparam_ ;
				  by _group_ _time;
				run;

				/* eMKF: transposed predictions data set */

				%if &comparedto ^=%str() %then %do;
					proc transpose data=_bayesfit_(drop = eta:) out=_bayesfitt_;
					run;
					data _bayesfitt_;
					  set _bayesfitt_;
					  if scan(_name_,1,"_") in("groupdif", "grouprat") then do;
						  if scan(_name_,3,"_") ^= "" then do;
						  	 if scan(_name_,2,"_") ^= "MAX" then _diffgrp1_ = 1*scan(_name_,2,"_");
							 else _diffgrp1_ = - &ug;
							 if substr(scan(_name_,3,"_"), 1, length(scan(_name_,3,"_")) - 3) ^= "MIN" then 
						  	 	_diffgrp2_ = 1*substr(scan(_name_,3,"_"), 1, length(scan(_name_,3,"_")) - 3);
							 else _diffgrp2_ = 0;
						  end;
						  else do;
						  	 if substr(scan(_name_,2,"_"), 1, length(scan(_name_,2,"_")) - 3) in("MRD", "MRR") then do;
							 	_diffgrp1_ = - &ug;
							    _diffgrp2_ = 0;
							 end;
						  	 if substr(scan(_name_,2,"_"), 1, length(scan(_name_,2,"_")) - 3) in("SRD1", "SRR1") then do;
							 	_diffgrp1_ = - (&ug-1)/2;
							    _diffgrp2_ = 0;
							 end;
						  	 if substr(scan(_name_,2,"_"), 1, length(scan(_name_,2,"_")) - 3) in("SRD2", "SRR2") then do;
							 	_diffgrp1_ = - &ug;
							    _diffgrp2_ = -(&ug-1)/2;
							 end;
						  end;
					  end;
					  if substr(_name_, 6, 3) = "dif" then _disparity = "difference";
					  if substr(_name_, 6, 3) = "rat" then _disparity = "ratio";
					  if substr(_name_, 6, 3) = "min" then _disparity = "min";
					  if substr(_name_, 6, 3) = "max" then _disparity = "max";
					  if substr(_name_, 6, 3) = "mn1" then _disparity = "avgexclmin";
					  if substr(_name_, 6, 3) = "mn2" then _disparity = "avgexclmax";
					  if substr(_name_, length(_name_)- 2, 3) = "pvr" then type="pvr";
					  if substr(_name_, length(_name_)- 2, 3) = "pmn" then type="pmn";
					run;
					proc sort data=_bayesfitt_;
	 				  by _disparity _diffgrp1_ _diffgrp2_;
					run;
					data _bayesfitt_;
					  merge _bayesfitt_(where=(type="pmn") rename=(col1=pred_Bayes_&uvar&s22uvar))
					        _bayesfitt_(where=(type="pvr") rename=(col1=predVar_Bayes_&uvar&s22uvar))
					        ;
					  predSE_Bayes_&uvar&s22uvar = sqrt(predVar_Bayes_&uvar&s22uvar);
					  rename _diffgrp1_ = _group_;
					  drop type _name_;
					run;
					data _bayesfitt_;
	 				  merge _bayesfitt_(keep= _diffgrp2_ _disparity _group_) _bayesfitt_(drop= _diffgrp2_ _disparity _group_);
					  _time = &un;
					  _oldtime = _time;
					  if _diffgrp2_ > 0 then _newtime = _time + _diffgrp2_;
					  if _diffgrp2_ le 0 then _newtime = _time + &ug + 1 - _diffgrp2_;
					  if _diffgrp2_ =.  then _newtime = _time + &ug + 2 ;
					  _time = _newtime;
					run;
				%end;

				%let _igrp_ = 0; %let _t_ = 0;
				data _bayesfit_ ;
				  set _bayesfit_;
				  %if &comparedto ^= %str() %then drop group: ;;
				  %do _t_ = 1 %to &un;
				  	  %do _igrp_ = 1 %to &ug;
					  	  _group_ = &_igrp_;
						  _time = &_t_;
						  _oldtime = &_t_;
					  	  _newtime = &_t_;
						  pred_Bayes_&uvar&s22uvar = eta&_t_._&_igrp_.pmn;
						  predVar_Bayes_&uvar&s22uvar = eta&_t_._&_igrp_.pvr;
						  predSE_Bayes_&uvar&s22uvar = sqrt(eta&_t_._&_igrp_.pvr);
						  drop eta&_t_._&_igrp_.pmn eta&_t_._&_igrp_.pvr;
						  output;
					  %end;
				  %end;
			    run;
				data _bayesfit_;
				  set _bayesfit_ %if &comparedto ^=%str() %then _bayesfitt_;;
				run;
				proc sort data=_bayesfit_;
				  by _group_ _time %if &comparedto ^=%str() %then _disparity;;
				run;

				/* eMKF: finalize datasets  */
				%if %upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %do;
					data _bayeslogmod_;
					  set _bayeslogmod_;
					  Model = resolve('&newuvar&s2newuvar'); 
					run;
					proc sort data=_bayeslogmod_ out=_bayeslogmod_;
					  by Model ;
					run;
				%end;
				data _bayeslogGR_;
				  set _bayeslogGR_;
				  Model = resolve('&newuvar&s2newuvar'); 
				run;
				proc sort data=_bayeslogGR_ out=_bayeslogGR_;
				  by Model ;
				run;

				/* eMKF: remove differences and ratios from logfile to minimize dataset size (user could recalculate those if needed) */
				data _bayeslog_;
				  set _bayeslog_;
				  Model = resolve('&newuvar&s2newuvar'); 
				  %if &comparedto ^=%str() %then drop group: ;; 
				run;
				proc sort data=_bayeslog_ out=_bayeslog_;
				  by Model Iteration ;
				run;

				/* eMKF: append datasets by model */
				data _bayesfit2_;
				  %if &ui = 1 %then set _bayesfit_;;
				  %if &ui > 1 %then merge _bayesfit2_ _bayesfit_;;
				  %if &ui > 1 %then by _group_ _time %if &comparedto ^=%str() %then _disparity;;;
				run;
				data _bayesparam2_;
				  %if &ui = 1 %then set _bayesparam_;;
				  %if &ui > 1 %then merge _bayesparam2_ _bayesparam_;;
				  %if &ui > 1 %then by _group_ _time;;
				run;
				data _bayeslogGR2_;
				  %if &ui = 1 %then set _bayeslogGR_;;
				  %if &ui > 1 %then merge _bayeslogGR2_ _bayeslogGR_;;
				  %if &ui > 1 %then by Model ;;
				run;
				data _bayeslog2_;
				  %if &ui = 1 %then set _bayeslog_;;
				  %if &ui > 1 %then merge _bayeslog2_ _bayeslog_;;
				  %if &ui > 1 %then by Model Iteration;;
				run;
				%if %upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %do;
					data _bayeslogmod2_;
					  %if &ui = 1 %then set _bayeslogmod_;;
					  %if &ui > 1 %then merge _bayeslogmod2_ _bayeslogmod_;;
					  %if &ui > 1 %then by Model ;;
					run;
				%end;

				/* eMKF: local cleanup */
				proc datasets nolist;
				  delete _bayesparamt_ _bayesfitt_ _bayesparam_ _bayesfit_ _bayeslogGR_ _bayeslog_ 
				  		 %if %upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then _bayeslogmod_;
				  ;
				run;
				quit;

				%let uvar= ; %let newuvar= ; %let s2uvar= ; %let s2newuvar= ; %let s22uvar= ;

			%end; /*End of the Bayesian %do &ui*/

			%put ;
			%put End of Bayesian model fitting for _rep = &uj of &crep ;

			/* eMKF: Track the stratum identifier _rep */
			%if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then %do;
				data _bayeslogmod2_;
				  set _bayeslogmod2_;
				  _rep = &uj;
				run;
			%end;
			data _bayeslogGR2_;
			  set _bayeslogGR2_;
			  _rep = &uj;
			run;
			data _bayeslog2_;
			  set _bayeslog2_;
			  _rep = &uj;
			run;
			data _bayesparam2_;
			  set _bayesparam2_;
			  _rep = &uj;
			run;
			data _bayesfit2_;
			  set _bayesfit2_;
			  _rep = &uj;
			run;

			/* eMKF: Prepare output dataset &out._bayes with differences and ratios */
			data _bayesfit2_;
			  set _bayesfit2_;
			  _time =_oldtime;
			  _idd+1;
			run;
			%if &comparedto ^=%str() %then %do;
				proc sort data=_bayesfit2_;
			  	  by _diffgrp2_;
				run;
			%end;
			data _junk_;
			run;
			proc sort data=_bayesdata1_ out= _junk_(keep= _group_ &group _rep) nodupkey;
			  by _group_;
			run;
			data _bayesfit2_;
			  merge _bayesfit2_ 
			  		%if &comparedto =%str()  %then _junk_;
			  		%if &comparedto ^=%str() %then _junk_(rename=(_group_=_diffgrp2_ &group=diff_&group));
			  ;
			  by %if &comparedto =%str() %then _group_; %else _diffgrp2_; ;
			run;
			proc sort data=_bayesfit2_;
			  by _idd;
			run;
			data _bayesfit2_;
			  set _bayesfit2_;
			  drop _idd;
			run;
			data &out._bayes;
			  set &out._bayes _bayesfit2_;
			  if _time ne .;
			  %if &comparedto ^=%str() %then if _diffgrp2_ = -(&ug-1)/2 then diff_&group = "AVGEXCLMAX";;
			  %if &comparedto ^=%str() %then if _diffgrp2_ = 0 then diff_&group = "MIN";;
			run;

			/* eMKF: Append remaining datasets */
			data &out._bayesparm;
			  set &out._bayesparm _bayesparam2_;
			  if _time ne .;
			run;
			data &out._bayeslogGR;
			  set &out._bayeslogGR _bayeslogGR2_;
			  if mixed ne .;
			run;
			%if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then %do;
				data &out._bayeslogmod;
				  set &out._bayeslogmod _bayeslogmod2_;
 				  %if &breakPoint = %str() or %upcase(&breakType) = LEVEL_BREAK %then if flg ne .;; 
				  %if %upcase(&breakType) = FULL_BREAK %then if s1flg ne . and s2flg ne .;;
				run;
			%end;

			/* eMKF: To keep file size manageable, use separate dataset for each replication instead of appending */
			%if %upcase(&mcmclog) = YES %then %do;
				data &out._bayeslog_rep&uj;
				  set _bayeslog2_;
				  if Iteration ne .;
				run;
			%end;

		%end; /* End of replications %do uj*/

		%put ;
		%put End of all Bayesian model fitting loops ;

		/* eMKF: local cleanup */
		%if %upcase(&mcmclog) ^= YES %then %do;
			%let uj=0;
			%do uj=1 %to &crep; 
				proc datasets nolist;
					delete &out._bayeslog_rep&uj; 
				run;
				quit;
			%end;
		%end;
		proc datasets nolist;
		  delete _junk_ _bayesdata1_ _bayesfit2_ _bayesparam2_ _bayeslogGR2_ _bayeslog2_ 
				 %if &flag1a = 1 or &flag2a = 1 or &flag3a = 1 %then _bayeslogmod2_;
		  ;
		run;
		quit;

		/* eMKF: Adding original data back for reference */
		data _junk_;
		run;
		proc sort data= _bayesdata_ out=_junk_(drop= &outcome2 &se2) nodupkey;
		  by _rep _group_ _time ;
		run;
		data _junkN_;
		run;
		proc sort data= _bayesdata_(where = (_group_ = 1 and _time = &un)) out=_junkN_(keep= &time &by _time _rep) nodupkey;
		  by _rep ;
		run;
		data _outbs1 _outbs2 _outbs3;
		run;
		data _outbs3;
		  merge _junk_ &out._bayes(where = (_newtime le &un));
		  by _rep _group_ _time;
		  %if &comparedto ^=%str() %then if _group_ = -&ug then &group = "MAX";;
		  %if &comparedto ^=%str() %then if _group_ = -(&ug-1)/2 then &group = "AVGEXCLMIN";;
		run;
		%if &comparedto ^=%str() %then %do;
			data _outbs1;
			  merge _junkN_(drop=_time) &out._bayes(where = (_newtime > &un));
			  by _rep;
			run;
			proc sort data= _outbs1;
			  by _rep _group_ _newtime ;
			run;
			data _outbs2;
			  merge _junk_(where=(_time = &un)) _outbs1;
			  by _rep _group_ ;
			  if _group_ = -&ug then &group = "MAX";
			  if _group_ = -(&ug-1)/2 then &group = "AVGEXCLMIN";
			run;
			proc sort data= _outbs2;
			  by _rep _group_ _newtime ;
			run;
		%end;
		data &out._bayes;
		    set _outbs2 _outbs3;
		run;
		proc sort data= &out._bayes;
		  by _rep _group_ _time _newtime;
		run;
		data &out._bayesparm;
		  merge _junk_ &out._bayesparm;
		  by _rep _group_ _time;
		run;

		/* eMKF: Set up comparisons data set if requested */

		%let _comp2=; 

		%if &comparedto ^=%str() %then %do;

			data &comparedata;
			run;
			data &comparedata;
			  set &out._bayes;
			  if _group_ = . or _diffgrp2_ ne . ;
			run;

			/* eMKF: find label of comparison group - modified to allow for min/max used as reference  */
			data _junk_ _junk0_;
			run;
			proc freq data=&comparedata noprint;
			  tables &group/ list out=_junk_;
			run;
			proc freq data=&comparedata noprint;
			  tables diff_&group/ list out=_junk0_;
			run;
			data _junk_;
			  set _junk_ _junk0_;
			  _comp_ = upcase(compress("&comparedto"));
			  if upcase(compress(&group)) = _comp_ then call symput("_comp2", &group);
			  else if upcase(compress(diff_&group)) = _comp_ then call symput("_comp2", diff_&group);;
			run;

			%if &_comp2 = %str() %then %do; /* eMKF v2.4 correction: dropped  and %upcase(&_comp2) ^= MIN and %upcase(&_comp2) ^= MAX from clause */
			    /* eMKF: Shortened warning message in log*/
				%if %upcase(&comparedto) ^=%str() and %upcase(&comparedto) ^= UNSPECIFIED %then %do; /* eMKF v2.4 correction: added clause for when &comparedto is unspecified */
					%put WARNING: The comparison group &comparedto is not a &group or a recognized reference value.;
				%end;
				%else %do;
					%put WARNING: The comparison group was not specified.;
				%end;
				%put WARNING- No comparisons will be printed at this point.;
				proc iml; /* eMKF: Added warning message to HTML output*/
	 			    %if %upcase(&comparedto) ^=%str() and %upcase(&comparedto) ^= UNSPECIFIED %then %do; /* eMKF v2.4 correction: added clause for when &comparedto is unspecified */
				        print " Warning: The comparison group &comparedto is not a &group or a recognized reference value";
					    print "  		 Check to make sure the value &comparedto is correct";
					%end;
					%else %do;
						print "          The comparison group was not specified";
					%end;
					print "          No comparisons will be printed at this point";
	                print "          All comparisons could be found in the &out._bayes data ";
				quit;
			%end;

			proc datasets nolist;
		  		delete _junk0_ ;
			run ;
			quit;

			/* eMKF v2.4 correction: reset &comparedata dataset to null here instead of after the next %if statement */
			data &comparedata;
			run;
		%end;

		%let comparedto = &_comp2;

		%if &comparedto ^=%str() %then %do;
			data &comparedata;
			  set &out._bayes;
			  if _diffgrp2_ ne . ;
			  if upcase(compress(&group)) = upcase(compress("&comparedto")) or upcase(compress(diff_&group)) = upcase(compress("&comparedto"));
			  if upcase(compress(&group)) = upcase(compress(diff_&group)) then delete;
			  if upcase(compress("&comparedto")) ^= "MAX" and upcase(compress("&comparedto")) ^= "MIN" then do;
			  	if upcase(compress(&group)) = "MAX" or upcase(compress(diff_&group)) = "MIN" then delete;
			  end;
			  &group._1 = &group;
			  &group._2 = diff_&group;
			  _thekey = 1;
			  rename &_thekeep1b;;
			  drop _avgse _y _se &outcome &se &outcome2 &se2 impute _diffgrp2_ _oldtime _newtime predvar_Bayes_: 
			       %if &by ^=%str() %then _avgseb imputeb;
				   %if %upcase(&randomVars) = YES %then _avgn _n;
				   %if %upcase(&randomVars) = YES and &by ^=%str() %then _avgnb;
              ;
			run;
			data _junk_;
			run;
			proc sort data= &out._bayes out= _junk_(keep= &by inputorder ) nodupkey;
			  by &by descending inputorder;
			run;
			data _junk_;
			  set _junk_;
			  _thekey =1;
			run;
			proc sort data= _junk_ out= _junk_ nodupkey;
			  by _thekey &by ;
			run;
			data _junk_;
			  set _junk_;
			  inputorder = inputorder + 0.01;
			run;
			proc sort data=&comparedata;
			  by _thekey &by inputorder;
			run;
			data &comparedata;
			  merge &comparedata(drop=inputorder) _junk_;
			  by _thekey &by;
			  drop _thekey;
			run;
			proc sort data=&comparedata out=&comparedata;
			  by _disparity %if &by ^=%str() %then &by ;;
			run;
			data &comparedata;
			  set &comparedata;
			  by _disparity %if &by ^=%str() %then &by ;;
			  _mid + 1;
			  if first._disparity then _mid = 1;
			  %if &by ^=%str() %then if first.&by then _mid = 1; ;;
			  if _mid=1 then firstp=1;
			run;
		%end;

		/* eMKF: more local cleanup */
		proc datasets nolist;
		  delete _junk_ _junkN_ _outbs1 _outbs2 _outbs3;
		run ;
		quit; 

		/* eMKF v2.4: revised to delete the applicable FCMP functions for trend break scenarios */
		%let uloc = &cmploc..uds;
		proc fcmp outlib=&uloc; 
			deletesubr rtnorm;
			deletesubr EP;
			%if %upcase(&randomVars) = YES %then deletesubr RP;; 
			%if &breakPoint = %str() %then %do;
				%if &flag1f = 1 %then deletesubr MP_bfc;;
				%if &flag2f = 1 %then deletesubr MP_bfq;;
				%if &flag3f = 1 %then deletesubr MP_bfl;;
			%end;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %do;
					%if &flag1f = 1 %then deletesubr MP_xptl_bfc;;
					%if &flag2f = 1 %then deletesubr MP_xptl_bfq;;
					%if &flag3f = 1 %then deletesubr MP_xptl_bfl;;
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;
					%if &flag1f = 1 and &s2flag1f = 1 %then deletesubr MP_xptf_bfc_bfc;;
					%if &flag1f = 1 and &s2flag2f = 1 %then deletesubr MP_xptf_bfc_bfq;;
					%if &flag1f = 1 and &s2flag3f = 1 %then deletesubr MP_xptf_bfc_bfl;;
					%if &flag2f = 1 and &s2flag2f = 1 %then deletesubr MP_xptf_bfq_bfq;;
					%if &flag2f = 1 and &s2flag3f = 1 %then deletesubr MP_xptf_bfq_bfl;;
					%if &flag3f = 1 and &s2flag3f = 1 %then deletesubr MP_xptf_bfl_bfl;;
				%end;
			%end;
			%if &breakPoint = %str() %then %do;
				%if &flag1a = 1 %then deletesubr CP_bmac;; 
				%if &flag2a = 1 %then deletesubr CP_bmaq;; 
				%if &flag3a = 1 %then deletesubr CP_bmal;; 
				%if &flag1 = 1 or &flag1f = 1 %then deletesubr CP_bgc;; 
				%if &flag2 = 1 or &flag2f = 1 %then deletesubr CP_bgq;; 
				%if &flag3 = 1 or &flag3f = 1 %then deletesubr CP_bgl;; 
				%if &flag4 = 1 %then deletesubr CP_b1c;; 
				%if &flag5 = 1 %then deletesubr CP_b1q;; 
				%if &flag6 = 1 %then deletesubr CP_b1l;; 
				%if &flag7 = 1 %then deletesubr CP_b0;; 
			%end;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %do;
					%if &flag1a = 1 %then deletesubr CP_xptl_bmac;; 
					%if &flag2a = 1 %then deletesubr CP_xptl_bmaq;; 
					%if &flag3a = 1 %then deletesubr CP_xptl_bmal;; 
					%if &flag1 = 1 or &flag1f = 1 %then deletesubr CP_xptl_bgc;; 
					%if &flag2 = 1 or &flag2f = 1 %then deletesubr CP_xptl_bgq;; 
					%if &flag3 = 1 or &flag3f = 1 %then deletesubr CP_xptl_bgl;; 
					%if &flag4 = 1 %then deletesubr CP_xptl_b1c;; 
					%if &flag5 = 1 %then deletesubr CP_xptl_b1q;; 
					%if &flag6 = 1 %then deletesubr CP_xptl_b1l;; 
					%if &flag7 = 1 %then deletesubr CP_xptl_b0;; 
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;
					%if &flag1a = 1 and &s2flag1a = 1 %then deletesubr CP_xptf_bmac_bmac;; 
					%if &flag1a = 1 and &s2flag2a = 1 %then deletesubr CP_xptf_bmac_bmaq;; 
					%if &flag1a = 1 and &s2flag3a = 1 %then deletesubr CP_xptf_bmac_bmal;; 
					%if &flag2a = 1 and &s2flag2a = 1 %then deletesubr CP_xptf_bmaq_bmaq;; 
					%if &flag2a = 1 and &s2flag3a = 1 %then deletesubr CP_xptf_bmaq_bmal;; 
					%if &flag3a = 1 and &s2flag3a = 1 %then deletesubr CP_xptf_bmal_bmal;; 
					%if (&flag1=1 or &flag1f=1) and (&s2flag1=1 or &s2flag1f=1) %then deletesubr CP_xptf_bgc_bgc;; 
					%if (&flag1=1 or &flag1f=1) and (&s2flag2=1 or &s2flag2f=1) %then deletesubr CP_xptf_bgc_bgq;; 
					%if (&flag1=1 or &flag1f=1) and (&s2flag3=1 or &s2flag3f=1) %then deletesubr CP_xptf_bgc_bgl;; 
					%if (&flag2=1 or &flag2f=1) and (&s2flag2=1 or &s2flag2f=1) %then deletesubr CP_xptf_bgq_bgq;; 
					%if (&flag2=1 or &flag2f=1) and (&s2flag3=1 or &s2flag3f=1) %then deletesubr CP_xptf_bgq_bgl;; 
					%if (&flag3=1 or &flag3f=1) and (&s2flag3=1 or &s2flag3f=1) %then deletesubr CP_xptf_bgl_bgl;; 
					%if &flag4 = 1 and &s2flag4 = 1	%then deletesubr CP_xptf_b1c_b1c;; 
					%if &flag4 = 1 and &s2flag5 = 1	%then deletesubr CP_xptf_b1c_b1q;; 
					%if &flag4 = 1 and &s2flag6 = 1	%then deletesubr CP_xptf_b1c_b1l;; 
					%if &flag5 = 1 and &s2flag5 = 1	%then deletesubr CP_xptf_b1q_b1q;; 
					%if &flag5 = 1 and &s2flag6 = 1	%then deletesubr CP_xptf_b1q_b1l;; 
					%if &flag6 = 1 and &s2flag6 = 1	%then deletesubr CP_xptf_b1l_b1l;; 
					%if &flag7 = 1 and &s2flag7 = 1	%then deletesubr CP_xptf_b0_b0;; 
				%end;
			%end;
			%if &breakPoint = %str() %then %do;
				%if &flag1a = 1 %then deletesubr FP_bmac;; 
				%if &flag2a = 1 %then deletesubr FP_bmaq;; 
				%if &flag3a = 1 %then deletesubr FP_bmal;; 
			%end;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %do;
					%if &flag1a = 1 %then deletesubr FP_xptl_bmac;; 
					%if &flag2a = 1 %then deletesubr FP_xptl_bmaq;; 
					%if &flag3a = 1 %then deletesubr FP_xptl_bmal;; 
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;
					%if &flag1a = 1 and &s2flag1a = 1 %then deletesubr FP_xptf_bmac_bmac;; 
					%if &flag1a = 1 and &s2flag2a = 1 %then deletesubr FP_xptf_bmac_bmaq;; 
					%if &flag1a = 1 and &s2flag3a = 1 %then deletesubr FP_xptf_bmac_bmal;; 
					%if &flag2a = 1 and &s2flag2a = 1 %then deletesubr FP_xptf_bmaq_bmaq;; 
					%if &flag2a = 1 and &s2flag3a = 1 %then deletesubr FP_xptf_bmaq_bmal;; 
					%if &flag3a = 1 and &s2flag3a = 1 %then deletesubr FP_xptf_bmal_bmal;; 
				%end;
			%end;
		run;
		quit;	
		options cmplib = _null_;

	%end; /* End of the Bayesian model(s) fitting*/

    /************************************************************************************************/
	/* Finalizing the results into a single dataset (eMKF: modified to account for added variables) */
    /************************************************************************************************/

	%if &slopes =%str() and %upcase(&Bayesian)=YES %then %do;
		data &out._pred;
		  set &out._bayes;
	  	  %if &comparedata ^=%str() %then if _group_ ^= . and _diffgrp2_ = . ;; /* eMKF v2.4 correction: use &comparedata instead of &comparedto */
		run;
	%end;

	%if &slopes ^=%str() and %upcase(&Bayesian)=YES %then %do;
		proc sort data=&out._pred;
		  by _rep &group _time;
		run;
		proc sort data=&out._bayes;
		  by _rep &group _time;
		run;
		data &out._pred;
		  merge &out._pred 
				%if &comparedto =%str() %then &out._bayes;
				%if &comparedto ^=%str() %then &out._bayes(where=(_group_ ^= . and _diffgrp2_ = . ));
			;
		  by _rep &group _time;
		run;
		proc sort data=&out._pred;
		  by &by &group _time;
		run;
	%end;

	data &out._pred;
	  merge &out._pred(keep = &by &group &time &outcome &se &neff &outcome2 &se2 &neff2)
			&out._pred(keep= _rep)
		    &out._pred(keep= _group_ _time _rtime %if &breakPoint ^= %str() %then _s1rtime _s2rtime; ) 
	        &out._pred(keep= _y _se %if &outcome2 ^=%str() and &se2 ^=%str() %then _y2 _se2; ) 
	        &out._pred(keep= _avgse 
                             %if &by ^=%str() %then _avgseb; 
                             %if &outcome2 ^=%str() and &se2 ^=%str() %then _avgse2; 
                             %if &outcome2 ^=%str() and &se2 ^=%str() and &by ^=%str() %then _avgse2b; )
			%if %upcase(&randomVars) = YES and %upcase(&Bayesian)=YES %then %do;
				&out._pred(keep= _n _avgn 
                                 %if &by ^=%str() %then _avgnb;
                                 %if &outcome2 ^=%str() and &se2 ^=%str() %then _n2 _avgn2;
                                 %if &outcome2 ^=%str() and &se2 ^=%str() and &by ^=%str() %then _avgn2b; )
			%end;
	        &out._pred(keep= impute inputorder %if &by ^=%str() %then imputeb;)
			&out._pred(keep= pred:) 
			/* eMKF v2.4 streamlining: matched only first 5 characters in &toprint2 string */
			%if &toprint2 ^= %str() %then %if %upcase(%substr(&toprint2,1,5)) = MODEL %then &out._pred(keep= p1: p2: p3: p4: p5: p6: p7: );;
		;
	run;

	/* eMKF: added functionality to remind the user about the predictions dataset if not tabulated */
	%if %upcase(&finalprint) ^= YES %then %do;
	    %put ;
		%put Tabulated printout of MKF predictions for the last time point was turned off by the user.;
		%put Model predictions are in dataset &out._pred.;
		proc iml;
		    print " Note: The tabulated printout of MKF predictions for the last time point was turned off by the user";
			print "  	  Model predictions can always be found in dataset &out._pred";
		quit;
	%end;
	%else %do;

		data _junk_;
		run;

		%if %upcase(&Bayesian)= YES %then %do;
			%if &comparedata ^=%str() %then %do; /* eMKF v2.4 correction: use &comparedata instead of &comparedto */
				proc sort data=&out._bayes(where=(_group_ ^= . and _diffgrp2_ = . )) out= _junk_;
			  		by &by _time;
				run;
			%end;
			%else %do;
				proc sort data=&out._bayes out= _junk_;
			  		by &by _time;
				run;
			%end;
		%end;
		%else %do;
			proc sort data=&out._pred out= _junk_;
			  by &by _time;
			run;
		%end;

		proc sort data=_finalprint_;
		  by &by _time;
		run;

		data _junk_;
		  merge _junk_(in=b) _finalprint_(in=a);
		  by &by _time;
		  if a and b;
		run;

		data _junk_;
		  merge _junk_(drop=pred:) _junk_(keep=pred:) ;
		run;

		proc sort data=_junk_;
		  by &by &group _time;
		run;

		data _junk_;
		  set _junk_;
		  %if %upcase(&Bayesian)  = YES %then final_pred=pred_Bayes_&toprint ;;
		  %if %upcase(&Bayesian)  = YES %then final_se=predSE_Bayes_&toprint ;;
		  %if %upcase(&Bayesian) ^= YES %then final_pred=pred_&toprint2 ;;
		  %if %upcase(&Bayesian) ^= YES %then final_se=predSE_&toprint2 ;;
		  %if &outcome2 ^= %str() and &se2 ^= %str() %then final_pred2=pred2_&toprint2 ;;
		  %if &outcome2 ^= %str() and &se2 ^= %str() %then final_se2=pred2SE_&toprint2 ;;  
		  keep &by &group _group_ _time &time _y _se final_pred final_se inputorder impute 
               %if &by ^= %str() %then imputeb;
		       %if &outcome2 ^= %str() and &se2 ^= %str() %then final_pred2 final_se2  _y2 _se2 ;
		  ;
		run;

		/* eMKF v2.4: Revised to account for added trend break options */
		%let _thet=;
		%if %upcase(&Bayesian)  = YES  %then %do;
		  %if &breakPoint = %str() %then %do;
			%if %upcase(&toprint)=BMA_CUBIC 	%then %let _thet= Bayesian model average up to unconstrained cubic trend%str(,) ;
			%if %upcase(&toprint)=BMA_QUAD 		%then %let _thet= Bayesian model average up to unconstrained quadratic trend%str(,) ;
			%if %upcase(&toprint)=BMA_LINEAR 	%then %let _thet= Bayesian model average up to unconstrained linear trend%str(,) ;
			%if %upcase(&toprint)=FULL_CUBIC 	%then %let _thet= Fully Bayesian cubic trends%str(,) ;
			%if %upcase(&toprint)=FULL_QUAD 	%then %let _thet= Fully Bayesian quadratic trends%str(,) ;
			%if %upcase(&toprint)=FULL_LINEAR 	%then %let _thet= Fully Bayesian linear trends%str(,) ;
			%if %upcase(&toprint)=INDEP_CUBIC 	%then %let _thet= Independent Bayesian cubic trends%str(,) ;
			%if %upcase(&toprint)=INDEP_QUAD 	%then %let _thet= Independent Bayesian quadratic trends%str(,) ;
			%if %upcase(&toprint)=INDEP_LINEAR 	%then %let _thet= Independent Bayesian linear trends%str(,) ;
			%if %upcase(&toprint)=COMMON_CUBIC 	%then %let _thet= Common Bayesian cubic trend%str(,) ;
			%if %upcase(&toprint)=COMMON_QUAD 	%then %let _thet= Common Bayesian quadratic trend%str(,) ;
			%if %upcase(&toprint)=COMMON_LINEAR %then %let _thet= Common Bayesian linear trend%str(,) ;
			%if %upcase(&toprint)=DROPPED 		%then %let _thet= Bayesian intercepts-only model%str(,) ;
		  %end;
		  %else %do;
			 %if %upcase(&breakType) = LEVEL_BREAK %then %do;
				%if %upcase(&toprint)=BMA_CUBIC_XLV 	%then %let _thet= Bayesian model average up to unconstrained cubic trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_QUAD_XLV 		%then %let _thet= Bayesian model average up to unconstrained quadratic trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_LINEAR_XLV 	%then %let _thet= Bayesian model average up to unconstrained linear trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=FULL_CUBIC_XLV 	%then %let _thet= Fully Bayesian cubic trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=FULL_QUAD_XLV 	%then %let _thet= Fully Bayesian quadratic trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=FULL_LINEAR_XLV 	%then %let _thet= Fully Bayesian linear trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=INDEP_CUBIC_XLV 	%then %let _thet= Independent Bayesian cubic trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=INDEP_QUAD_XLV 	%then %let _thet= Independent Bayesian quadratic trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=INDEP_LINEAR_XLV 	%then %let _thet= Independent Bayesian linear trends%str(,) with level shifts in &breakPoint%str(,) ;
				%if %upcase(&toprint)=COMMON_CUBIC_XLV 	%then %let _thet= Common Bayesian cubic trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=COMMON_QUAD_XLV 	%then %let _thet= Common Bayesian quadratic trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=COMMON_LINEAR_XLV %then %let _thet= Common Bayesian linear trend%str(,) with level shift(s) in &breakPoint%str(,) ;
				%if %upcase(&toprint)=DROPPED_XLV 		%then %let _thet= Bayesian intercepts-only model%str(,) with level shift(s) in &breakPoint%str(,) ;
			 %end;
			 %if %upcase(&breakType) = FULL_BREAK %then %do;
				%if %upcase(&toprint)=BMA_CUBIC_CUB 	%then %let _thet= Bayesian model average up to unconstrained cubic trend before and after &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_CUBIC_QUA 	%then %let _thet= Bayesian model average up to unconstrained cubic trend before, and quadratic trend after, &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_CUBIC_LIN 	%then %let _thet= Bayesian model average up to unconstrained cubic trend before, and linear trend after, &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_QUAD_QUA 		%then %let _thet= Bayesian model average up to unconstrained quadratic trend before and after &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_QUAD_LIN 		%then %let _thet= Bayesian model average up to unconstrained quadratic trend before, and linear trend after, &breakPoint%str(,) ;
				%if %upcase(&toprint)=BMA_LINEAR_LIN 	%then %let _thet= Bayesian model average up to unconstrained linear trend before and after &breakPoint%str(,) ;
				%if %upcase(&toprint)=FULL_CUBIC_CUB    %then %let _thet= Fully Bayesian cubic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=FULL_CUBIC_QUA    %then %let _thet= Fully Bayesian cubic trends before, and quadratic trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=FULL_CUBIC_LIN    %then %let _thet= Fully Bayesian cubic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=FULL_QUAD_QUA 	%then %let _thet= Fully Bayesian quadratic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=FULL_QUAD_LIN 	%then %let _thet= Fully Bayesian quadratic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=FULL_LINEAR_LIN   %then %let _thet= Fully Bayesian linear trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_CUBIC_CUB   %then %let _thet= Independent Bayesian cubic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_CUBIC_QUA   %then %let _thet= Independent Bayesian cubic trends before, and quadratic trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_CUBIC_LIN   %then %let _thet= Independent Bayesian cubic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_QUAD_QUA 	%then %let _thet= Independent Bayesian quadratic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_QUAD_LIN 	%then %let _thet= Independent Bayesian quadratic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint)=INDEP_LINEAR_LIN  %then %let _thet= Independent Bayesian linear trends before and after &breakPoint%str(,);
				%if %upcase(&toprint)=COMMON_CUBIC_CUB  %then %let _thet= Common Bayesian cubic trend before and after &breakPoint%str(,);
				%if %upcase(&toprint)=COMMON_CUBIC_QUA  %then %let _thet= Common Bayesian cubic trend before, and quadratic trend after, &breakPoint%str(,);
				%if %upcase(&toprint)=COMMON_CUBIC_LIN  %then %let _thet= Common Bayesian cubic trend before, and linear trend after, &breakPoint%str(,);
				%if %upcase(&toprint)=COMMON_QUAD_QUA   %then %let _thet= Common Bayesian quadratic trend before and after &breakPoint%str(,);
				%if %upcase(&toprint)=COMMON_QUAD_LIN   %then %let _thet= Common Bayesian quadratic trend before, and linear trend after, &breakPoint%str(,);
	        	%if %upcase(&toprint)=COMMON_LINEAR_LIN %then %let _thet= Common Bayesian linear trend before and after &breakPoint%str(,);
				%if %upcase(&toprint)=DROPPED_DROPPED 	%then %let _thet= Bayesian intercepts-only model before and after &breakPoint%str(,);
			 %end;
		  %end;
		%end;
		%if %upcase(&Bayesian)  ^= YES %then %do;
		  %if &breakPoint = %str() %then %do;
			%if %upcase(&toprint2)=MODELAVG 	 %then %let _thet= Maximum likelihood-based average of selected trend models%str(,) ;
			%if %upcase(&toprint2)=INDEP_CUBIC 	 %then %let _thet= Independent maximum likelihood-based cubic trends%str(,) ;
			%if %upcase(&toprint2)=INDEP_QUAD 	 %then %let _thet= Independent maximum likelihood-based quadratic trends%str(,) ;
			%if %upcase(&toprint2)=INDEP_LINEAR  %then %let _thet= Independent maximum likelihood-based linear trends%str(,) ;
			%if %upcase(&toprint2)=COMMON_CUBIC  %then %let _thet= Common maximum likelihood-based cubic trend%str(,) ;
			%if %upcase(&toprint2)=COMMON_QUAD 	 %then %let _thet= Common maximum likelihood-based quadratic trend%str(,) ;
        	%if %upcase(&toprint2)=COMMON_LINEAR %then %let _thet= Common maximum likelihood-based linear trend%str(,) ;
			%if %upcase(&toprint2)=DROPPED 		 %then %let _thet= Maximum likelihood-based intercepts-only model%str(,) ;
		  %end;
		  %else %do;
			 %if %upcase(&breakType) = LEVEL_BREAK %then %do;
				%if %upcase(&toprint2)=MODELAVG_XLEVEL 	 %then %let _thet= Maximum likelihood-based average of selected trend models%str(,) with level shifts in &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_CUBIC_XLV   %then %let _thet= Independent maximum likelihood-based cubic trends%str(,) with level shifts in &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_QUAD_XLV 	 %then %let _thet= Independent maximum likelihood-based quadratic trends%str(,) with level shifts in &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_LINEAR_XLV  %then %let _thet= Independent maximum likelihood-based linear trends%str(,) with level shifts in &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_CUBIC_XLV  %then %let _thet= Common maximum likelihood-based cubic trend%str(,) with level shift(s) in &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_QUAD_XLV   %then %let _thet= Common maximum likelihood-based quadratic trend%str(,) with level shift(s) in &breakPoint%str(,);
	        	%if %upcase(&toprint2)=COMMON_LINEAR_XLV %then %let _thet= Common maximum likelihood-based linear trend%str(,) with level shift(s) in &breakPoint%str(,);
				%if %upcase(&toprint2)=DROPPED_XLV 	  	 %then %let _thet= Maximum likelihood-based intercepts-only model%str(,) with level shift(s) in &breakPoint%str(,);
			 %end;
			 %if %upcase(&breakType) = FULL_BREAK %then %do;
				%if %upcase(&toprint2)=MODELAVG_XFULL 	 %then %let _thet= Maximum likelihood-based average of selected trend models%str(,) with trend breaks in &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_CUBIC_CUB   %then %let _thet= Independent maximum likelihood-based cubic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_CUBIC_QUA   %then %let _thet= Independent maximum likelihood-based cubic trends before, and quadratic trends after, &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_CUBIC_LIN   %then %let _thet= Independent maximum likelihood-based cubic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_QUAD_QUA 	 %then %let _thet= Independent maximum likelihood-based quadratic trends before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_QUAD_LIN 	 %then %let _thet= Independent maximum likelihood-based quadratic trends before, and linear trends after, &breakPoint%str(,);
				%if %upcase(&toprint2)=INDEP_LINEAR_LIN  %then %let _thet= Independent maximum likelihood-based linear trends before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_CUBIC_CUB  %then %let _thet= Common maximum likelihood-based cubic trend before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_CUBIC_QUA  %then %let _thet= Common maximum likelihood-based cubic trend before, and quadratic trend after, &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_CUBIC_LIN  %then %let _thet= Common maximum likelihood-based cubic trend before, and linear trend after, &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_QUAD_QUA   %then %let _thet= Common maximum likelihood-based quadratic trend before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=COMMON_QUAD_LIN   %then %let _thet= Common maximum likelihood-based quadratic trend before, and linear trend after, &breakPoint%str(,);
	        	%if %upcase(&toprint2)=COMMON_LINEAR_LIN %then %let _thet= Common maximum likelihood-based linear trend before and after &breakPoint%str(,);
				%if %upcase(&toprint2)=DROPPED_DROPPED 	 %then %let _thet= Maximum likelihood-based intercepts-only model before and after &breakPoint%str(,);
			 %end;
		  %end;
		%end;
		/* eMKF v2.4: edited titles to account for additional ARmodel option */
		%if %upcase(&ARmodel) = COMMON_AR  %then %let _thet = &_thet with common autoregressive parameters%str(,) ;
		%if %upcase(&ARmodel) = INDEP_AR   %then %let _thet = &_thet with independent autoregressive parameters%str(,) ;
		%if %upcase(&ARmodel) = COMMON_ARH %then %let _thet = &_thet with common autocorrelation parameter%str(,) ;

		data _junk_;
		  set _junk_;
		  stddiff= (final_pred - _y)/_se;
		  _rse=_se/_y;
		  bayes_rse = final_pred / final_se;
		  ratio_se= final_se /_se;
		  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
			  stddiff2= (final_pred2 - _y2)/_se2;
			 _rse2=_se2/_y2;
			 bayes_rse2 = final_pred2 / final_se2;
			 ratio_se2= final_se2 /_se2;
		  %end;
		run;

		%if &outcome2 =%str() or &se2 =%str() %then %do;
			data _junk_;
			  set _junk_;
			  array Apred(1:2) _y final_pred;
			  array Ase(1:2) _se final_se;
			  array Arse(1:2) _rse bayes_rse;
			  do _i_ = 1 to 2;
			  	prediction = Apred[_i_];
			   	predse = Ase[_i_];
			   	predrse = Arse[_i_];
			   	if _i_=2 then pred_stddiff = stddiff;
			   	if _i_=2 then pred_ratiose = ratio_se;
			   	output;
			  end;
			  drop _y  _se final_pred final_se stddiff ratio_se _rse bayes_rse;
			run;
		%end;
		%else %do;
			data _junk_;
			  set _junk_;
			  array Apred(1:4) _y final_pred _y2 final_pred2;
			  array Ase(1:4) _se final_se _se2  final_se2;
			  array Arse(1:4) _rse bayes_rse _rse2 bayes_rse2;
			  do _i_ = 1 to 4;
			   	prediction = Apred[_i_];
			   	predse = Ase[_i_];
			   	predrse = Arse[_i_];
			   	if _i_=2 then pred_stddiff = stddiff;
			   	if _i_=2 then pred_ratiose = ratio_se;
			   	if _i_=3 then pred_stddiff = .;
			   	if _i_=3 then pred_ratiose = .;
			   	if _i_=4 then pred_stddiff = stddiff2;
			   	if _i_=4 then pred_ratiose = ratio_se2;
			   	output;
			  end;
			  drop _y  _se final_pred final_se stddiff ratio_se _rse bayes_rse;
			run;
		%end;

		%if &comparedto ^=%str() and %upcase(&Bayesian) = YES %then %do;

			data _junnk_;
			run;

			%if &breakPoint = %str() %then %do;
				data _junnk_;
				  set &comparedata;
				  %if %upcase(&toprint)=BMA_CUBIC     %then rename pred_bmac= prediction rmse_bmac =predse ;;
				  %if %upcase(&toprint)=BMA_QUAD      %then rename pred_bmaq= prediction rmse_bmaq =predse ;;
				  %if %upcase(&toprint)=BMA_LINEAR    %then rename pred_bmal= prediction rmse_bmal =predse ;;
				  %if %upcase(&toprint)=FULL_CUBIC 	  %then rename pred_bfc= prediction rmse_bfc =predse ;;
				  %if %upcase(&toprint)=FULL_QUAD 	  %then rename pred_bfq= prediction rmse_bfq =predse ;;
				  %if %upcase(&toprint)=FULL_LINEAR   %then rename pred_bfl= prediction rmse_bfl =predse ;;
				  %if %upcase(&toprint)=INDEP_CUBIC   %then rename pred_bgc= prediction rmse_bgc =predse ;;
				  %if %upcase(&toprint)=INDEP_QUAD    %then rename pred_bgq= prediction rmse_bgq =predse ;;
				  %if %upcase(&toprint)=INDEP_LINEAR  %then rename pred_bgl= prediction rmse_bgl =predse ;;
				  %if %upcase(&toprint)=COMMON_CUBIC  %then rename pred_b1c= prediction rmse_b1c =predse ;;
				  %if %upcase(&toprint)=COMMON_QUAD   %then rename pred_b1q= prediction rmse_b1q =predse ;;
				  %if %upcase(&toprint)=COMMON_LINEAR %then rename pred_b1l= prediction rmse_b1l =predse ;;
				  %if %upcase(&toprint)=DROPPED 	  %then rename pred_b0= prediction rmse_b0 =predse ;;
				run;
			%end;
			%else %do;
				%if %upcase(&breakType) = LEVEL_BREAK %then %do;
					data _junnk_;
					  set &comparedata;
					  %if %upcase(&toprint)=BMA_CUBIC_XLV     %then rename pred_bmac_xlv= prediction rmse_bmac_xlv =predse ;;
					  %if %upcase(&toprint)=BMA_QUAD_XLV      %then rename pred_bmaq_xlv= prediction rmse_bmaq_xlv =predse ;;
					  %if %upcase(&toprint)=BMA_LINEAR_XLV    %then rename pred_bmal_xlv= prediction rmse_bmal_xlv =predse ;;
					  %if %upcase(&toprint)=FULL_CUBIC_XLV 	  %then rename pred_bfc_xlv= prediction rmse_bfc_xlv =predse ;;
					  %if %upcase(&toprint)=FULL_QUAD_XLV 	  %then rename pred_bfq_xlv= prediction rmse_bfq_xlv =predse ;;
					  %if %upcase(&toprint)=FULL_LINEAR_XLV   %then rename pred_bfl_xlv= prediction rmse_bfl_xlv =predse ;;
					  %if %upcase(&toprint)=INDEP_CUBIC_XLV   %then rename pred_bgc_xlv= prediction rmse_bgc_xlv =predse ;;
					  %if %upcase(&toprint)=INDEP_QUAD_XLV    %then rename pred_bgq_xlv= prediction rmse_bgq_xlv =predse ;;
					  %if %upcase(&toprint)=INDEP_LINEAR_XLV  %then rename pred_bgl_xlv= prediction rmse_bgl_xlv =predse ;;
					  %if %upcase(&toprint)=COMMON_CUBIC_XLV  %then rename pred_b1c_xlv= prediction rmse_b1c_xlv =predse ;;
					  %if %upcase(&toprint)=COMMON_QUAD_XLV   %then rename pred_b1q_xlv= prediction rmse_b1q_xlv =predse ;;
					  %if %upcase(&toprint)=COMMON_LINEAR_XLV %then rename pred_b1l_xlv= prediction rmse_b1l_xlv =predse ;;
					  %if %upcase(&toprint)=DROPPED_XLV 	  %then rename pred_b0_xlv= prediction rmse_b0_xlv =predse ;;
					run;
				%end;
				%if %upcase(&breakType) = FULL_BREAK %then %do;
					data _junnk_;
					  set &comparedata;
					  %if %upcase(&toprint)=BMA_CUBIC_CUB     %then rename pred_bmac_bmac= prediction rmse_bmac_bmac =predse ;;
					  %if %upcase(&toprint)=BMA_CUBIC_QUA     %then rename pred_bmac_bmaq= prediction rmse_bmac_bmaq =predse ;;
					  %if %upcase(&toprint)=BMA_CUBIC_LIN     %then rename pred_bmac_bmal= prediction rmse_bmac_bmal =predse ;;
					  %if %upcase(&toprint)=BMA_QUAD_QUA      %then rename pred_bmaq_bmaq= prediction rmse_bmaq_bmaq =predse ;;
					  %if %upcase(&toprint)=BMA_QUAD_LIN      %then rename pred_bmaq_bmal= prediction rmse_bmaq_bmal =predse ;;
					  %if %upcase(&toprint)=BMA_LINEAR_LIN    %then rename pred_bmal_bmal= prediction rmse_bmal_bmal =predse ;;
					  %if %upcase(&toprint)=FULL_CUBIC_CUB 	  %then rename pred_bfc_bfc= prediction rmse_bfc_bfc =predse ;;
					  %if %upcase(&toprint)=FULL_CUBIC_QUA 	  %then rename pred_bfc_bfq= prediction rmse_bfc_bfq =predse ;;
					  %if %upcase(&toprint)=FULL_CUBIC_LIN 	  %then rename pred_bfc_bfl= prediction rmse_bfc_bfl =predse ;;
					  %if %upcase(&toprint)=FULL_QUAD_QUA 	  %then rename pred_bfq_bfq= prediction rmse_bfq_bfq =predse ;;
					  %if %upcase(&toprint)=FULL_QUAD_LIN 	  %then rename pred_bfq_bfl= prediction rmse_bfq_bfl =predse ;;
					  %if %upcase(&toprint)=FULL_LINEAR_LIN   %then rename pred_bfl_bfl= prediction rmse_bfl_bfl =predse ;;
					  %if %upcase(&toprint)=INDEP_CUBIC_CUB   %then rename pred_bgc_bgc= prediction rmse_bgc_bgc =predse ;;
					  %if %upcase(&toprint)=INDEP_CUBIC_QUA   %then rename pred_bgc_bgq= prediction rmse_bgc_bgq =predse ;;
					  %if %upcase(&toprint)=INDEP_CUBIC_LIN   %then rename pred_bgc_bgl= prediction rmse_bgc_bgl =predse ;;
					  %if %upcase(&toprint)=INDEP_QUAD_QUA    %then rename pred_bgq_bgq= prediction rmse_bgq_bgq =predse ;;
					  %if %upcase(&toprint)=INDEP_QUAD_LIN    %then rename pred_bgq_bgl= prediction rmse_bgq_bgl =predse ;;
					  %if %upcase(&toprint)=INDEP_LINEAR_LIN  %then rename pred_bgl_bgl= prediction rmse_bgl_bgl =predse ;;
					  %if %upcase(&toprint)=COMMON_CUBIC_CUB  %then rename pred_b1c_b1c= prediction rmse_b1c_b1c =predse ;;
					  %if %upcase(&toprint)=COMMON_CUBIC_QUA  %then rename pred_b1c_b1q= prediction rmse_b1c_b1q =predse ;;
					  %if %upcase(&toprint)=COMMON_CUBIC_LIN  %then rename pred_b1c_b1l= prediction rmse_b1c_b1l =predse ;;
					  %if %upcase(&toprint)=COMMON_QUAD_QUA   %then rename pred_b1q_b1q= prediction rmse_b1q_b1q =predse ;;
					  %if %upcase(&toprint)=COMMON_QUAD_LIN   %then rename pred_b1q_b1l= prediction rmse_b1q_b1l =predse ;;
					  %if %upcase(&toprint)=COMMON_LINEAR_LIN %then rename pred_b1l_b1l= prediction rmse_b1l_b1l =predse ;;
					  %if %upcase(&toprint)=DROPPED_DROPPED   %then rename pred_b0_b0= prediction rmse_b0_b0 =predse ;;
					run;
				%end;
			%end;

			data _junnk_;
			  set _junnk_;
			  _i_=5;
			  if _disparity = "difference" then _groupdiff_ = compress(&group._1)||" - "|| &group._2;
			  if _disparity = "ratio" then _groupratio_ = compress(&group._1)||" / "|| &group._2;
			  keep &by &time &group &group._1 &group._2 prediction predse _i_ _groupdiff_ _groupratio_ _disparity inputorder;
			run;

			data _junk_;
			  set _junk_ _junnk_ ;
			run;

			/* eMKF: clean up */		
			proc datasets nolist;
			  delete _junnk_ ;
			run ;
			quit;

		%end;

		data _junk_;
		  set _junk_;

		  /* eMKF: CIs formatted to account for extra space for the minus sign */
		  %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do;
			  if _disparity = "difference" or _disparity = "" then do;
				  if prediction -(1.96*predse) ge 0 and prediction +(1.96*predse) ge 0 
					then pred_ci = "[ "||compress(put(prediction -(1.96*predse), 16.&pdigit))||",  "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
				  if prediction -(1.96*predse)  < 0 and prediction +(1.96*predse) ge 0 
					then pred_ci = "["||compress(put(prediction -(1.96*predse), 16.&pdigit))||",  "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
				  if prediction -(1.96*predse) ge 0 and prediction +(1.96*predse)  < 0 
					then pred_ci = "[ "||compress(put(prediction -(1.96*predse), 16.&pdigit))||", "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
				  if prediction -(1.96*predse)  < 0 and prediction +(1.96*predse)  < 0 
					then pred_ci = "["||compress(put(prediction -(1.96*predse), 16.&pdigit))||", "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
			  end;
			  if _disparity = "ratio" and prediction > 0 then do; /* eMKF: Added for printing ratios and their lognormal CIs */
				  pred_ci = "[ "||compress(put(exp(log(prediction) -(1.96*predse/prediction)), 16.&pdigit))||",  "|| compress(put(exp(log(prediction) +(1.96*predse/prediction)), 16.&pdigit))||"]";
			  end;
		  %end;
		  %else %do;
			  if prediction -(1.96*predse) ge 0 and prediction +(1.96*predse) ge 0 
				then pred_ci = "[ "||compress(put(prediction -(1.96*predse), 16.&pdigit))||",  "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
			  if prediction -(1.96*predse)  < 0 and prediction +(1.96*predse) ge 0 
				then pred_ci = "["||compress(put(prediction -(1.96*predse), 16.&pdigit))||",  "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
			  if prediction -(1.96*predse) ge 0 and prediction +(1.96*predse)  < 0 
				then pred_ci = "[ "||compress(put(prediction -(1.96*predse), 16.&pdigit))||", "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
			  if prediction -(1.96*predse)  < 0 and prediction +(1.96*predse)  < 0 
				then pred_ci = "["||compress(put(prediction -(1.96*predse), 16.&pdigit))||", "|| compress(put(prediction +(1.96*predse), 16.&pdigit))||"]";
		  %end;

		  if _i_ in (1, 3) then label="Sample       ";
          if _i_ in (2, 4) then label="Model   ";  /* eMKF v2.4: changed label MKF estimate to Model */

		  if pred_stddiff ne . then stddiff= put(pred_stddiff, 16.&pdigit);
		  if pred_ratiose ne . then ratiose= put(pred_ratiose, 16.&pdigit);
		  if pred_stddiff = . then stddiff= "  ~~             ";
		  if pred_ratiose = . then ratiose=  "  ~~             ";
		  format prediction predse pred_stddiff pred_ratiose 16.&pdigit;
		run;

		data _junk_;
		  set _junk_;
		  ll1=0;
		  %if &by ^=%str() %then ll1 =length(compress(&by));;
		  ll2=length(compress(&group));
		  ll3=0;
		  ll3=length(compress(_time));
		  %if %eval(0+ %_counts_(&time)) = 1 %then ll3=length(compress(&time));;
		  ll4=length(compress(label));
		  ll5=length(compress(put(prediction, 16.&pdigit)));
		  ll6=length(compress(put(predse, 16.&pdigit)));
		  ll7=length(compress(pred_ci));
		  ll8=length(compress(stddiff));
		  ll9=length(compress(ratiose));
		run;

		data _freqg_;
		run;

		proc means data=_junk_ noprint;
		  var ll1-ll9;
		  output out=_freqg_ max=ll1-ll9;
		run;

		%local _flign; %let _flign=134; /* eMKF: increased line width from 94 */
		data _freqg_;
		  set _freqg_;
		  id+1;
		  space=5; /* eMKF: increased from 3*/
		  n1 = 4;
		  n2 = n1 + max(3, ll1)  -1 + space;
		  n3 = n2 + max(5, ll2)  -1 + space;
		  n4 = n3 + max(4, ll3)  -1 + space;
		  n5 = n4 + max(12, ll4) -1 + space;
		  n6 = n5 + max(10, ll5) -1 + space;
		  n7 = n6 + max(5, ll6)  -1 + space;
		  n8 = n7 + max(17, ll7) -1 + space;
		  n9 = n8 + max(7, ll8)  -1 + space;
		  n0 = n9 + max(10, ll9) +1 + space;
		  if id=10 then call symput("_flign", col1);
		run;
		%let _flign =%eval(0 + &_flign);

		proc transpose data=_freqg_(keep=n0-n9) out=_freqg_;
		run;

		/* Let's set up the printing*/

		data _freqg_;
		 set _freqg_;
		 id +1;
		 %if &by ^=%str() %then if id=1 then name1=compress("@"||col1)||" &by                     ";;;
		 if id=2 then name1=compress("@"||col1)||" &group                     ";
		 if id=3 then name1=compress("@"||col1)||" &time                    ";
		 if id=4 then name1=compress("@"||col1)||" label                    ";
		 if id=5 then name1=compress("@"||col1)||" prediction                     ";
		 if id=6 then name1=compress("@"||col1)||" predse                     ";
		 if id=7 then name1=compress("@"||col1)||" pred_ci                     ";
		 if id=8 then name1=compress("@"||col1)||" stddiff                     ";
		 if id=9 then name1=compress("@"||col1)||" ratiose                     ";

		 %if &by ^=%str() %then if id=1 then name1a=compress("@"||col1)||" &by                     ";;;
		 if id=2 then name1a=compress("@"||col1)||" &group                     ";
		 if id=3 then name1a=compress("@"||col1)||" &time                    ";
		 if id=4 then name1a=compress("@"||col1)||" ' &outcome Estimation:'                    "; /* eMKF v2.4: corrected leading spaces */
		 if id=4 then name1b=compress("@"||col1)||" ' &outcome2 Estimation:'                    ";
		 if id=4 then name2=compress("@"||col1)||" label                    ";
		 if id=5 then name2=compress("@"||col1)||" prediction                     ";
		 if id=6 then name2=compress("@"||col1)||" predse                     ";
		 if id=7 then name2=compress("@"||col1)||" pred_ci                     ";
		 if id=8 then name2=compress("@"||col1)||" stddiff                     ";
		 if id=9 then name2=compress("@"||col1)||" ratiose                     ";

		 %if &by ^=%str() %then if id=1 then name3=compress("@"||col1)||" '&by'                     ";;;
		 if id=2 then name3=compress("@"||col1)||" '   &group'                     ";
		 if id=3 then name3=compress("@"||col1)||" '&time'                    ";
		 if id=4 then name3=compress("@"||col1)||" 'Source'                    ";  /* eMKF v2.4: changed column label to Source instead of Estimation Type */
		 if id=5 then name3=compress("@"||col1)||" 'Estimate'                     "; /* eMKF v2.4: changed from Point estimate to just Estimate */
		 if id=6 then name3=compress("@"||col1)||" 'RMSE'                     "; /* eMKF: changed label from Std. Error to RMSE to avoid confusion */
		 if id=7 then name3=compress("@"||col1)||" '   Wald 95% CI'                     ";
		 if id=8 then name3=compress("@"||col1)||" 'Std. Diff'                     "; /* eMKF v2.4: set column label on one line */
		 if id=9 then name3=compress("@"||col1)||" 'Rel. RMSE'                     "; /* eMKF v2.4: set column label on one line */

		 *if id=4 then name4=compress("@"||col1)||" '   Type '                    ";
		 *if id=5 then name4=compress("@"||col1)||" 'Estimate'                     ";
		 *if id=8 then name4=compress("@"||col1)||" 'Diff'                     ";
		 *if id=9 then name4=compress("@"||col1)||" 'RMSE'                     ";

		 /* eMKF: added if-clause to correct uninitialized variable &group._1 warning in original MKF macro */
		 %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do; 
			 %if &by ^=%str() %then if id=1 then name5=compress("@"||col1)||" &by                     ";;
			 if id=2 then name5=compress("@"||col1)||" &group._1                  ";
			 if id=3 then name5=compress("@"||col1)||" group0                     ";
			 if id=5 then name5=compress("@"||col1 -1)||" prediction                      ";
			 if id=6 then name5=compress("@"||col1)||" predse                     ";
			 if id=7 then name5=compress("@"||col1)||" pred_ci                     ";

			 if id=2 then name6=compress("@"||col1)||" &group._1                 ";
			 if id=3 then name6=compress("@"||col1)||" group0                    ";
			 if id=5 then name6=compress("@"||col1 -1)||" prediction                     ";
			 if id=6 then name6=compress("@"||col1)||" predse                     ";
			 if id=7 then name6=compress("@"||col1)||" pred_ci                     ";

			 %if &by ^=%str() %then if id=1 then name5a=compress("@"||col1)||" &by                     ";;
			 if id=2 then name5a=compress("@"||col1)||" &group._1                 ";
			 if id=3 then name5a=compress("@"||col1)||" group0                    ";
			 if id=5 then name5a=compress("@"||col1)||" prediction                     ";
			 if id=6 then name5a=compress("@"||col1)||" predse                     ";
			 if id=7 then name5a=compress("@"||col1)||" pred_ci                     ";

			 if id=2 then name6a=compress("@"||col1)||" &group._1                 ";
			 if id=3 then name6a=compress("@"||col1)||" group0                    ";
			 if id=5 then name6a=compress("@"||col1)||" prediction                     ";
			 if id=6 then name6a=compress("@"||col1)||" predse                     ";
			 if id=7 then name6a=compress("@"||col1)||" pred_ci                     ";

			 %if &by ^=%str() %then if id=1 then name7=compress("@"||col1)||" '&by'                     ";;
			 if id=2 then name7=compress("@"||col1)||" '    Disparity Measure'                     ";
			 if id=5 then name7=compress("@"||col1)||"'Estimate'                     "; /* eMKF: Modified column label*/
			 if id=6 then name7=compress("@"||col1)||" ' RMSE '                     ";
			 if id=7 then name7=compress("@"||col1)||" '      95% CI'                     ";

		 %end;

		run;

		%local nname1 nname1a nname1b nname2 nname3 /*nname4*/ nname5 nname6 nname5a nname6a nname7 ;
		%let nname1=; %let nname1a=; %let nname1b=; %let nname2=; %let nname3=; /*%let nname4=;*/
		%let nname5=; %let nname6=; %let nname5a=; %let nname6a=; %let nname7=;

		proc sql noprint;
		   select name1  into :nname1  separated by ' '  from _freqg_ ;
		   select name1a into :nname1a separated by ' '  from _freqg_ ;
		   select name1b into :nname1b separated by ' '  from _freqg_ ;
		   select name2  into :nname2  separated by ' '  from _freqg_ ;
		   select name3  into :nname3  separated by ' '  from _freqg_ ;
		   *select name4  into :nname4  separated by ' '  from _freqg_ ;
		   /* eMKF: added if-clause to correct warnings in original MKF macro */
		   %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do;
			   select name5  into :nname5  separated by ' '  from _freqg_ ;
			   select name6  into :nname6  separated by ' '  from _freqg_ ;
			   select name5a into :nname5a separated by ' '  from _freqg_ ;
			   select name6a into :nname6a separated by ' '  from _freqg_ ;
			   select name7  into :nname7  separated by ' '  from _freqg_ ;
		  %end;
		quit;

		%if &_flign > 94 %then options linesize=&_flign ;;

		title "eMKF: &_thet"; /* eMKF v2.4 streamlining: edited title and subtitle for readability */
		%if %scan(&outcome2,1) = %str() or %scan(&se2,1) = %str() %then %do;
			%if %upcase(&randomVars) = YES  %then title2 "and random sampling variances across &group groups, for the outcome &outcome";;
			%if %upcase(&randomVars) ^= YES  %then title2 "and fixed sampling variances across &group groups, for the outcome &outcome";;
		%end;
		%else %do;
			%if %upcase(&randomVars) = YES  %then title2 "and random sampling variances across &group groups, for the outcomes &outcome and &outcome2";;
			%if %upcase(&randomVars) ^= YES  %then title2 "and fixed sampling variances across &group groups, for the outcomes &outcome and &outcome2";;
		%end;

		proc sort data=_junk_;
		  by %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then _disparity; inputorder _i_;
		run;

		%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
			data _junk000_;
			run;
			data _junk000_;
			  set _junk_;
			  if _i_ in (1,3);
			  _i_=_i_-0.5;
			  keep &by &group _time _i_ inputorder &time;
			run;
			data _junk_;
			  set _junk_ _junk000_;
			run;
			proc sort data=_junk_;
			  by inputorder &by &group _time _i_;
			run;

			/* eMKF: clean up */		
			proc datasets nolist;
			  delete _junk000_ 
			        ;
			run ;
			quit;

		%end;

		/* eMKF: This is the data step used for printing the table */
		data _null_;
		   set _junk_;
		   by %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then _disparity; inputorder; /* eMKF: added _disparity to the by list */
		   file print header=newpage;
		   label  _group_="Group ID" _time="Time " 
		         label="Estimation Type" prediction="Prediction" predse="Std. Err" 
		         pred_ci="95% CI" stddiff="Standardized Difference" ratiose="Relative RMSE" ;
		   if first.inputorder then firstp=1;
		   %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do;
		   		if _disparity = "difference" then group0="- "||compress(&group._2);
				if _disparity = "ratio" then group0="/ "||compress(&group._2); 	    /* eMKF: Added display format for ratios */
		   %end;
		   if _i_=0.5 then put &nname1a;
		   %if &outcome2  =%str() or &se2  =%str() %then if _i_=1 then put &nname1;;;
		   %if &outcome2 ^=%str() and &se2 ^=%str() %then if _i_=1 then put &nname2;;;
		   if _i_=2 then put &nname2;
		   if _i_=2.5 then put &nname1b;
		   if _i_=3 then put &nname2;
		   if _i_=4 then put &nname2;
		   %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do; /* eMKF: added this if-clause to correct warnings in original MKF macro */
			   if _i_=5 and first.inputorder and _disparity = "difference" 
				   then put "                         Differences between MKF point estimates by &group            ";
			   if _i_=5 and first.inputorder and _disparity = "ratio" 
				   then put "                         Ratios between MKF point estimates by &group             "; /* eMKF: Added for ratios */
			   if _i_=5 and first.inputorder then put "                        ";  
			   if _i_=5 and first.inputorder then put &nname7;   
			   if _i_=5 and firstp  = 1 and prediction < 0 then put &nname5;
			   if _i_=5 and firstp ne 1 and prediction < 0 then put &nname6;
			   if _i_=5 and firstp  = 1 and prediction ge 0 then put &nname5a;
			   if _i_=5 and firstp ne 1 and prediction ge 0 then put &nname6a;
		   %end;
		   if last.inputorder and impute=1 then put "   Warning:  For this group, user supplied SE=0 were set to average of nonzero values across timepoints";
		   %if &by ^=%str() %then if last.inputorder and imputeb=1 then put "   Warning:  For this group, user supplied SE=0 were set to average of nonzero values across strata";;;
		   if last.inputorder and _i_ ne 5 then put &_flign.*'-';;;;
		   %if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then if last.inputorder and _i_=5 then put &_flign.*'-';;;;
		   /* %if &by ^=%str() %then if last.&by or last._group_ then put &_flign.*'-';;; */
		   /* %if &by  =%str() %then if last._group_ then put &_flign.*'-';;; */
		   return;
		   newpage:
		      if _i_ ne 5 then do;
 			    put &nname3;
			    /*put &nname4;*/
		        put &_flign.*'#';
		        return;
			  end;
			  else do; 		/* eMKF: To do: would be nice to add by group label on page 2*/
				/*put &nname7;*/
				return;
			  end;
		run;

		title ;

		/* eMKF: clean up */		
		proc datasets nolist;
		  delete _junk_ _freqg_ _finalprint_ ;
		run ;
		quit;
	
	%end; /* eMKF: end if finalprint = YES */
	
%end; /*End of &run1 &run2 */

%if &comparedto ^=%str() and %upcase(&Bayesian)  = YES %then %do;

	data &comparedata; /* eMKF: Added ratios */
	  set &comparedata;
	  if _disparity = "difference" then _measure = compress(&group._1)|| " - " ||compress(&group._2);
	  if _disparity = "ratio" then _measure = compress(&group._1)|| " / " ||compress(&group._2); 
	  drop _group_ _rep _time inputorder _mid firstp;
	run;

	data &comparedata; /* eMKF: Kept ratios */
	  merge &comparedata(keep= _disparity _measure) &comparedata(keep= &group._1 &group._2) 
	        &comparedata(keep= &by &time) &comparedata(keep= pred_: rmse_:)
	  ;
	run;

%end;

data &out;
run;
data &out;
 set &out._pred;
 keep &_thekeep2;
run;
data &out;
 merge &_thekeep3;
run;
data &out;
 set &out;
 rename &_thekeep1;
run;
data &out;
 set &out;
 rename &_thekeeps;
run;

%if %upcase(&Bayesian)=YES %then %do;
	data &out._bayes;
	 set &out._bayes;
	 rename &_thekeep1b;
	 drop predVar_Bayes_: ;
	run;
	data &out._bayes;
	 set &out._bayes;
	 rename &_thekeepsb;
	run;
%end;

/* eMKF: clean up */		
proc datasets nolist;
  delete %if %upcase(&Bayesian) ^= YES %then _nlmixdata_; _bayesdata_ ;
run ;
quit;

/* eMFK v2.4 streamlining: added user-facing notes on progress of macro */
%put ;
%put MKF macro is done!;

/* eMFK v2.4 streamlining: reset log notes */
%if %upcase(&saslognotes) ^= YES %then options notes;;

%mend mkf;

data _null_;
run;

/* eMKF: BAYESFIT completely overhauled to use SAS PROC MCMC for the Bayesian estimations instead of precompiled C code
 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 btype              : full_cubic, full_quad, full_linear, indep_cubic, indep_quad, indep_linear, common_cubic, common_quad, common_linear, or dropped
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar (default)if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior; 
					  common_arh (new in eMKF 2.3) if AR correlation is common but variance parameters are independent.
 bslicesampler		: YES to use slice sampler instead of MH algorithm for parameters that are not included in Gibbs sampling. Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: NO for "raw" polynomials. YES (default) for pre-transforming the design matrix using SAS IML orpol function. Regression coefficients will be 
					  reverse-transformed prior to macro end. However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression.
 bmalpha , bpalpha 	: prior mean and precision for intercepts
 bmbeta1 , bpbeta1	: prior mean and precision for mean linear coefficient(s) across groups
 bmbeta2 , bpbeta2	: prior mean and precision for mean quadratic coefficient(s) across groups
 bmbeta3 , bpbeta3	: prior mean and precision for mean cubic coefficient(s) across groups
 bbeta1l , bbeta1u	: bounds for U(a,b) prior for SD of linear coefficients across groups -- only used for hyperprior(s) in full_cubic, full_quad, or full_linear
 bbeta2l , bbeta2u	: bounds for U(a,b) prior for SD of quadratic coefficients across groups -- only used for hyperprior(s) in full_cubic or full_quad
 bbeta3l , bbeta3u	: bounds for U(a,b) prior for SD of cubic coefficients across groups -- only used for hyperprior(s) in full_cubic
 bmrho , bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul , btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of the CMP library (usually set in parent macro mkf)
*/
%macro bayesfit(
             bdata	= , 
			 blog	= ,
			 btype	= full_linear, 
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time, 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of parent mkf macro 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values*/
			 bmalpha  = ,  bpalpha  = ,
			 bmbeta1  = 0, bpbeta1  = ,     /* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 bmbeta2  = 0, bpbeta2  = ,
			 bmbeta3  = 0, bpbeta3  = ,
			 bbeta1l  = 0, bbeta1u  = ,		/* eMKF: bbeta1l is constant c5 in RAND's MKF User's Guide */
			 bbeta2l  = 0, bbeta2u  = ,
			 bbeta3l  = 0, bbeta3u  = ,
             bmrho    = 0, bprho    = 1,	/* eMKF: Constants c9 and c10 in RAND's MKF User's Guide */
			 btaul    = 0.0001,	btauu  = ,  /* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape   = , bvscale   = ,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc = work.funcs
             ) / minoperator;  /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local g n p d brtm _brtimess brangeY bqrangeV bmedianV formatted dsop dscl _i _j oPPmat
       b1line b2line b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline
       parline aparline vparline mbparline sbparline udsparline tauparline2 psiparline2 sbparline2
       plinea plineb1 plineb2 plineb3 plinev plinetau plinepsi bslice
       hplinemb1 hplinesb1 hplinemb2 hplinesb2 hplinemb3 hplinesb3 hplinempsi hplinespsi
	   initlinea initlineb1 initlineb2 initlineb3 initlinevarr initlinetau initlinepsi
	   initlinemb1 initlinemb2 initlinemb3 initlinesb1 initlinesb2 initlinesb3 
       monitorline optionline udsline rcXline rcNline initmbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformat(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, randomVars = &brndvars, outformat= _bbdata_ );
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF: variable that will be used for real time in case times are irregular */
%let brtm  = _rtime;

/* eMKF v2.4 streamlining: Error check to make sure there are at least 2 timepoints */
%if &n < 2 %then %do;
	%put ERROR: bayesfit macro requires at least 2 timepoints. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p = 0;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC COMMON_CUBIC %then %let p = 4;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD COMMON_QUAD %then %let p = 3;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR COMMON_LINEAR %then %let p = 2;
%if %upcase(&btype) = DROPPED %then %let p = 1;
%let p = %eval(0+&p);

/* eMKF v2.4 streamlining: max polynomial rank d-1 to use in orpoly */
%let d = 0;
%if &n > 4 %then %let d = 4;	/* cubic allowed */
%else %do;
	%if &n > 3 %then %let d = 3;	/* quad allowed */
	%else %do;
		%if &n > 2 %then %let d = 2;	/* linear allowed */
		%else %let d = 1;						/* intercepts-only model allowed */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4 streamlining: Error check to make sure requested trend models can be fit */
%if &p > &d %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%put ERROR- &btype was requested, yet there are only enough data for a degree %eval(&d-1) polynomial.; 
  	%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF: Modified to use orthogonal cubic polynomial design matrix */

data _oXmat_ _oPmat_;
run;

/* eMKF v2.4 streamlining: accounted for max polynomial degree in case of fewer timepoints than 5 */
%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  x = { &_brtimess };								/* eMKF v2.4 correction: use &_brtimess instead of &_rtimess */
	  x = T(x);											/* eMKF: column vector with real times */
	  %if &d = 1 %then oP = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP = orpol(x, &d - 1);;			/* eMKF v2.4: orthonormal design matrix oP */
	  x0 = { %cnstss(1, &n) };
	  x0 = T(x0);
	  %if &n > 2 %then x1 = x;;
	  %if &n > 3 %then x2 = x#x1;;
	  %if &n > 4 %then x3 = x#x2;;
	  uP = x0;										
	  %if &n > 2 %then uP = uP || x1;;	
	  %if &n > 3 %then uP = uP || x2;;	
	  %if &n > 4 %then uP = uP || x3;;					/* eMKF v2.4: raw/unstandardized design matrix uP */
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
      %if &n > 2 %then oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];;
      %if &n > 3 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &n > 4 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
	  oPP = oP1;									
	  %if &n > 2 %then oPP = oPP || oP2;;
	  %if &n > 3 %then oPP = oPP || oP3;;
	  %if &n > 4 %then oPP = oPP || oP4;;				/* eMKF: right multiplication of uP with oPP produces oP */
	  y = T(do(1, &n, 1));								/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1" "&brtm.2" "&brtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1" "&brtm.2"} ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1"} ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4 streamlining: Add raw predictor variables */
	  set _bbdata_;
	  &brtm.0 = 1;
	  %if &d > 1 %then &brtm.1 = &brtm;;
	  %if &d > 2 %then &brtm.2 = &brtm**2;;
	  %if &d > 3 %then &brtm.3 = &brtm**3;;
	run;
%end;

/* eMKF: Evaluate range of the data to use in setting prior parameters, as in MKF */
%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF: c1 in RAND's MKF User's Guide */
%if &bmalpha = %str() %then %let bmalpha = %sysevalf(0.5 * &brangeY);;

/* eMKF: 1/c2 in RAND's MKF User's Guide */	
%if &bpalpha = %str() %then %let bpalpha = %sysevalf(0.000001/(&brangeY**2));; 

/* eMKF: c3 or c7 in RAND's MKF User's Guide */
%if &bmbeta1 = %str() %then %let bmbeta1 = %sysevalf(0);;

/* eMKF: 1/c4 in RAND's MKF User's Guide */ 
%if &bpbeta1  = %str() and (%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR) 
	%then %let bpbeta1  = %sysevalf(10/(&brangeY**2));;

/* eMKF: 1/c8 in RAND's MKF User's Guide */	
%if &bpbeta1  = %str() and not(%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR) 
	%then %let bpbeta1  = %sysevalf(0.000001/(&brangeY**2));;

/* eMKF: c5 in RAND's MKF User's Guide  */
%if &bbeta1l  = %str() %then %let bbeta1l = %sysevalf(0);;						

/* eMKF: c6 in RAND's MKF User's Guide  */	
%if &bbeta1u  = %str() %then %let bbeta1u = %sysevalf(0.5 * &brangeY);;		

/* eMKF v2.4: added check for negative value */
%if &bmrho  ^= %str() and &bmrho < 0 %then %do;
	%put WARNING: Prior mean &bmrho for transformed AR(1) correlation coefficient is expected to be positive.;
	%put WARNING- Its absolute value will be used instead.;
	%let bmrho = %sysevalf(- &bmrho);
%end;

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho    = %str() %then %let  bmrho  = %sysevalf(0);;
	
/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho    = %str() %then %let  bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul    = %str() %then %let  btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu    = %str() %then %let  btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &bmbeta2 = %str() %then %let bmbeta2 = %sysevalf(0);; 
%if &bpbeta2 = %str() %then %let bpbeta2 = %sysevalf(2.0 * &bpbeta1);; 
%if &bmbeta3 = %str() %then %let bmbeta3 = %sysevalf(0);; 	
%if &bpbeta3 = %str() %then %let bpbeta3 = %sysevalf(4.0 * &bpbeta1);; 		
%if &bbeta2l = %str() %then %let bbeta2l = %sysevalf(0);; 						
%if &bbeta2u = %str() %then %let bbeta2u = %sysevalf(1.5 * &bbeta1u);;
%if &bbeta3l = %str() %then %let bbeta3l = %sysevalf(0);; 	
%if &bbeta3u = %str() %then %let bbeta3u = %sysevalf(2.0 * &bbeta1u);; 

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF: Named 1-dimensional arrays of regression parameters other than intercept (if any) */
%let b1line=; %let b2line=; %let b3line=; 
%if not(%upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %let b1line = array b1g[&g] b1g1-b1g&g ;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC FULL_QUAD INDEP_QUAD %then %let b2line = array b2g[&g] b2g1-b2g&g ;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %let b3line = array b3g[&g] b3g1-b3g&g ;

/* eMKF: Constant arrays of hyperparameters to pass to UDS (fully Bayesian setting only) */
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %let b1line = &b1line%str(;) array mb1hyp[2] (&bmbeta1 &bpbeta1) ;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %let b2line = &b2line%str(;) array mb2hyp[2] (&bmbeta2 &bpbeta2) ;
%if %upcase(&btype) = FULL_CUBIC %then %let b3line = &b3line%str(;) array mb3hyp[2] (&bmbeta3 &bpbeta3) ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means 
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to selected parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF: Hyper-parameters in the full Bayesian models */
%let mbparline=; %let sbparline=; %let sbparline2=;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let mbparline = &mbparline mb1 ;
	%let sbparline = &sbparline sb1 ;
	%let sbparline2 = &sbparline2 parms sb1 &bslice;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let mbparline = &mbparline mb2 ;
	%let sbparline = &sbparline sb2 ;
	%let sbparline2 = &sbparline2 parms sb2 &bslice;
%end;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let mbparline = &mbparline mb3 ;
	%let sbparline = &sbparline sb3 ;
	%let sbparline2 = &sbparline2 parms sb3 &bslice;
%end;

/* eMKF: Intercepts */
%let aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let aparline = &aparline ag&_i ; 
%end; 

/* eMKF: Linear, quadratic, and cubic coefficients, as needed */
%let parline = &aparline; %let _i = 0;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i b3g&_i ;
	%end;
%end;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i ;
	%end;
%end;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i ;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC   %then %let parline = &parline b1 b2 b3 ;
%if %upcase(&btype) = COMMON_QUAD    %then %let parline = &parline b1 b2 ;
%if %upcase(&btype) = COMMON_LINEAR  %then %let parline = &parline b1 ;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* mbetag and Dbetag updated with the hyper-parameters in the fully Bayesian models */
%if &mbparline ^= %str() %then %let udsparline = &udsparline parms &mbparline mbetag Dbetag %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF: Hyper-prior specification in the full Bayesian models */
%let hplinemb1=; %let hplinemb2=; %let hplinemb3=; %let hplinesb1=; %let hplinesb2=; %let hplinesb3=;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let hplinesb3 = hyperprior sb3 ~ uniform(&bbeta3l, &bbeta3u);
	%let hplinemb3 = hyperprior mb3 ~ normal(&bmbeta3, prec=&bpbeta3);
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let hplinesb2 = hyperprior sb2 ~ uniform(&bbeta2l, &bbeta2u);
	%let hplinemb2 = hyperprior mb2 ~ normal(&bmbeta2, prec=&bpbeta2);
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let hplinesb1 = hyperprior sb1 ~ uniform(&bbeta1l, &bbeta1u);
	%let hplinemb1 = hyperprior mb1 ~ normal(&bmbeta1, prec=&bpbeta1); 
%end;

/* eMKF: Prior for intercepts ag1 through ag&g */
%let plinea = prior &aparline ~ normal(&bmalpha, prec=&bpalpha);

/* eMKF: Priors for regression parameters other than intercepts */
%let plineb1=; %let plineb2=; %let plineb3=;
%if %upcase(&btype) = INDEP_CUBIC %then
	%let plineb3 = prior b3g: ~ normal(&bmbeta3, prec=&bpbeta3);
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD %then 
	%let plineb2 = prior b2g: ~ normal(&bmbeta2, prec=&bpbeta2);
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then 
	%let plineb1 = prior b1g: ~ normal(&bmbeta1, prec=&bpbeta1);
%if %upcase(&btype) = COMMON_CUBIC %then 
	%let plineb3 = prior b3 ~ normal(&bmbeta3, prec=&bpbeta3);
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD %then 
	%let plineb2 = prior b2 ~ normal(&bmbeta2, prec=&bpbeta2);
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then 
	%let plineb1 = prior b1 ~ normal(&bmbeta1, prec=&bpbeta1);
%if %upcase(&btype) = FULL_CUBIC %then 
	%let plineb3 = prior b3g: ~ normal(mb3, sd=sb3);
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then 
	%let plineb2 = prior b2g: ~ normal(mb2, sd=sb2);
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then
	%let plineb1 = prior b1g: ~ normal(mb1, sd=sb1);

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF: Initial values for regression hyper-parameters in the fully Bayesian models */
%let initlinemb1=; %let initlinemb2=; %let initlinemb3=; %let initlinesb1=; %let initlinesb2=; %let initlinesb3=;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let initlinesb3 = sb3 = rand('uniform', &bbeta3l, &bbeta3u);
	%let initlinemb3 = mb3 = &bmbeta3 + sqrt(1/&bpbeta3)*rand('normal') ;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let initlinesb2 = sb2 = rand('uniform', &bbeta2l, &bbeta2u);
	%let initlinemb2 = mb2 = &bmbeta2 + sqrt(1/&bpbeta2)*rand('normal') ;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let initlinesb1 = sb1 = rand('uniform', &bbeta1l, &bbeta1u);
	%let initlinemb1 = mb1 = &bmbeta1 + sqrt(1/&bpbeta1)*rand('normal') ;
%end;

/* eMKF: Initial values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
%let initmbeta = call zeromatrix(Dbetag);	
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &bmalpha%str(;) Dbetag[1,1] = &bpalpha;

/* eMKF: In models other than the fully Bayesian trend models, mbetag and Dbetag are constants */
%if not(%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR DROPPED)
	%then %let initmbeta = &initmbeta%str(;) mbetag[2,1] = &bmbeta1%str(;) Dbetag[2,2] = &bpbeta1;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD COMMON_CUBIC COMMON_QUAD 
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta2%str(;) Dbetag[3,3] = &bpbeta2;
%if %upcase(&btype) in INDEP_CUBIC COMMON_CUBIC 
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = &bmbeta3%str(;) Dbetag[4,4] = &bpbeta3;

/* eMKF: In fully Bayesian models, mbetag and Dbetag depend on model parameters and are updated accordingly */
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR 
	%then %let initmbeta = &initmbeta%str(;) mbetag[2,1] = mb1%str(;) Dbetag[2,2] = 1/sb1**2;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = mb2%str(;) Dbetag[3,3] = 1/sb2**2;
%if %upcase(&btype) = FULL_CUBIC
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = mb3%str(;) Dbetag[4,4] = 1/sb3**2;

/* eMKF: Initial values for intercepts */
%let initlinea=; %let _i = 0;
%do _i = 1 %to &g; 
	%let initlinea = &initlinea ag&_i = &bmalpha+sqrt(1/&bpalpha)*rand('normal')%str(;) ;
%end;

/* eMKF: Initial values for regression parameters */
%let initlineb1=; %let initlineb2=; %let initlineb3=; %let _i=0;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 b3g&_i=mb3+sb3*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 b2g&_i=mb2+sb2*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 b1g&_i=mb1+sb1*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) = INDEP_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 b3g&_i=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC %then
	%let initlineb3 = b3 = &bmbeta3 + sqrt(1/&bpbeta3)*rand('normal') ;
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD %then
	%let initlineb2 = b2 = &bmbeta2 + sqrt(1/&bpbeta2)*rand('normal') ;
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then
	%let initlineb1 = b1 = &bmbeta1 + sqrt(1/&bpbeta1)*rand('normal') ;

/* eMKF: Initial values for unobserved true states predictions given regression parameters */
%let _i = 0; %let _j = 0; 
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %do;
    %do _i = 1 %to &g; 
	    %local initetamnarr&_i;   /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	    %do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i+X[&_j,3]*b2g&_i+X[&_j,4]*b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n;  														 /* eMKF v2.4 correction to selected columns in X */
	  		%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i+X[&_j,3]*b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
			%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1+X[&_j,3]*b2+X[&_j,4]*b3%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1+X[&_j,3]*b2%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = DROPPED %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &brtm.0 %if &d > 1 %then &brtm.1; %if &d > 2 %then &brtm.2; %if &d > 3 %then &brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
%let rcXline = ;
%if &p = 1 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'));
%if &p = 2 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'));
%if &p = 3 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'));
%if &p = 4 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'), resolve('&brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions */
/*       These will be applied in the order defined here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ; 

/* eMKF: UDS statement for mean hyper-parameters in fully Bayesian models (if applicable) */
/*       The pseudo-parameters mbetag and Dbetag are also updated in those UDS subroutines */
/*       Note that the sb1-sb3 are updated via the M-H sampler, which is applied before the UDS per SAS documentation */
%if %upcase(&btype) = FULL_CUBIC %then
	%let udsline = &udsline uds MP_bfc(mb1, mb2, mb3, mbetag, Dbetag, b1g, b2g, b3g, mb1hyp, mb2hyp, mb3hyp, sb1, sb2, sb3)%str(;) ;
%if %upcase(&btype) = FULL_QUAD %then
	%let udsline = &udsline uds MP_bfq(mb1, mb2, mbetag, Dbetag, b1g, b2g, mb1hyp, mb2hyp, sb1, sb2)%str(;) ;
%if %upcase(&btype) = FULL_LINEAR %then
	%let udsline = &udsline uds MP_bfl(mb1, mbetag, Dbetag, b1g, mb1hyp, sb1)%str(;) ;

/* eMKF: UDS statement for regression coefficients  */
/*       The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if %upcase(&btype) = DROPPED %then
	%let udsline = &udsline uds CP_b0(ag, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_LINEAR %then
	%let udsline = &udsline uds CP_b1l(ag, b1, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_QUAD %then 
	%let udsline = &udsline uds CP_b1q(ag, b1, b2, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_CUBIC %then
	%let udsline = &udsline uds CP_b1c(ag, b1, b2, b3, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_LINEAR FULL_LINEAR %then
	%let udsline = &udsline uds CP_bgl(ag, b1g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_QUAD FULL_QUAD %then
	%let udsline = &udsline uds CP_bgq(ag, b1g, b2g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_CUBIC FULL_CUBIC %then
	%let udsline = &udsline uds CP_bgc(ag, b1g, b2g, b3g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then 
	%let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%let monitorline = &sbparline &mbparline &parline etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;

proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, &p];										/* design matrix to use in matrix multiplication */
	  array mbetag[&p, 1];									/* prior mean vector for betas (assumed common accross groups) */
	  array Dbetag[&p, &p];									/* diagonal prior precision matrix for betas (assumed common accross groups) */
	  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;	/* conformal arrays used in UDS subroutines for common trend models */
		 array aX[&n, 1];									/* design matrix (intercept only) */
		 array bX[&n, %eval(&p-1)];							/* design matrix (excl. intercept) */
	  	 array ambetag[1, 1];								/* hyper parameter vector (intercept only) */
		 array bmbetag[%eval(&p-1), 1];						/* hyper parameter vector (excl. intercept) */
		 array aDbetag[1, 1];								/* hyper parameter matrix (intercept only) */
		 array bDbetag[%eval(&p-1),%eval(&p-1)];			/* hyper parameter matrix (excl. intercept) */
	  %end;
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  array ag[&g] ag1-ag&g;								/* named 1-dimensional array of group-specific intercepts */
	  &b1line;;												/* named 1-dimensional array of group-specific linear coefficients (if requested) */
 	  &b2line;;                     						/* named 1-dimensional array of group-specific quad coefficients (if requested) */
	  &b3line;; 											/* named 1-dimensional array of group-specific cubic coefficients (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
		  if &p > 1 then do;								/* Xarr is a 2-dimensional array for p > 1 */
		 	  do i = 1 to &n;
			 	  do m = 1 to &p;
					  X[i,m] = Xarr[i,m];						
			  	  end;
		  	  end;
		  end;
		  else do;											/* !! Xarr collapses to a 1-dimensional array if p = 1 !! */
		 	  do i = 1 to &n;
			  	  X[i,1] = Xarr[i];						
		  	  end;
		  end;
		  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do; /* conformal subarrays used in UDS subroutines for common trend models */
			  do i = 1 to &n;								
				  aX[i, 1] = X[i, 1];
				  do m = 2 to &p;
					  bX[i, m-1] = X[i, m];
				  end;
			  end;
		  %end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
			*	  dg[k] = nu[k]**&n;
			*	  do i = 2 to &n;
			*		  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*	  end;
			*	  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*		  rho = 0;             
			*		  nu[k] = tausq[k]; 		 
			*	      dg[k] = nu[k]**&n;
			*	  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initlinesb1;;									/* initialize SD hyperparameter sb1 (if applicable) */
	  	  &initlinesb2;;									/* initialize SD hyperparameter sb2 (if applicable) */
	  	  &initlinesb3;;									/* initialize SD hyperparameter sb3 (if applicable) */
		  &initlinemb1;;									/* initialize mean hyperparameter mb1 (if applicable) */
	  	  &initlinemb2;;									/* initialize mean hyperparameter mb2 (if applicable) */
	  	  &initlinemb3;;									/* initialize mean hyperparameter mb3 (if applicable) */
		  &initmbeta;;							 			/* initialize mbetag and Dbetag */
		  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;	/* conformal subarrays used in UDS subroutines for common trend models */
			  call zeromatrix(aDbetag);
			  call zeromatrix(bDbetag); 
		  	  ambetag[1,1] = mbetag[1,1];
		  	  aDbetag[1,1] = Dbetag[1,1];	
			  do m = 2 to &p;
				  bmbetag[m-1, 1] = mbetag[m,1];
			      bDbetag[m-1, m-1] = Dbetag[m,m];	
			  end;
		  %end;

		  &initlinea;;										/* initialize intercepts */
		  &initlineb1;;										/* initialize linear coefficients (if applicable) */
		  &initlineb2;;										/* initialize quad coefficients (if applicable) */	
		  &initlineb3;;										/* initialize cubic coefficients (if applicable) */

          %do _i = 1 %to &g; 
		      &&initetamnarr&_i;;						    /* initialize conditional mean for true states  */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /********************/
	  /* UDS declarations */
	  /********************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  &sbparline2;;											/* SD hyper-parameters (if any) */
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			*    dg[k] = nu[k]**&n;
			*    do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*    end;
			*    if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])-1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			*    dg[k] = nu[k]**&n;
			*    do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			*    end;
			*    if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;

	  	  &hplinesb1;;						 	 			/* SD hyper-priors in the full_linear, full_quad, and full_cubic cases */
	  	  &hplinesb2;;						 	 			/* SD hyper-priors in the full_quad and full_cubic cases */
	  	  &hplinesb3;;						 	 			/* SD hyper-prior in the full_cubic case */
	      &hplinemb1;;						 	 			/* Mean hyper-priors in the full_linear, full_quad, and full_cubic cases */
	  	  &hplinemb2;;						 	 			/* Mean hyper-priors in the full_quad and full_cubic cases */	
      	  &hplinemb3;; 						 	 			/* Mean hyper-prior in the full_cubic case */
		  %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then	
		  	  prior mbetag Dbetag ~ general(0);;			/* pseudo-parameters mbetag and Dbetag do no contribute to prior */
	  	  &plinea;; 							 			/* prior for intercepts */
	  	  &plineb1;;							 			/* prior for linear coefficients (if those were requested) */
	  	  &plineb2;;							 			/* prior for quadratic coefficients (if those were requested) */
	  	  &plineb3;;							 			/* prior for cubic coefficients (if those were requested) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		  	  lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;

		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= etamn: Log: spsi mpsi &tauparline &psiparline
				    	%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; ) 
			&blog(keep = spsi mpsi)
	  ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: &tauparline psi
				    	%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: tau psi
				       %if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF: order columns by group */
	data _blogc2_;
  	  retain  Iteration 
			  %do _i=1 %to &g;
				  ag&_i
				  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then b1g&_i;
				  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then b1g&_i b2g&_i;
				  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then b1g&_i b2g&_i b3g&_i;
			  %end;
			  %if %upcase(&btype) = COMMON_LINEAR %then b1 ; 
			  %if %upcase(&btype) = COMMON_QUAD   %then b1 b2 ; 
			  %if %upcase(&btype) = COMMON_CUBIC  %then b1 b2 b3 ; 
	  ;
	  set &blog(keep = Iteration ag: %if &p > 1 %then b: ;);
	run;

	/* eMKF: block diagonal by group */
	%let oPPmat = ; %let _i = 0;
	%do _i = 1 %to &g; 
		%if &_i = 1 %then %let oPPmat = block( oP ;
		%if &_i > 1 and &_i < &g %then %let oPPmat = &oPPmat , block ( oP ;
		%if &_i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let oPPmat = &oPPmat );
	%end;

	%let _i = 0;

	/* eMKF: call proc iml to perform matrix multiplication */
	proc iml;

		use _oPmat_;
		read all into oP; close _oPmat_;
		oP = oP[1:&p, 1:&p];
		oPP = &oPPmat;;

		/* eMKF: re-structure block matrix in the common trend cases (where &p > 1) */
		%if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
			oPP1 = oPP[do(1, &g*&p, &p), do(1, &g*&p, &p)];
			oPP2 = vecdiag(oPP[do(1, &g*&p, &p), do(2, &g*&p, &p)]);
			ToPP2 = vecdiag(oPP[do(2, &g*&p, &p), do(1, &g*&p, &p)]);
			oPP1 = oPP1 // T(ToPP2);
			oPP0 = oPP2;
			%if &p > 2 %then %do;
				oPP3 = vecdiag(oPP[do(1, &g*&p, &p), do(3, &g*&p, &p)]);
				ToPP3 = vecdiag(oPP[do(3, &g*&p, &p), do(1, &g*&p, &p)]);
				oPP1 = oPP1 // T(ToPP3);
				oPP0 = oPP0 || oPP3;
			%end;
			%if &p > 3 %then %do;
				oPP4 = vecdiag(oPP[do(1, &g*&p, &p), do(4, &g*&p, &p)]);
				ToPP4 = vecdiag(oPP[do(4, &g*&p, &p), do(1, &g*&p, &p)]);
				oPP1 = oPP1 // T(ToPP4);
				oPP0 = oPP0 || oPP4;
			%end;
			oPP0 = oPP0 // oPP[2:&p, 2:&p];
			oPP = oPP1 || oPP0;
		%end;

		varNames = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames = varNames || {"ag&_i"};
		  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then varNames = varNames || {"b1g&_i"};;
		  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then varNames = varNames || {"b1g&_i"} || {"b2g&_i"};;
		  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then varNames = varNames || {"b1g&_i"} || {"b2g&_i"} || {"b3g&_i"};;
		%end;
		%if %upcase(&btype) = COMMON_LINEAR %then varNames = varNames || {"b1"};;
		%if %upcase(&btype) = COMMON_QUAD   %then varNames = varNames || {"b1" "b2"};;
		%if %upcase(&btype) = COMMON_CUBIC  %then varNames = varNames || {"b1" "b2" "b3"};;

		use _blogc2_;
		read all into oB;
		close _blogc2_;

		oB1 = oB[,1];
		oB = T(oB[,2:ncol(oB)]);
		oBB = oPP * oB;
		oBB = oB1 || T(oBB);

		create _tblogc2_ var varNames;
		append from oBB;
		close _tblogc2_;

	quit;

	/* eMKF: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration ag1-ag&g 
			  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then b1g1-b1g&g ; 
			  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then b1g1-b1g&g b2g1-b2g&g ; 
			  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g ; 
			  %if %upcase(&btype) = COMMON_LINEAR %then b1 ; 
			  %if %upcase(&btype) = COMMON_QUAD   %then b1 b2 ; 
			  %if %upcase(&btype) = COMMON_CUBIC  %then b1 b2 b3 ; 
	  ;
	  set _tblogc2_;
	run;

	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then sb: mb: ;)
	        _tblogc_
			&blog(drop = %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then sb: mb: ;
						 ag: %if &p > 1 %then b: ; )
	  ;
	  by Iteration;
	run;

%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bbjunk _oXmat_ _oPmat_ _tblogc_ _tblogc2_ _blogc2_;
run ;
quit;

%mend bayesfit;

data _null_;
run;


/* BAYESFITxptl macro
 Version of BAYESFIT macro for eMKF v2.4 to allow intercept-only (level) shift in trend.

 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 btype              : full_cubic, full_quad, full_linear, indep_cubic, indep_quad, indep_linear, common_cubic, common_quad, common_linear, or dropped
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 bxpt				: value of timepoint at which trend break occurs.
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar (default)if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior; 
					  common_arh (new in eMKF 2.3) if AR correlation is common but variance parameters are independent.
 bslicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling step 
					  Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression if borpoly=YES.
 s1bmalpha,s1bpalpha: prior mean and precision for alphas in segment 1
 s2bmalpha,s2bpalpha: prior mean and precision for alphas in segment 2
 bmbeta1 , bpbeta1	: prior mean and precision for mean linear coefficient(s) across groups
 bmbeta2 , bpbeta2 	: prior mean and precision for mean quadratic coefficient(s) across groups
 bmbeta3 , bpbeta3	: prior mean and precision for mean cubic coefficient(s) across groups
 bbeta1l , bbeta1u	: bounds for U(a,b) prior for SD of linear coefficients across groups -- only used for hyperprior(s) in full_cubic, full_quad, or full_linear
 bbeta2l , bbeta2u	: bounds for U(a,b) prior for SD of quadratic coefficients across groups -- only used for hyperprior(s) in full_cubic or full_quad
 bbeta3l , bbeta3u	: bounds for U(a,b) prior for SD of cubic coefficients across groups -- only used for hyperprior(s) in full_cubic
 bmrho , bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul , btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of the CMP library (usually set in parent macro mkf)

*/
%macro bayesfitxptl(
             bdata	= , 
			 blog	= ,
			 btype	= full_linear, 
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time,
			 bxpt   = , 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of parent mkf macro 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values */
			 s1bmalpha  = , s1bpalpha= ,
			 s2bmalpha  = , s2bpalpha= ,
			 bmbeta1  = 0,  bpbeta1  = ,    /* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 bmbeta2  = 0,  bpbeta2  = ,
			 bmbeta3  = 0,  bpbeta3  = ,
			 bbeta1l  = 0,  bbeta1u  = ,	/* eMKF: bbeta1l is Constant c5 in RAND's MKF User's Guide */
			 bbeta2l  = 0,  bbeta2u  = ,
			 bbeta3l  = 0,  bbeta3u  = ,
             bmrho    = 0,  bprho    = 1,	/* eMKF: bmrho is c9 and bprho is c10 in RAND's MKF User's Guide */
			 btaul    = 0.0001,	btauu= ,  	/* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape  = ,   bvscale  = ,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc = work.funcs
             ) / minoperator;  /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local g n s1n s2n p d brtm s1brtm s2brtm _brtimess brangeY s1brangeY s2brangeY bqrangeV bmedianV formatted dsop dscl _i _j oPPmat
       b1line b2line b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline
       parline s1aparline s2aparline vparline mbparline sbparline udsparline tauparline2 psiparline2 sbparline2
       plines1a plines2a plineb1 plineb2 plineb3 plinev plinetau plinepsi bslice
       hplinemb1 hplinesb1 hplinemb2 hplinesb2 hplinemb3 hplinesb3 hplinempsi hplinespsi
	   initlines1a initlines2a initlineb1 initlineb2 initlineb3 initlinevarr initlinetau initlinepsi
	   initlinemb1 initlinemb2 initlinemb3 initlinesb1 initlinesb2 initlinesb3 
       monitorline optionline udsline rcXline rcNline initmbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformatXPT(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, xpt=&bxpt, randomVars=&brndvars, outformat=_bbdata_ );
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1 */
%let s1n=;
data _bfreqs1n_;
run;
proc freq data=_bbdata_ noprint;
  tables _s1rtime /list out=_bfreqs1n_;
run;
data _bfreqs1n_;
  set _bfreqs1n_(where=(_s1rtime ne 0));
  _s1tm + 1;
  call symput('s1n',_s1tm);
  keep _s1tm _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2 */
%let s2n=;
data _bfreqs2n_;
run;
proc freq data=_bbdata_ noprint;
  tables _s2rtime /list out=_bfreqs2n_;
run;
data _bfreqs2n_;
  set _bfreqs2n_(where=(_s2rtime ne 0));
  _s2tm + 1;
  call symput('s2n',_s2tm);
  keep _s2tm _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _bfreqs2n_;
  set _bfreqs2n_;
  _s2tm = _s2tm + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: variables that will be used for real times in case timepoints are irregular */
%let brtm =_rtime; %let s1brtm=_s1rtime;  %let s2brtm=_s2rtime;

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p = 1;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC COMMON_CUBIC %then %let p = 5;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD COMMON_QUAD %then %let p = 4;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR COMMON_LINEAR %then %let p = 3;
%if %upcase(&btype) = DROPPED %then %let p = 2;
%let p = %eval(0+&p); 

/* eMKF v2.4: max polynomial rank to use in orpoly is d-1 */
%let d = 0;
%if &s1n > 4 or &s2n > 4 %then %let d = 4; /* cubic allowed with 5+ timepoints in either segments 1 or 2 */
%else %do;
	%if &s1n > 3 or &s2n > 3 %then %let d = 3; /* quad allowed with 4+ timepoints in either segments 1 or 2 */
	%else %do;
		%if &s1n > 2 or &s2n > 2 %then %let d = 2; /* linear allowed with 3+ timepoints in either segments 1 or 2 */
		%else %let d = 1;     /* intercepts-only model is allowed with just 2 timepoints in both segments 1 and 2 */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4: Error check to make sure requested trend model can be fit */
%if (&p > &d+1) %then %do;
	%put ERROR: Specified trend model cannot be fit. Please review!;
	%put ERROR- &btype was requested: there are only enough data for a degree %eval(&d-1) polynomial.;; 
  	%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  s1x0 = { %cnstss(1, &s1n) %cnstss(0, &s2n)};
	  s1x0 = T(s1x0);										/* eMKF v2.4: Intercepts for segment 1 */
	  s2x0 = { %cnstss(0, &s1n) %cnstss(1, &s2n)}; 
	  s2x0 = T(s2x0);										/* eMKF v2.4: Intercepts for segment 2 */
	  x = { &_brtimess };
	  x = T(x);												/* eMKF: column vector with real times */
	  %if &d = 1 %then oP0 = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP0 = orpol(x, &d-1);;				/* eMKF v2.4: orthonormal design matrix oP */
	  oP = (oP0[,1]#s1x0) || (oP0[,1]#s2x0);
	  %if &s1n > 2 or &s2n > 2 %then oP = oP || oP0[,2];;
	  %if &s1n > 3 or &s2n > 3 %then oP = oP || oP0[,3];;
	  %if &s1n > 4 or &s2n > 4 %then oP = oP || oP0[,4];;
	  %if &s1n > 2 or &s2n > 2 %then x1 = x;;
	  %if &s1n > 3 or &s2n > 3 %then x2 = x#x1;;
	  %if &s1n > 4 or &s2n > 4 %then x3 = x#x2;;
	  uP = s1x0 || s2x0;									/* eMKF v2.4: raw/unstandardized design matrix uP */
	  %if &s1n > 2 or &s2n > 2 %then uP = uP || x1;;
	  %if &s1n > 3 or &s2n > 3 %then uP = uP || x2;;
	  %if &s1n > 4 or &s2n > 4 %then uP = uP || x3;;
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
	  oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];
      %if &s1n > 2 or &s2n > 2 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &s1n > 3 or &s2n > 3 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
      %if &s1n > 4 or &s2n > 4 %then oP5 = inv(T(uP)*uP)*T(uP)*oP[,5];;
	  oPP = oP1 || oP2;										/* eMKF: right multiplication of uP with oPP produces oP */
	  %if &s1n > 2 or &s2n > 2 %then oPP = oPP || oP3;;
	  %if &s1n > 3 or &s2n > 3 %then oPP = oPP || oP4;;
	  %if &s1n > 4 or &s2n > 4 %then oPP = oPP || oP5;;
	  y = T(do(1, &n, 1));									/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" "&brtm.2" "&brtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" "&brtm.2" } ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" } ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _bbdata_ */
	  set _bbdata_;
	  if &s1brtm > 0 then &s1brtm.0 = 1; else &s1brtm.0 = 0;
	  if &s2brtm > 0 then &s2brtm.0 = 1; else &s2brtm.0 = 0;
	  %if &d > 1 %then &brtm.1 = &brtm;;
	  %if &d > 2 %then &brtm.2 = &brtm**2;;
	  %if &d > 3 %then &brtm.3 = &brtm**3;;
	run;
%end;

/* eMKF v2.4: Evaluate range of the data in each segment to use in setting prior parameters */
%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

%let s1brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s1brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s1brangeY", range);
run;
%let s1brangeY = %sysevalf(&s1brangeY + 0);

%let s2brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s2brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s2brangeY", range);
run;
%let s2brangeY = %sysevalf(&s2brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF: c1 in RAND's MKF User's Guide */
%if &s1bmalpha = %str() %then %let s1bmalpha = %sysevalf(0.5 * &s1brangeY);;
%if &s2bmalpha = %str() %then %let s2bmalpha = %sysevalf(0.5 * &s2brangeY);;

/* eMKF: 1/c2 in RAND's MKF User's Guide */	
%if &s1bpalpha = %str() %then %let s1bpalpha = %sysevalf(0.000001/(&s1brangeY**2));; 
%if &s2bpalpha = %str() %then %let s2bpalpha = %sysevalf(0.000001/(&s2brangeY**2));; 

/* eMKF: c3 or c7 in RAND's MKF User's Guide */
%if &bmbeta1 = %str() %then %let bmbeta1 = %sysevalf(0);;

/* eMKF: 1/c4 in RAND's MKF User's Guide */ 
%if &bpbeta1  = %str() and (%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR) 
	%then %let bpbeta1  = %sysevalf(10/(&brangeY**2));;

/* eMKF: 1/c8 in RAND's MKF User's Guide */	
%if &bpbeta1  = %str() and not(%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR) 
	%then %let bpbeta1  = %sysevalf(0.000001/(&brangeY**2));;

/* eMKF: c5 in RAND's MKF User's Guide  */
%if &bbeta1l  = %str() %then %let bbeta1l = %sysevalf(0);;						

/* eMKF: c6 in RAND's MKF User's Guide  */	
%if &bbeta1u  = %str() %then %let bbeta1u = %sysevalf(0.5 * &brangeY);;		

/* eMKF v2.4: added check for negative value */
%if &bmrho  ^= %str() and &bmrho < 0 %then %do;
	%put WARNING: Prior mean &bmrho for transformed AR(1) correlation coefficient is expected to be positive.;
	%put WARNING- Its absolute value will be used instead.;
	%let bmrho = %sysevalf(- &bmrho);
%end;

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho    = %str() %then %let  bmrho  = %sysevalf(0);;	

/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho    = %str() %then %let  bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul    = %str() %then %let  btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu    = %str() %then %let  btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &bmbeta2 = %str() %then %let bmbeta2 = %sysevalf(0);; 
%if &bpbeta2 = %str() %then %let bpbeta2 = %sysevalf(2.0 * &bpbeta1);; 
%if &bmbeta3 = %str() %then %let bmbeta3 = %sysevalf(0);; 	
%if &bpbeta3 = %str() %then %let bpbeta3 = %sysevalf(4.0 * &bpbeta1);; 		
%if &bbeta2l = %str() %then %let bbeta2l = %sysevalf(0);; 						
%if &bbeta2u = %str() %then %let bbeta2u = %sysevalf(1.5 * &bbeta1u);;
%if &bbeta3l = %str() %then %let bbeta3l = %sysevalf(0);; 	
%if &bbeta3u = %str() %then %let bbeta3u = %sysevalf(2.0 * &bbeta1u);; 

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF: Named 1-dimensional arrays of regression parameters other than intercept (if any) */
%let b1line=; %let b2line=; %let b3line=; 
%if not(%upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %let b1line = array b1g[&g] b1g1-b1g&g ;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC FULL_QUAD INDEP_QUAD %then %let b2line = array b2g[&g] b2g1-b2g&g ;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %let b3line = array b3g[&g] b3g1-b3g&g ;

/* eMKF: Constant arrays of hyperparameters to pass to UDS (fully Bayesian setting only) */
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %let b1line = &b1line%str(;) array mb1hyp[2] (&bmbeta1 &bpbeta1) ;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %let b2line = &b2line%str(;) array mb2hyp[2] (&bmbeta2 &bpbeta2) ;
%if %upcase(&btype) = FULL_CUBIC %then %let b3line = &b3line%str(;) array mb3hyp[2] (&bmbeta3 &bpbeta3) ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means 
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to selected parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF: Hyper-parameters in the full Bayesian models */
%let mbparline=; %let sbparline=; %let sbparline2=;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let mbparline = &mbparline mb1 ;
	%let sbparline = &sbparline sb1 ;
	%let sbparline2 = &sbparline2 parms sb1 &bslice;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let mbparline = &mbparline mb2 ;
	%let sbparline = &sbparline sb2 ;
	%let sbparline2 = &sbparline2 parms sb2 &bslice;
%end;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let mbparline = &mbparline mb3 ;
	%let sbparline = &sbparline sb3 ;
	%let sbparline2 = &sbparline2 parms sb3 &bslice;
%end;

/* eMKF v2.4: Segment 1 intercepts */
%let s1aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s1aparline = &s1aparline s1ag&_i ; 
%end; 

/* eMKF v2.4: Segment 2 intercepts */
%let s2aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s2aparline = &s2aparline s2ag&_i ; 
%end; 

/* eMKF: Linear, quadratic, and cubic coefficients, as needed */
%let parline = &s1aparline &s2aparline; /* eMKF v2.4: parline accounts for two sets of intercepts */
%let _i = 0;
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i b3g&_i ;
	%end;
%end;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i ;
	%end;
%end;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i ;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC   %then %let parline = &parline b1 b2 b3 ;
%if %upcase(&btype) = COMMON_QUAD    %then %let parline = &parline b1 b2 ;
%if %upcase(&btype) = COMMON_LINEAR  %then %let parline = &parline b1 ;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* mbetag and Dbetag updated with the hyper-parameters in the fully Bayesian models */
%if &mbparline ^= %str() %then %let udsparline = &udsparline parms &mbparline mbetag Dbetag %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF: Hyper-prior specification in the full Bayesian models */
%let hplinemb1=; %let hplinemb2=; %let hplinemb3=; %let hplinesb1=; %let hplinesb2=; %let hplinesb3=;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let hplinesb3 = hyperprior sb3 ~ uniform(&bbeta3l, &bbeta3u);
	%let hplinemb3 = hyperprior mb3 ~ normal(&bmbeta3, prec=&bpbeta3);
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let hplinesb2 = hyperprior sb2 ~ uniform(&bbeta2l, &bbeta2u);
	%let hplinemb2 = hyperprior mb2 ~ normal(&bmbeta2, prec=&bpbeta2);
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let hplinesb1 = hyperprior sb1 ~ uniform(&bbeta1l, &bbeta1u);
	%let hplinemb1 = hyperprior mb1 ~ normal(&bmbeta1, prec=&bpbeta1); 
%end;

/* eMKF v2.4: Prior for intercepts ag1 through ag&g in segments 1 and 2 */
%let plines1a = prior &s1aparline ~ normal(&s1bmalpha, prec=&s1bpalpha);
%let plines2a = prior &s2aparline ~ normal(&s2bmalpha, prec=&s2bpalpha);

/* eMKF: Priors for regression parameters other than intercepts */
%let plineb1=; %let plineb2=; %let plineb3=;
%if %upcase(&btype) = INDEP_CUBIC %then
	%let plineb3 = prior b3g: ~ normal(&bmbeta3, prec=&bpbeta3);
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD %then 
	%let plineb2 = prior b2g: ~ normal(&bmbeta2, prec=&bpbeta2);
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then 
	%let plineb1 = prior b1g: ~ normal(&bmbeta1, prec=&bpbeta1);
%if %upcase(&btype) = COMMON_CUBIC %then 
	%let plineb3 = prior b3 ~ normal(&bmbeta3, prec=&bpbeta3);
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD %then 
	%let plineb2 = prior b2 ~ normal(&bmbeta2, prec=&bpbeta2);
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then 
	%let plineb1 = prior b1 ~ normal(&bmbeta1, prec=&bpbeta1);
%if %upcase(&btype) = FULL_CUBIC %then 
	%let plineb3 = prior b3g: ~ normal(mb3, sd=sb3);
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then 
	%let plineb2 = prior b2g: ~ normal(mb2, sd=sb2);
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then
	%let plineb1 = prior b1g: ~ normal(mb1, sd=sb1);

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF: Initial values for regression hyper-parameters in the fully Bayesian models */
%let initlinemb1=; %let initlinemb2=; %let initlinemb3=; %let initlinesb1=; %let initlinesb2=; %let initlinesb3=;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%let initlinesb3 = sb3 = rand('uniform', &bbeta3l, &bbeta3u);
	%let initlinemb3 = mb3 = &bmbeta3 + sqrt(1/&bpbeta3)*rand('normal') ;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%let initlinesb2 = sb2 = rand('uniform', &bbeta2l, &bbeta2u);
	%let initlinemb2 = mb2 = &bmbeta2 + sqrt(1/&bpbeta2)*rand('normal') ;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%let initlinesb1 = sb1 = rand('uniform', &bbeta1l, &bbeta1u);
	%let initlinemb1 = mb1 = &bmbeta1 + sqrt(1/&bpbeta1)*rand('normal') ;
%end;

/* eMKF v2.4: Initial values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
/* eMKF v2.4: note change in dimensionality */
%let initmbeta = call zeromatrix(Dbetag);	
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &s1bmalpha%str(;) Dbetag[1,1] = &s1bpalpha;
%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s2bmalpha%str(;) Dbetag[2,2] = &s2bpalpha;

/* eMKF v2.4: In models other than the fully Bayesian trend models, mbetag and Dbetag are constants */
%if not(%upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR DROPPED)
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta1%str(;) Dbetag[3,3] = &bpbeta1;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD COMMON_CUBIC COMMON_QUAD 
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = &bmbeta2%str(;) Dbetag[4,4] = &bpbeta2;
%if %upcase(&btype) in INDEP_CUBIC COMMON_CUBIC 
	%then %let initmbeta = &initmbeta%str(;) mbetag[5,1] = &bmbeta3%str(;) Dbetag[5,5] = &bpbeta3;

/* eMKF v2.4: In fully Bayesian models, mbetag and Dbetag depend on model parameters and are updated accordingly */
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR 
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = mb1%str(;) Dbetag[3,3] = 1/sb1**2;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = mb2%str(;) Dbetag[4,4] = 1/sb2**2;
%if %upcase(&btype) = FULL_CUBIC
	%then %let initmbeta = &initmbeta%str(;) mbetag[5,1] = mb3%str(;) Dbetag[5,5] = 1/sb3**2;

/* eMKF v2.4: Initial values for intercepts in segments 1 and 2 */
%let initlines1a=; %let initlines2a=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlines1a = &initlines1a s1ag&_i = &s1bmalpha+sqrt(1/&s1bpalpha)*rand('normal')%str(;) ;
	%let initlines2a = &initlines2a s2ag&_i = &s2bmalpha+sqrt(1/&s2bpalpha)*rand('normal')%str(;) ;
%end;

/* eMKF: Initial values for regression parameters */
%let initlineb1=; %let initlineb2=; %let initlineb3=; %let _i=0;
%if %upcase(&btype) = FULL_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 b3g&_i=mb3+sb3*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 b2g&_i=mb2+sb2*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 b1g&_i=mb1+sb1*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) = INDEP_CUBIC %then %do;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 b3g&_i=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC %then
	%let initlineb3 = b3 = &bmbeta3 + sqrt(1/&bpbeta3)*rand('normal') ;
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD %then
	%let initlineb2 = b2 = &bmbeta2 + sqrt(1/&bpbeta2)*rand('normal') ;
%if %upcase(&btype) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then
	%let initlineb1 = b1 = &bmbeta1 + sqrt(1/&bpbeta1)*rand('normal') ;

/* eMKF v2.4: Initial values for unobserved true states predictions given regression parameters */
/* eMKF v2.4: note change in dimensionality for X matrix */
%let _i = 0; %let _j = 0; 
%if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then %do;
    %do _i = 1 %to &g; 
	    %local initetamnarr&_i;   /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	    %do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i+X[&_j,4]*b2g&_i+X[&_j,5]*b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	  		%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i+X[&_j,4]*b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
			%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_CUBIC %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1+X[&_j,4]*b2+X[&_j,5]*b3%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1+X[&_j,4]*b2%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = COMMON_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = DROPPED %then %do;
	%do _i = 1 %to &g; 
  	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	        %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
/* eMKF v2.4: modified to allow for segment-specific intercepts */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &s1brtm.0 &s2brtm.0 %if &d > 1 %then &brtm.1; %if &d > 2 %then &brtm.2; %if &d > 3 %then &brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
/* eMKF v2.4: note change in dimensionality */
%let rcXline = ;
%if &p = 2 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'));
%if &p = 3 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'));
%if &p = 4 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'));
%if &p = 5 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'), resolve('&brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions */
/*       These will be applied in the order defined here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ; 

/* eMKF v2.4: UDS statement for mean hyper-parameters in fully Bayesian models (if applicable), revised for increased dimension */
/* The pseudo-parameters mbetag and Dbetag are also updated in those UDS subroutines */
/* Note that the sb1-sb3 are updated via the M-H sampler, which is applied before the UDS per SAS documentation */
%if %upcase(&btype) = FULL_CUBIC %then
	%let udsline = &udsline uds MP_xptl_bfc(mb1, mb2, mb3, mbetag, Dbetag, b1g, b2g, b3g, mb1hyp, mb2hyp, mb3hyp, sb1, sb2, sb3)%str(;) ;
%if %upcase(&btype) = FULL_QUAD %then
	%let udsline = &udsline uds MP_xptl_bfq(mb1, mb2, mbetag, Dbetag, b1g, b2g, mb1hyp, mb2hyp, sb1, sb2)%str(;) ;
%if %upcase(&btype) = FULL_LINEAR %then
	%let udsline = &udsline uds MP_xptl_bfl(mb1, mbetag, Dbetag, b1g, mb1hyp, sb1)%str(;) ;

/* eMKF v2.4: UDS statement for regression coefficients, revised to accomodate additional intercept for segment 2  */
/* The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if %upcase(&btype) = DROPPED %then
	%let udsline = &udsline uds CP_xptl_b0(s1ag, s2ag, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_LINEAR %then
	%let udsline = &udsline uds CP_xptl_b1l(s1ag, s2ag, b1, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_QUAD %then 
	%let udsline = &udsline uds CP_xptl_b1q(s1ag, s2ag, b1, b2, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = COMMON_CUBIC %then
	%let udsline = &udsline uds CP_xptl_b1c(s1ag, s2ag, b1, b2, b3, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_LINEAR FULL_LINEAR %then
	%let udsline = &udsline uds CP_xptl_bgl(s1ag, s2ag, b1g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_QUAD FULL_QUAD %then
	%let udsline = &udsline uds CP_xptl_bgq(s1ag, s2ag, b1g, b2g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) in INDEP_CUBIC FULL_CUBIC %then
	%let udsline = &udsline uds CP_xptl_bgc(s1ag, s2ag, b1g, b2g, b3g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then 
	%let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%let monitorline = &sbparline &mbparline &parline etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;
proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, &p];										/* design matrix to use in matrix multiplication */
	  array mbetag[&p, 1];									/* prior mean vector for betas (assumed common accross groups) */
	  array Dbetag[&p, &p];									/* diagonal prior precision matrix for betas (assumed common accross groups) */
	  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;	/* conformal arrays used in UDS subroutines for common trend models */
		 array aX[&n, 2];									/* eMKF v2.4: design matrix now has two intercept columns */
		 array bX[&n, %eval(&p-2)];							/* eMKF v2.4: design matrix (excl. two intercept columns) */
	  	 array ambetag[2, 1];								/* eMKF v2.4: hyper parameter vector (intercepts only) */
		 array bmbetag[%eval(&p-2), 1];						/* eMKF v2.4: hyper parameter vector (excl. intercepts) */
		 array aDbetag[2, 2];								/* eMKF v2.4: hyper parameter matrix (intercepts only) */
		 array bDbetag[%eval(&p-2),%eval(&p-2)];			/* eMKF v2.4: hyper parameter matrix (excl. intercepts) */
	  %end;
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  array s1ag[&g] s1ag1-s1ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 1 */
	  array s2ag[&g] s2ag1-s2ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 2 */
	  &b1line;;												/* named 1-dimensional array of group-specific linear coefficients (if requested) */
 	  &b2line;;                     						/* named 1-dimensional array of group-specific quad coefficients (if requested) */
	  &b3line;; 											/* named 1-dimensional array of group-specific cubic coefficients (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
	 	  do i = 1 to &n;
		 	  do m = 1 to &p;
				  X[i,m] = Xarr[i,m];						/* eMKF v2.4: Xarr remains a 2-dimensional array even in dropped case due to 2 intercept columns */
		  	  end;
	  	  end;
		  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do; /* conformal subarrays used in UDS subroutines for common trend models */
			  do i = 1 to &n;								
				  aX[i, 1] = X[i, 1];						/* eMKF v2.4: segment 1 intercept */
				  aX[i, 2] = X[i, 2];						/* eMKF v2.4: segment 2 intercept */
				  do m = 3 to &p;							/* eMKF v2.4: p must be ge 3 in common_ cases */
					  bX[i, m-2] = X[i, m];
				  end;
			  end;
		  %end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k = 1 to &g;								/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initlinesb1;;									/* initialize SD hyperparameter sb1 (if applicable) */
	  	  &initlinesb2;;									/* initialize SD hyperparameter sb2 (if applicable) */
	  	  &initlinesb3;;									/* initialize SD hyperparameter sb3 (if applicable) */
		  &initlinemb1;;									/* initialize mean hyperparameter mb1 (if applicable) */
	  	  &initlinemb2;;									/* initialize mean hyperparameter mb2 (if applicable) */
	  	  &initlinemb3;;									/* initialize mean hyperparameter mb3 (if applicable) */
		  &initmbeta;;							 			/* initialize mbetag and Dbetag */
		  %if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;	/* conformal subarrays used in UDS subroutines for common trend models */
			  call zeromatrix(aDbetag);
			  call zeromatrix(bDbetag); 
		  	  ambetag[1,1] = mbetag[1,1];		  	 		/* eMKF v2.4: segment 1 intercept */ 	
		  	  aDbetag[1,1] = Dbetag[1,1];	
			  ambetag[2,1] = mbetag[2,1]; 					/* eMKF v2.4: segment 2 intercept */ 
		  	  aDbetag[2,2] = Dbetag[2,2];	
			  do m = 3 to &p;								/* eMKF v2.4: p must be ge 3 in common_* cases */
				  bmbetag[m-2, 1] = mbetag[m,1];
			      bDbetag[m-2, m-2] = Dbetag[m,m];	
			  end;
		  %end;

		  &initlines1a;;									/* eMKF v2.4: initialize intercepts for segment 1 */
		  &initlines2a;;									/* eMKF v2.4: initialize intercepts for segment 2 */
		  &initlineb1;;										/* initialize linear coefficients (if applicable) */
		  &initlineb2;;										/* initialize quad coefficients (if applicable) */	
		  &initlineb3;;										/* initialize cubic coefficients (if applicable) */

          %do _i = 1 %to &g; 
		      &&initetamnarr&_i;;						    /* initialize conditional mean for true states  */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /********************/
	  /* UDS declarations */
	  /********************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  &sbparline2;;											/* SD hyper-parameters (if any) */
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			*    dg[k] = nu[k]**&n;
			*    do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			*    end;
			*    if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;

	  	  &hplinesb1;;						 	 			/* SD hyper-priors in the full_linear, full_quad, and full_cubic cases */
	  	  &hplinesb2;;						 	 			/* SD hyper-priors in the full_quad and full_cubic cases */
	  	  &hplinesb3;;						 	 			/* SD hyper-prior in the full_cubic case */
	      &hplinemb1;;						 	 			/* Mean hyper-priors in the full_linear, full_quad, and full_cubic cases */
	  	  &hplinemb2;;						 	 			/* Mean hyper-priors in the full_quad and full_cubic cases */	
      	  &hplinemb3;; 						 	 			/* Mean hyper-prior in the full_cubic case */
		  %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then	
		  	  prior mbetag Dbetag ~ general(0);;			/* pseudo-parameters mbetag and Dbetag do no contribute to prior */
	  	  &plines1a;; 							 			/* eMKF v2.4: prior for intercepts in segment 1 */
	  	  &plines2a;; 							 			/* eMKF v2.4: prior for intercepts in segment 2 */
	  	  &plineb1;;							 			/* prior for linear coefficients (if those were requested) */
	  	  &plineb2;;							 			/* prior for quadratic coefficients (if those were requested) */
	  	  &plineb3;;							 			/* prior for cubic coefficients (if those were requested) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		  	  lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;

		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= etamn: Log: spsi mpsi &tauparline &psiparline
				    	%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; ) 
			&blog(keep = spsi mpsi)
      ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: &tauparline psi
				    	%if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: tau psi
				       %if %upcase(&btype) in FULL_CUBIC FULL_QUAD FULL_LINEAR %then mbetag: Dbetag: ; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF v2.4: order columns by segment and group */
	data _blogc2_;
  	  retain  Iteration 
			  %do _i=1 %to &g;
				  s1ag&_i s2ag&_i
				  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then b1g&_i;
				  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then b1g&_i b2g&_i;
				  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then b1g&_i b2g&_i b3g&_i;
			  %end;
			  %if %upcase(&btype) = COMMON_LINEAR %then b1 ; 
			  %if %upcase(&btype) = COMMON_QUAD   %then b1 b2 ; 
			  %if %upcase(&btype) = COMMON_CUBIC  %then b1 b2 b3 ; 
	  ;
	  set &blog(keep = Iteration s1a: s2a: %if &p > 2 %then b: ;);
	run;

	/* eMKF: block diagonal by group */
	%let oPPmat = ; %let _i = 0;
	%do _i = 1 %to &g; 
		%if &_i = 1 %then %let oPPmat = block( oP ;
		%if &_i > 1 and &_i < &g %then %let oPPmat = &oPPmat , block ( oP ;
		%if &_i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let oPPmat = &oPPmat );
	%end;

	%let _i = 0;

	/* eMKF: call proc iml to perform matrix multiplication */
	proc iml;
		use _oPmat_;
		read all into oP; close _oPmat_;
		oP = oP[1:&p, 1:&p];
		oPP = &oPPmat;;
		/* eMKF: re-structure block matrix in the common trend cases (where &p > 2) */
		/* eMKF v2.4: over-hauled restructuring due to two columns of intercepts */
		%if %upcase(&btype) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
			/* sorted index vector */
			undP = do(1, &g*&p, &p) || do(2, &g*&p, &p);
			sndP = undP;									
			sndP[,rank(sndP)] = undP; 
			/* square matrix involving intercepts only */
			oPP1 = oPP[sndP, sndP];
			/* last row to append */
			oPP2 = oPP[sndP, do(3, &g*&p, &p)];
			vPP2 = oPP2[1:2, 1];
			%if &g > 1 %then %do;
				%do i = 1 %to &g-1;
					vPP2 = vPP2 // oPP2[(1+2*&i):(2*(1+&i)), 1+&i];
				%end;
			%end;
			oPP1 = oPP1 // T(vPP2);
			/* last column to append */
			oPP2 = oPP[do(3, &g*&p, &p), sndP];
			TvPP2 = oPP2[1, 1:2];
			%if &g > 1 %then %do;
				%do i = 1 %to &g-1;
					TvPP2 = TvPP2 || oPP2[1+&i, (1+2*&i):(2*(1+&i))];
				%end;
			%end;
			oPP0 = T(TvPP2);
			/* quadratic terms if applicable */
			%if &p > 3 %then %do;
				oPP3 = oPP[sndP, do(4, &g*&p, &p)];
				vPP3 = oPP3[1:2, 1];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						vPP3 = vPP3 // oPP3[(1+2*&i):(2*(1+&i)), 1+&i];
					%end;
				%end;
				oPP1 = oPP1 // T(vPP3);
				oPP3 = oPP[do(4, &g*&p, &p), sndP];
				TvPP3 = oPP3[1, 1:2];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						TvPP3 = TvPP3 || oPP3[1+&i, (1+2*&i):(2*(1+&i))];
					%end;
				%end;
				oPP0 = oPP0 || T(TvPP3);
			%end;
			/* cubic terms if applicable */
			%if &p > 4 %then %do;
				oPP4 = oPP[sndP, do(5, &g*&p, &p)];
				vPP4 = oPP4[1:2, 1];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						vPP4 = vPP4 // oPP4[(1+2*&i):(2*(1+&i)), 1+&i];
					%end;
				%end;
				oPP1 = oPP1 // T(vPP4);
				oPP4 = oPP[do(5, &g*&p, &p), sndP];
				TvPP4 = oPP4[1, 1:2];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						TvPP4 = TvPP4 || oPP4[1+&i, (1+2*&i):(2*(1+&i))];
					%end;
				%end;
				oPP0 = oPP0 || T(TvPP4);
			%end;
			/* combine all into single restructured matrix */
			oPP0 = oPP0 // oPP[3:&p, 3:&p];
			oPP = oPP1 || oPP0;
		%end;
		varNames = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames = varNames || {"s1ag&_i"} || {"s2ag&_i"};
		  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then varNames = varNames || {"b1g&_i"};;
		  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then varNames = varNames || {"b1g&_i"} || {"b2g&_i"};;
		  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then varNames = varNames || {"b1g&_i"} || {"b2g&_i"} || {"b3g&_i"};;
		%end;
		%if %upcase(&btype) = COMMON_LINEAR %then varNames = varNames || {"b1"};;
		%if %upcase(&btype) = COMMON_QUAD   %then varNames = varNames || {"b1" "b2"};;
		%if %upcase(&btype) = COMMON_CUBIC  %then varNames = varNames || {"b1" "b2" "b3"};;
		use _blogc2_;
		read all into oB;
		close _blogc2_;
		oB1 = oB[,1];
		oB = oB[,2:ncol(oB)];
		oBB = oPP * T(oB);
		oBB = oB1 || T(oBB);
		create _tblogc2_ var varNames;
		append from oBB;
		close _tblogc2_;
	quit;

	/* eMKF v2.4: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration s1ag1-s1ag&g s2ag1-s2ag&g  
			  %if %upcase(&btype) in FULL_LINEAR INDEP_LINEAR %then b1g1-b1g&g ; 
			  %if %upcase(&btype) in FULL_QUAD INDEP_QUAD %then b1g1-b1g&g b2g1-b2g&g ; 
			  %if %upcase(&btype) in FULL_CUBIC INDEP_CUBIC %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g ; 
			  %if %upcase(&btype) = COMMON_LINEAR %then b1 ; 
			  %if %upcase(&btype) = COMMON_QUAD   %then b1 b2 ; 
			  %if %upcase(&btype) = COMMON_CUBIC  %then b1 b2 b3 ; 
	  ;
	  set _tblogc2_;
	run;

	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then sb: mb: ;)
	        _tblogc_
			&blog(drop = %if %upcase(&btype) in FULL_LINEAR FULL_QUAD FULL_CUBIC %then sb: mb: ;
						 s1a: s2a: %if &p > 2 %then b: ; )
	  ;
	  by Iteration;
	run;

%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bfreqs1n_ _bfreqs2n_ _bbjunk _oXmat_ _oPmat_ _tblogc_ _tblogc2_ _blogc2_;
run ;
quit;

%mend bayesfitxptl;

data _null_;
run;

/* BAYESFITxptf macro
 Version of BAYESFIT macro for eMKF v2.4 to allow full break in trend.

 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 s1btype , s2btype  : full_cubic, full_quad, full_linear, indep_cubic, indep_quad, indep_linear, common_cubic, common_quad, common_linear, or dropped
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 bxpt				: value of timepoint at which trend break occurs.
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar (default)if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior; 
					  common_arh (new in eMKF 2.3) if AR correlation is common but variance parameters are independent.
 bslicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling step 
					  Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression if borpoly=YES.
 s1bmalpha,s1bpalpha: prior mean and precision for intercepts in segment 1
 s1bmbeta1,s1bpbeta1: prior mean and precision for mean linear coefficient(s) across groups in segment 1
 s1bmbeta2,s1bpbeta2: prior mean and precision for mean quadratic coefficient(s) across groups in segment 1
 s1bmbeta3,s1bpbeta3: prior mean and precision for mean cubic coefficient(s) across groups in segment 1
 s1bbeta1l,s1bbeta1u: bounds for U(a,b) prior for SD of linear coefficients across groups in segment 1 -- only used for hyperprior(s) in full_cubic, full_quad, or full_linear
 s1bbeta2l,s1bbeta2u: bounds for U(a,b) prior for SD of quadratic coefficients across groups in segment 1 -- only used for hyperprior(s) in full_cubic or full_quad
 s1bbeta3l,s1bbeta3u: bounds for U(a,b) prior for SD of cubic coefficients across groups in segment 1 -- only used for hyperprior(s) in full_cubic
 s2bmalpha,s2bpalpha: prior mean and precision for intercepts in segment 2
 s2bmbeta1,s2bpbeta1: prior mean and precision for mean linear coefficient(s) across groups in segment 2
 s2bmbeta2,s2bpbeta2: prior mean and precision for mean quadratic coefficient(s) across groups in segment 2
 s2bmbeta3,s2bpbeta3: prior mean and precision for mean cubic coefficient(s) across groups in segment 2
 s2bbeta1l,s2bbeta1u: bounds for U(a,b) prior for SD of linear coefficients across groups in segment 2 -- only used for hyperprior(s) in full_cubic, full_quad, or full_linear
 s2bbeta2l,s2bbeta2u: bounds for U(a,b) prior for SD of quadratic coefficients across groups in segment 2 -- only used for hyperprior(s) in full_cubic or full_quad
 s2bbeta3l,s2bbeta3u: bounds for U(a,b) prior for SD of cubic coefficients across groups in segment 2 -- only used for hyperprior(s) in full_cubic
 bmrho, bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul, btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of the CMP library (usually set in parent macro mkf)

*/
%macro bayesfitxptf(
             bdata	= , 
			 blog	= ,
			 s1btype = full_linear, s2btype = full_linear, 
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time,
			 bxpt   = , 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of parent mkf macro. 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values */
			 s1bmalpha  = , s1bpalpha= ,
			 s2bmalpha  = , s2bpalpha= ,
			 s1bmbeta1  = 0,  s1bpbeta1  = ,    /* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 s2bmbeta1  = 0,  s2bpbeta1  = ,
			 s1bmbeta2  = 0,  s1bpbeta2  = ,
			 s2bmbeta2  = 0,  s2bpbeta2  = ,
			 s1bmbeta3  = 0,  s1bpbeta3  = ,
			 s2bmbeta3  = 0,  s2bpbeta3  = ,
			 s1bbeta1l  = 0,  s1bbeta1u  = ,	/* eMKF: bbeta1l is Constant c5 in RAND's MKF User's Guide */
			 s2bbeta1l  = 0,  s2bbeta1u  = ,
			 s1bbeta2l  = 0,  s1bbeta2u  = ,
			 s2bbeta2l  = 0,  s2bbeta2u  = ,
			 s1bbeta3l  = 0,  s1bbeta3u  = ,
			 s2bbeta3l  = 0,  s2bbeta3u  = ,
             bmrho    = 0,  bprho    = 1,		/* eMKF: bmrho is c9 and bprho is c10 in RAND's MKF User's Guide */
			 btaul    = 0.0001,	btauu= ,  		/* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape  = ,   bvscale  = ,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc = work.funcs
             ) / minoperator;  /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local g n s1n s2n s1p s2p s1d s2d brtm s1brtm s2brtm _brtimess _s1brtimess _s2brtimess brangeY s1brangeY s2brangeY bqrangeV bmedianV formatted dsop dscl _i _j s1oPPmat s2oPPmat
	   s1bflag1 s1bflag2 s1bflag3 s1bflag4 s1bflag5 s1bflag6 s1bflag7 s1bflag1f s1bflag2f s1bflag3f 
	   s2bflag1 s2bflag2 s2bflag3 s2bflag4 s2bflag5 s2bflag6 s2bflag7 s2bflag1f s2bflag2f s2bflag3f 
       s1b1line s1b2line s1b3line s2b1line s2b2line s2b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline
       parline s1aparline s2aparline vparline s1mbparline s1sbparline s2mbparline s2sbparline udsparline tauparline2 psiparline2 s1sbparline2 s2sbparline2
       plines1a plines1b1 plines1b2 plines1b3 plines2a plines2b1 plines2b2 plines2b3 plinev plinetau plinepsi bslice
       hplines1mb1 hplines1sb1 hplines1mb2 hplines1sb2 hplines1mb3 hplines1sb3 hplines2mb1 hplines2sb1 hplines2mb2 hplines2sb2 hplines2mb3 hplines2sb3 hplinempsi hplinespsi
	   initlines1a initlines1b1 initlines1b2 initlines1b3 initlines2a initlines2b1 initlines2b2 initlines2b3 initlinevarr initlinetau initlinepsi
	   initlines1mb1 initlines1mb2 initlines1mb3 initlines1sb1 initlines1sb2 initlines1sb3 initlines2mb1 initlines2mb2 initlines2mb3 initlines2sb1 initlines2sb2 initlines2sb3
       monitorline optionline udsline rcXline rcNline inits1mbeta inits2mbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformatXPT(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, xpt=&bxpt, randomVars=&brndvars, outformat=_bbdata_ );
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1*/
%let s1n=0;
data _bfreqs1n_;
run;
proc freq data=_bbdata_ noprint;
  tables _s1rtime /list out=_bfreqs1n_;
run;
data _bfreqs1n_;
  set _bfreqs1n_(where=(_s1rtime ne 0));
  _s1tm + 1;
  call symput('s1n',_s1tm);
  keep _s1tm _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2*/
%let s2n=0;
data _bfreqs2n_;
run;
proc freq data=_bbdata_ noprint;
  tables _s2rtime /list out=_bfreqs2n_;
run;
data _bfreqs2n_;
  set _bfreqs2n_(where=(_s2rtime ne 0));
  _s2tm + 1;
  call symput('s2n',_s2tm);
  keep _s2tm _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _bfreqs2n_;
  set _bfreqs2n_;
  _s2tm = _s2tm + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 1 only */
%let _s1brtimess = ;
data _bfreqs1n_;
  set _bfreqs1n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s1rtime);
  else _rts = catx(" ", _rts, _s1rtime);
  call symput('_s1brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 2 only */
%let _s2brtimess = ;
data _bfreqs2n_;
  set _bfreqs2n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s2rtime);
  else _rts = catx(" ", _rts, _s2rtime);
  call symput('_s2brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: variables that will be used for real times in case timepoints are irregular */
%let brtm =_rtime; %let s1brtm=_s1rtime;  %let s2brtm=_s2rtime;

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure model types have been specified */
%if &s1btype = %str() or &s2btype = %str() %then %do;
	%put ERROR: Models must be specified for both segments. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: set model flags to use instead of repeated string matching */
%let s1bflag1=0; %let s1bflag2=0; %let s1bflag3=0; %let s1bflag4=0; %let s1bflag5=0; %let s1bflag6=0; %let s1bflag7=0; %let s1bflag1f=0; %let s1bflag2f=0; %let s1bflag3f=0; 
%if %upcase(&s1btype) = FULL_CUBIC    %then %let s1bflag1f = 1;
%if %upcase(&s1btype) = FULL_QUAD     %then %let s1bflag2f = 1;
%if %upcase(&s1btype) = FULL_LINEAR   %then %let s1bflag3f = 1;
%if %upcase(&s1btype) = INDEP_CUBIC   %then %let s1bflag1  = 1;
%if %upcase(&s1btype) = INDEP_QUAD    %then %let s1bflag2  = 1;
%if %upcase(&s1btype) = INDEP_LINEAR  %then %let s1bflag3  = 1;
%if %upcase(&s1btype) = COMMON_CUBIC  %then %let s1bflag4  = 1;
%if %upcase(&s1btype) = COMMON_QUAD   %then %let s1bflag5  = 1;
%if %upcase(&s1btype) = COMMON_LINEAR %then %let s1bflag6  = 1;
%if %upcase(&s1btype) = DROPPED 	  %then %let s1bflag7  = 1;
%let s2bflag1=0; %let s2bflag2=0; %let s2bflag3=0; %let s2bflag4=0; %let s2bflag5=0; %let s2bflag6=0; %let s2bflag7=0; %let s2bflag1f=0; %let s2bflag2f=0; %let s2bflag3f=0; 
%if %upcase(&s2btype) = FULL_CUBIC    %then %let s2bflag1f = 1;
%if %upcase(&s2btype) = FULL_QUAD     %then %let s2bflag2f = 1;
%if %upcase(&s2btype) = FULL_LINEAR   %then %let s2bflag3f = 1;
%if %upcase(&s2btype) = INDEP_CUBIC   %then %let s2bflag1  = 1;
%if %upcase(&s2btype) = INDEP_QUAD    %then %let s2bflag2  = 1;
%if %upcase(&s2btype) = INDEP_LINEAR  %then %let s2bflag3  = 1;
%if %upcase(&s2btype) = COMMON_CUBIC  %then %let s2bflag4  = 1;
%if %upcase(&s2btype) = COMMON_QUAD   %then %let s2bflag5  = 1;
%if %upcase(&s2btype) = COMMON_LINEAR %then %let s2bflag6  = 1;
%if %upcase(&s2btype) = DROPPED 	  %then %let s2bflag7  = 1;

/* eMKF v2.4 streamlining: moved up definition of dimensionality s1p and s2p for easier referencing of various models instead of using labels */
%let s1p = 0; %let s2p = 0;
%if &s1bflag1f = 1 or &s1bflag1 = 1 or &s1bflag4 = 1 %then %let s1p = 4;
%if &s1bflag2f = 1 or &s1bflag2 = 1 or &s1bflag5 = 1 %then %let s1p = 3;
%if &s1bflag3f = 1 or &s1bflag3 = 1 or &s1bflag6 = 1 %then %let s1p = 2;
%if &s1bflag7 = 1 %then %let s1p = 1;
%if &s2bflag1f = 1 or &s2bflag1 = 1 or &s2bflag4 = 1 %then %let s2p = 4;
%if &s2bflag2f = 1 or &s2bflag2 = 1 or &s2bflag5 = 1 %then %let s2p = 3;
%if &s2bflag3f = 1 or &s2bflag3 = 1 or &s2bflag6 = 1 %then %let s2p = 2;
%if &s2bflag7 = 1 %then %let s2p = 1;
%let s1p = %eval(0+&s1p); %let s2p = %eval(0+&s2p);
 
/* eMKF v2.4: max polynomial ranks s1d-1 and s2d-1 to use in orpoly for segments 1 and 2 */
%let s1d = 0; %let s2d = 0;
%if &s1n > 4 %then %let s1d = 4;	/* cubic allowed in segment 1 */
%else %do;
	%if &s1n > 3 %then %let s1d = 3;	/* quad allowed in segment 1 */
	%else %do;
		%if &s1n > 2 %then %let s1d = 2;	/* linear allowed in segment 1 */
		%else %let s1d = 1;						/* intercepts-only model allowed in segment 1 */
	%end;
%end;
%if &s2n > 4 %then %let s2d = 4;	/* cubic allowed in segment 2 */
%else %do;
	%if &s2n > 3 %then %let s2d = 3;	/* quad allowed in segment 2 */
	%else %do;
		%if &s2n > 2 %then %let s2d = 2; 	/* linear allowed in segment 2 */
		%else %let s2d = 1;						/* intercepts-only model allowed in segment 2 */
	%end;
%end;
%let s1d = %eval(0+&s1d); %let s2d = %eval(0+&s2d); 

/* eMKF v2.4: Error check to make sure requested trend models can be fit */
%if (&s1p > &s1d) or (&s2p > &s2d) %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%if &s1p > &s1d %then %put ERROR- &s1btype was requested for segment 1: there are only enough data for a degree %eval(&s1d-1) polynomial.;; 
	%if &s2p > &s2d %then %put ERROR- &s2btype was requested for segment 2: there are only enough data for a degree %eval(&s2d-1) polynomial.;; 
  	%return;
%end;

/* eMKF v2.4: Error check to reduce model combinations */
%if &s2p > &s1p %then %do;
	%put ERROR: Please ensure polynomial trend for segment 2 does not have higher degree than for segment 1.;
	%put ERROR- &s2btype was requested for segment 2, yet only &s1btype was requested for segment 1.; 
  	%return;
%end;

/* eMKF v2.4: Error check to rule out combinations with intercept-only model in segment 2 */
%if &s2p = 1 and &s1p > 1 %then %do;
	%put ERROR: Intercepts-only model in segment 2 is only allowed when it is also specified for segment 1.;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure same model type is requested for both segments 1 and 2 */
%if ((&s1bflag1f = 1 or &s1bflag2f = 1 or &s1bflag3f = 1) and (&s2bflag1f = 0 and &s2bflag2f = 0 and &s2bflag3f = 0)) or
    ((&s1bflag1 = 1 or &s1bflag2 = 1 or &s1bflag3 = 1) and (&s2bflag1 = 0 and &s2bflag2 = 0 and &s2bflag3 = 0)) or
	((&s1bflag4 = 1 or &s1bflag5 = 1 or &s1bflag6 = 1) and (&s2bflag4 = 0 and &s2bflag5 = 0 and &s2bflag6 = 0)) or
	(&s1bflag7 = 1 and &s2bflag7 = 0) %then %do;
		%put ERROR: Models for segments 1 (&s1btype) and 2 (&s2btype) are incompatible or unsupported. Please review!;
  		%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  /* eMKF v2.4: segment 1 */
	  s1x = { &_s1brtimess };
	  s1x = T(s1x);										/* eMKF: column vector with real times */
	  %if &s1d = 1 %then s1oP = orpol(s1x, 1)[,1];;
	  %if &s1d > 1 %then s1oP = orpol(s1x, &s1d - 1);;	/* eMKF v2.4: orthonormal design matrix s1oP */
	  s1x0 = { %cnstss(1, &s1n) };
	  s1x0 = T(s1x0);
	  %if &s1n > 2 %then s1x1 = s1x;;
	  %if &s1n > 3 %then s1x2 = s1x#s1x1;;
	  %if &s1n > 4 %then s1x3 = s1x#s1x2;;
	  s1uP = s1x0;										
	  %if &s1n > 2 %then s1uP = s1uP || s1x1;;	
	  %if &s1n > 3 %then s1uP = s1uP || s1x2;;	
	  %if &s1n > 4 %then s1uP = s1uP || s1x3;;			/* eMKF v2.4: raw/unstandardized design matrix s1uP */
	  s1oP1 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,1];
      %if &s1n > 2 %then s1oP2 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,2];;
      %if &s1n > 3 %then s1oP3 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,3];;
      %if &s1n > 4 %then s1oP4 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,4];;
	  s1oPP = s1oP1;									
	  %if &s1n > 2 %then s1oPP = s1oPP || s1oP2;;
	  %if &s1n > 3 %then s1oPP = s1oPP || s1oP3;;
	  %if &s1n > 4 %then s1oPP = s1oPP || s1oP4;;		/* eMKF: right multiplication of s1uP with s1oPP produces s1oP */
	  s1oP = s1oP // j(&s2n, &s1d, 0);					/* eMKF v2.4: pad with zeroes */
      /* eMKF v2.4: segment 2 */
	  s2x = { &_s2brtimess };
	  s2x = T(s2x);
 	  %if &s2d = 1 %then s2oP = orpol(s2x, 1)[,1];;
 	  %if &s2d > 1 %then s2oP = orpol(s2x, &s2d - 1);;
	  s2x0 = { %cnstss(1, &s2n) };
	  s2x0 = T(s2x0);
	  %if &s2n > 2 %then s2x1 = s2x;;
	  %if &s2n > 3 %then s2x2 = s2x#s2x1;;
	  %if &s2n > 4 %then s2x3 = s2x#s2x2;;
	  s2uP = s2x0;	
	  %if &s2n > 2 %then s2uP = s2uP || s2x1;;	
	  %if &s2n > 3 %then s2uP = s2uP || s2x2;;	
	  %if &s2n > 4 %then s2uP = s2uP || s2x3;;	
	  s2oP1 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,1];
      %if &s2n > 2 %then s2oP2 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,2];;
      %if &s2n > 3 %then s2oP3 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,3];;
      %if &s2n > 4 %then s2oP4 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,4];;
	  s2oPP = s2oP1;
	  %if &s2n > 2 %then s2oPP = s2oPP || s2oP2;;
	  %if &s2n > 3 %then s2oPP = s2oPP || s2oP3;;
	  %if &s2n > 4 %then s2oPP = s2oPP || s2oP4;;
	  s2oP =  j(&s1n, &s2d, 0) // s2oP;
	  /* eMKF v2.4: off-diagonal blocks and full block matrix oPP */
      s1oPP = s1oPP // j(&s2d, &s1d, 0);
	  s2oPP = j(&s1d, &s2d, 0) // s2oPP;
	  oPP = s1oPP || s2oPP;	
	  /* eMKF v2.4: consecutive time indices and block matrix oP */
	  y = T(do(1, &s1n+&s2n, 1));
	  yP = y || s1oP || s2oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &s1d = 4 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 4 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 3 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 2 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0"} ] ;;
	  %if &s1d = 1 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 1 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 1 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 1 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &s1d = 4 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 4 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 3 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 2 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0"} ] ;;
	  %if &s1d = 1 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 1 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 1 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 1 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _bbdata_ */
	  set _bbdata_;
	  if &s1brtm > 0 then &s1brtm.0 = 1; else &s1brtm.0 = 0;
	  %if &s1d > 1 %then &s1brtm.1 = &s1brtm;;
	  %if &s1d > 2 %then &s1brtm.2 = &s1brtm**2;;
	  %if &s1d > 3 %then &s1brtm.3 = &s1brtm**3;;
	  if &s2brtm > 0 then &s2brtm.0 = 1; else &s2brtm.0 = 0;
	  %if &s2d > 1 %then &s2brtm.1 = &s2brtm;;
	  %if &s2d > 2 %then &s2brtm.2 = &s2brtm**2;;
	  %if &s2d > 3 %then &s2brtm.3 = &s2brtm**3;;
	run;
%end;

/* eMKF v2.4: Evaluate range of the data in each segment to use in setting prior parameters */
%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

%let s1brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s1brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s1brangeY", range);
run;
%let s1brangeY = %sysevalf(&s1brangeY + 0);

%let s2brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s2brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s2brangeY", range);
run;
%let s2brangeY = %sysevalf(&s2brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF v2.4: c1 in RAND's MKF User's Guide */
%if &s1bmalpha = %str() %then %let s1bmalpha = %sysevalf(0.5 * &s1brangeY);;
%if &s2bmalpha = %str() %then %let s2bmalpha = %sysevalf(0.5 * &s2brangeY);;

/* eMKF v2.4: 1/c2 in RAND's MKF User's Guide */	
%if &s1bpalpha = %str() %then %let s1bpalpha = %sysevalf(0.000001/(&s1brangeY**2));;
%if &s2bpalpha = %str() %then %let s2bpalpha = %sysevalf(0.000001/(&s2brangeY**2));;

/* eMKF v2.4: c3 or c7 in RAND's MKF User's Guide */
%if &s1bmbeta1 = %str() %then %let s1bmbeta1 = %sysevalf(0);;
%if &s2bmbeta1 = %str() %then %let s2bmbeta1 = %sysevalf(0);;

/* eMKF v2.4: 1/c4 in RAND's MKF User's Guide */ 
%if &s1bflag1f = 1 or &s1bflag2f = 1 or &s1bflag3f = 1 %then %if &s1bpbeta1 = %str() %then %let s1bpbeta1  = %sysevalf(10/(&s1brangeY**2));;;
%if &s2bflag1f = 1 or &s2bflag2f = 1 or &s2bflag3f = 1 %then %if &s2bpbeta1 = %str() %then %let s2bpbeta1  = %sysevalf(10/(&s2brangeY**2));;;

/* eMKF v2.4: 1/c8 in RAND's MKF User's Guide */	
%if &s1bflag1f = 0 and &s1bflag2f = 0 and &s1bflag3f = 0 %then %if &s1bpbeta1 = %str() %then %let s1bpbeta1  = %sysevalf(0.000001/(&s1brangeY**2));;;
%if &s2bflag1f = 0 and &s2bflag2f = 0 and &s2bflag3f = 0 %then %if &s2bpbeta1 = %str() %then %let s2bpbeta1  = %sysevalf(0.000001/(&s2brangeY**2));;;

/* eMKF v2.4: c5 in RAND's MKF User's Guide  */
%if &s1bbeta1l = %str() %then %let s1bbeta1l = %sysevalf(0);;
%if &s2bbeta1l = %str() %then %let s2bbeta1l = %sysevalf(0);;						

/* eMKF v2.4: c6 in RAND's MKF User's Guide  */	
%if &s1bbeta1u = %str() %then %let s1bbeta1u = %sysevalf(0.5 * &s1brangeY);;	
%if &s2bbeta1u = %str() %then %let s2bbeta1u = %sysevalf(0.5 * &s2brangeY);;	

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho = %str() %then %let bmrho = %sysevalf(0);;	

/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho = %str() %then %let bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul = %str() %then %let btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu = %str() %then %let btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF v2.4: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &s1bmbeta2 = %str() %then %let s1bmbeta2 = %sysevalf(0);; 
%if &s2bmbeta2 = %str() %then %let s2bmbeta2 = %sysevalf(0);; 
%if &s1bpbeta2 = %str() %then %let s1bpbeta2 = %sysevalf(2.0 * &s1bpbeta1);; 
%if &s2bpbeta2 = %str() %then %let s2bpbeta2 = %sysevalf(2.0 * &s2bpbeta1);; 
%if &s1bmbeta3 = %str() %then %let s1bmbeta3 = %sysevalf(0);; 	
%if &s2bmbeta3 = %str() %then %let s2bmbeta3 = %sysevalf(0);; 	
%if &s1bpbeta3 = %str() %then %let s1bpbeta3 = %sysevalf(4.0 * &s1bpbeta1);; 		
%if &s2bpbeta3 = %str() %then %let s2bpbeta3 = %sysevalf(4.0 * &s2bpbeta1);; 		
%if &s1bbeta2l = %str() %then %let s1bbeta2l = %sysevalf(0);; 						
%if &s2bbeta2l = %str() %then %let s2bbeta2l = %sysevalf(0);; 						
%if &s1bbeta2u = %str() %then %let s1bbeta2u = %sysevalf(1.5 * &s1bbeta1u);;
%if &s2bbeta2u = %str() %then %let s2bbeta2u = %sysevalf(1.5 * &s2bbeta1u);;
%if &s1bbeta3l = %str() %then %let s1bbeta3l = %sysevalf(0);; 	
%if &s2bbeta3l = %str() %then %let s2bbeta3l = %sysevalf(0);; 	
%if &s1bbeta3u = %str() %then %let s1bbeta3u = %sysevalf(2.0 * &s1bbeta1u);; 
%if &s2bbeta3u = %str() %then %let s2bbeta3u = %sysevalf(2.0 * &s2bbeta1u);; 

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF v2.4: Named 1-dimensional arrays of regression parameters other than intercept (if any) for segments 1 and 2 */
%let s1b1line=; %let s1b2line=; %let s1b3line=; %let s2b1line=; %let s2b2line=; %let s2b3line=; 
%if &s1bflag1f=1 or &s1bflag1=1 or &s1bflag2f=1 or &s1bflag2=1 or &s1bflag3f=1 or &s1bflag3=1 %then %let s1b1line = array s1b1g[&g] s1b1g1-s1b1g&g ;
%if &s1bflag1f=1 or &s1bflag1=1 or &s1bflag2f=1 or &s1bflag2=1 								  %then %let s1b2line = array s1b2g[&g] s1b2g1-s1b2g&g ;
%if &s1bflag1f=1 or &s1bflag1=1 															  %then %let s1b3line = array s1b3g[&g] s1b3g1-s1b3g&g ;
%if &s2bflag1f=1 or &s2bflag1=1 or &s2bflag2f=1 or &s2bflag2=1 or &s2bflag3f=1 or &s2bflag3=1 %then %let s2b1line = array s2b1g[&g] s2b1g1-s2b1g&g ;
%if &s2bflag1f=1 or &s2bflag1=1 or &s2bflag2f=1 or &s2bflag2=1								  %then %let s2b2line = array s2b2g[&g] s2b2g1-s2b2g&g ;
%if &s2bflag1f=1 or &s2bflag1=1 															  %then %let s2b3line = array s2b3g[&g] s2b3g1-s2b3g&g ;

/* eMKF v2.4: Constant arrays of hyperparameters to pass to UDS (fully Bayesian setting only) for segments 1 and 2 */
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then %let s1b1line = &s1b1line%str(;) array s1mb1hyp[2] (&s1bmbeta1 &s1bpbeta1) ;
%if &s1bflag1f=1 or &s1bflag2f=1 				 %then %let s1b2line = &s1b2line%str(;) array s1mb2hyp[2] (&s1bmbeta2 &s1bpbeta2) ;
%if &s1bflag1f=1 								 %then %let s1b3line = &s1b3line%str(;) array s1mb3hyp[2] (&s1bmbeta3 &s1bpbeta3) ;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then %let s2b1line = &s2b1line%str(;) array s2mb1hyp[2] (&s2bmbeta1 &s2bpbeta1) ;
%if &s2bflag1f=1 or &s2bflag2f=1 				 %then %let s2b2line = &s2b2line%str(;) array s2mb2hyp[2] (&s2bmbeta2 &s2bpbeta2) ;
%if &s2bflag1f=1 								 %then %let s2b3line = &s2b3line%str(;) array s2mb3hyp[2] (&s2bmbeta3 &s2bpbeta3) ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means 
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to selected parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF v2.4: Hyper-parameters in the full Bayesian models for segments 1 and 2 */
%let s1mbparline=; %let s1sbparline=; %let s1sbparline2=;
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then %do;
	%let s1mbparline = &s1mbparline s1mb1 ;
	%let s1sbparline = &s1sbparline s1sb1 ;
	%let s1sbparline2 = &s1sbparline2 parms s1sb1 &bslice;
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 %then %do;
	%let s1mbparline = &s1mbparline s1mb2 ;
	%let s1sbparline = &s1sbparline s1sb2 ;
	%let s1sbparline2 = &s1sbparline2 parms s1sb2 &bslice;
%end;
%if &s1bflag1f=1 %then %do;
	%let s1mbparline = &s1mbparline s1mb3 ;
	%let s1sbparline = &s1sbparline s1sb3 ;
	%let s1sbparline2 = &s1sbparline2 parms s1sb3 &bslice;
%end;
%let s2mbparline=; %let s2sbparline=; %let s2sbparline2=;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then %do;
	%let s2mbparline = &s2mbparline s2mb1 ;
	%let s2sbparline = &s2sbparline s2sb1 ;
	%let s2sbparline2 = &s2sbparline2 parms s2sb1 &bslice;
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 %then %do;
	%let s2mbparline = &s2mbparline s2mb2 ;
	%let s2sbparline = &s2sbparline s2sb2 ;
	%let s2sbparline2 = &s2sbparline2 parms s2sb2 &bslice;
%end;
%if &s2bflag1f=1 %then %do;
	%let s2mbparline = &s2mbparline s2mb3 ;
	%let s2sbparline = &s2sbparline s2sb3 ;
	%let s2sbparline2 = &s2sbparline2 parms s2sb3 &bslice;
%end;

/* eMKF v2.4: Combined regression coefficients for segments 1 and 2 */
%let parline =;

/* eMKF v2.4: Segment 1 intercepts */
%let s1aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s1aparline = &s1aparline s1ag&_i ; 
%end; 

/* eMKF v2.4: Linear, quadratic, and cubic coefficients, as needed for segment 1 */
%let parline = &parline &s1aparline;
%let _i = 0;
%if &s1bflag1f=1 or &s1bflag1=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i s1b2g&_i s1b3g&_i ;
	%end;
%end;
%if &s1bflag2f=1 or &s1bflag2=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i s1b2g&_i ;
	%end;
%end;
%if &s1bflag3f=1 or &s1bflag3=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i ;
	%end;
%end;
%if &s1bflag4=1 %then %let parline = &parline s1b1 s1b2 s1b3 ;
%if &s1bflag5=1 %then %let parline = &parline s1b1 s1b2 ;
%if &s1bflag6=1 %then %let parline = &parline s1b1 ;

/* eMKF v2.4: Segment 2 intercepts */
%let s2aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s2aparline = &s2aparline s2ag&_i ; 
%end; 

/* eMKF v2.4: Linear, quadratic, and cubic coefficients, as needed for segment 2 */
%let parline = &parline &s2aparline;
%let _i = 0;
%if &s2bflag1f=1 or &s2bflag1=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i s2b2g&_i s2b3g&_i ;
	%end;
%end;
%if &s2bflag2f=1 or &s2bflag2=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i s2b2g&_i ;
	%end;
%end;
%if &s2bflag3f=1 or &s2bflag3=1 %then %do;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i ;
	%end;
%end;
%if &s2bflag4=1 %then %let parline = &parline s2b1 s2b2 s2b3 ;
%if &s2bflag5=1 %then %let parline = &parline s2b1 s2b2 ;
%if &s2bflag6=1 %then %let parline = &parline s2b1 ;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* eMKF v2.4: mbetag and Dbetag updated with the hyper-parameters in the fully Bayesian models */
/* Recall that the possibility of a fully Bayesian model in segment 1 but not 2 (or vice versa) has been ruled out at the start of this macro */
%if &s1mbparline ^= %str() and &s2mbparline ^= %str() %then %let udsparline = &udsparline parms &s1mbparline &s2mbparline mbetag Dbetag %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF v2.4: Hyper-prior specification in the full Bayesian models for segment 1 */
%let hplines1mb1=; %let hplines1mb2=; %let hplines1mb3=; %let hplines1sb1=; %let hplines1sb2=; %let hplines1sb3=;
%if &s1bflag1f=1 %then %do;
	%let hplines1sb3 = hyperprior s1sb3 ~ uniform(&s1bbeta3l, &s1bbeta3u);
	%let hplines1mb3 = hyperprior s1mb3 ~ normal(&s1bmbeta3, prec=&s1bpbeta3);
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 %then %do;
	%let hplines1sb2 = hyperprior s1sb2 ~ uniform(&s1bbeta2l, &s1bbeta2u);
	%let hplines1mb2 = hyperprior s1mb2 ~ normal(&s1bmbeta2, prec=&s1bpbeta2);
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then %do;
	%let hplines1sb1 = hyperprior s1sb1 ~ uniform(&s1bbeta1l, &s1bbeta1u);
	%let hplines1mb1 = hyperprior s1mb1 ~ normal(&s1bmbeta1, prec=&s1bpbeta1); 
%end;

/* eMKF v2.4: Hyper-prior specification in the full Bayesian models for segment 2 */
%let hplines2mb1=; %let hplines2mb2=; %let hplines2mb3=; %let hplines2sb1=; %let hplines2sb2=; %let hplines2sb3=;
%if &s2bflag1f=1 %then %do;
	%let hplines2sb3 = hyperprior s2sb3 ~ uniform(&s2bbeta3l, &s2bbeta3u);
	%let hplines2mb3 = hyperprior s2mb3 ~ normal(&s2bmbeta3, prec=&s2bpbeta3);
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 %then %do;
	%let hplines2sb2 = hyperprior s2sb2 ~ uniform(&s2bbeta2l, &s2bbeta2u);
	%let hplines2mb2 = hyperprior s2mb2 ~ normal(&s2bmbeta2, prec=&s2bpbeta2);
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then %do;
	%let hplines2sb1 = hyperprior s2sb1 ~ uniform(&s2bbeta1l, &s2bbeta1u);
	%let hplines2mb1 = hyperprior s2mb1 ~ normal(&s2bmbeta1, prec=&s2bpbeta1); 
%end;

/* eMKF v2.4: Priors for intercepts and regression parameters other than intercepts in segment 1 */
%let plines1a = prior &s1aparline ~ normal(&s1bmalpha, prec=&s1bpalpha);
%let plines1b1=; %let plines1b2=; %let plines1b3=;
%if &s1bflag1=1 %then
	%let plines1b3 = prior s1b3g: ~ normal(&s1bmbeta3, prec=&s1bpbeta3);
%if &s1bflag1=1 or &s1bflag2=1 %then 
	%let plines1b2 = prior s1b2g: ~ normal(&s1bmbeta2, prec=&s1bpbeta2);
%if &s1bflag1=1 or &s1bflag2=1 or &s1bflag3=1 %then 
	%let plines1b1 = prior s1b1g: ~ normal(&s1bmbeta1, prec=&s1bpbeta1);
%if &s1bflag4=1 %then 
	%let plines1b3 = prior s1b3 ~ normal(&s1bmbeta3, prec=&s1bpbeta3);
%if &s1bflag4=1 or &s1bflag5=1 %then 
	%let plines1b2 = prior s1b2 ~ normal(&s1bmbeta2, prec=&s1bpbeta2);
%if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then 
	%let plines1b1 = prior s1b1 ~ normal(&s1bmbeta1, prec=&s1bpbeta1);
%if &s1bflag1f=1 %then 
	%let plines1b3 = prior s1b3g: ~ normal(s1mb3, sd=s1sb3);
%if &s1bflag1f=1 or &s1bflag2f=1 %then 
	%let plines1b2 = prior s1b2g: ~ normal(s1mb2, sd=s1sb2);
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then
	%let plines1b1 = prior s1b1g: ~ normal(s1mb1, sd=s1sb1);

/* eMKF v2.4: Priors for intercepts and regression parameters other than intercepts in segment 2 */
%let plines2a = prior &s2aparline ~ normal(&s2bmalpha, prec=&s2bpalpha);
%let plines2b1=; %let plines2b2=; %let plines2b3=;
%if &s2bflag1=1 %then
	%let plines2b3 = prior s2b3g: ~ normal(&s2bmbeta3, prec=&s2bpbeta3);
%if &s2bflag1=1 or &s2bflag2=1 %then 
	%let plines2b2 = prior s2b2g: ~ normal(&s2bmbeta2, prec=&s2bpbeta2);
%if &s2bflag1=1 or &s2bflag2=1 or &s2bflag3=1 %then 
	%let plines2b1 = prior s2b1g: ~ normal(&s2bmbeta1, prec=&s2bpbeta1);
%if &s2bflag4=1 %then 
	%let plines2b3 = prior s2b3 ~ normal(&s2bmbeta3, prec=&s2bpbeta3);
%if &s2bflag4=1 or &s2bflag5=1 %then 
	%let plines2b2 = prior s2b2 ~ normal(&s2bmbeta2, prec=&s2bpbeta2);
%if &s2bflag4=1 or &s2bflag5=1 or &s2bflag6=1 %then 
	%let plines2b1 = prior s2b1 ~ normal(&s2bmbeta1, prec=&s2bpbeta1);
%if &s2bflag1f=1 %then 
	%let plines2b3 = prior s2b3g: ~ normal(s2mb3, sd=s2sb3);
%if &s2bflag1f=1 or &s2bflag2f=1 %then 
	%let plines2b2 = prior s2b2g: ~ normal(s2mb2, sd=s2sb2);
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then
	%let plines2b1 = prior s2b1g: ~ normal(s2mb1, sd=s2sb1);

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF v2.4: Initial values for regression hyper-parameters in the fully Bayesian models for segment 1 */
%let initlines1mb1=; %let initlines1mb2=; %let initlines1mb3=; %let initlines1sb1=; %let initlines1sb2=; %let initlines1sb3=;
%if &s1bflag1f=1 %then %do;
	%let initlines1sb3 = s1sb3 = rand('uniform', &s1bbeta3l, &s1bbeta3u);
	%let initlines1mb3 = s1mb3 = &s1bmbeta3 + sqrt(1/&s1bpbeta3)*rand('normal') ;
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 %then %do;
	%let initlines1sb2 = s1sb2 = rand('uniform', &s1bbeta2l, &s1bbeta2u);
	%let initlines1mb2 = s1mb2 = &s1bmbeta2 + sqrt(1/&s1bpbeta2)*rand('normal') ;
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then %do;
	%let initlines1sb1 = s1sb1 = rand('uniform', &s1bbeta1l, &s1bbeta1u);
	%let initlines1mb1 = s1mb1 = &s1bmbeta1 + sqrt(1/&s1bpbeta1)*rand('normal') ;
%end;

/* eMKF v2.4: Initial values for regression hyper-parameters in the fully Bayesian models for segment 2 */
%let initlines2mb1=; %let initlines2mb2=; %let initlines2mb3=; %let initlines2sb1=; %let initlines2sb2=; %let initlines2sb3=;
%if &s2bflag1f=1 %then %do;
	%let initlines2sb3 = s2sb3 = rand('uniform', &s2bbeta3l, &s2bbeta3u);
	%let initlines2mb3 = s2mb3 = &s2bmbeta3 + sqrt(1/&s2bpbeta3)*rand('normal') ;
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 %then %do;
	%let initlines2sb2 = s2sb2 = rand('uniform', &s2bbeta2l, &s2bbeta2u);
	%let initlines2mb2 = s2mb2 = &s2bmbeta2 + sqrt(1/&s2bpbeta2)*rand('normal') ;
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then %do;
	%let initlines2sb1 = s2sb1 = rand('uniform', &s2bbeta1l, &s2bbeta1u);
	%let initlines2mb1 = s2mb1 = &s2bmbeta1 + sqrt(1/&s2bpbeta1)*rand('normal') ;
%end;

/* eMKF v2.4: Initial values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
/* eMKF v2.4: In models other than the fully Bayesian trend models, mbetag and Dbetag are constants */
/* eMKF v2.4: In fully Bayesian models, mbetag and Dbetag depend on model parameters and are updated accordingly */
/* eMKF v2.4: note change in dimensionality */
%let initmbeta = call zeromatrix(Dbetag);	

/* eMKF v2.4: segment 1 */
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &s1bmalpha%str(;) Dbetag[1,1] = &s1bpalpha;
%if &s1bflag1=1 or &s1bflag4=1 or &s1bflag2=1 or &s1bflag5=1 or &s1bflag3=1 or &s1bflag6=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s1bmbeta1%str(;) Dbetag[2,2] = &s1bpbeta1;
%if &s1bflag1=1 or &s1bflag4=1 or &s1bflag2=1 or &s1bflag5=1 
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = &s1bmbeta2%str(;) Dbetag[3,3] = &s1bpbeta2;
%if &s1bflag1=1 or &s1bflag4=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = &s1bmbeta3%str(;) Dbetag[4,4] = &s1bpbeta3;
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 
	%then %let initmbeta = &initmbeta%str(;) mbetag[2,1] = s1mb1%str(;) Dbetag[2,2] = 1/s1sb1**2;
%if &s1bflag1f=1 or &s1bflag2f=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[3,1] = s1mb2%str(;) Dbetag[3,3] = 1/s1sb2**2;
%if &s1bflag1f=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[4,1] = s1mb3%str(;) Dbetag[4,4] = 1/s1sb3**2;

/* eMKF v2.4: segment 2 */
%let initmbeta = &initmbeta%str(;) mbetag[1+&s1p,1] = &s2bmalpha%str(;) Dbetag[1+&s1p,1+&s1p] = &s2bpalpha;
%if &s2bflag1=1 or &s2bflag4=1 or &s2bflag2=1 or &s2bflag5=1 or &s2bflag3=1 or &s2bflag6=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[2+&s1p,1] = &s2bmbeta1%str(;) Dbetag[2+&s1p,2+&s1p] = &s2bpbeta1;
%if &s2bflag1=1 or &s2bflag4=1 or &s2bflag2=1 or &s2bflag5=1 
	%then %let initmbeta = &initmbeta%str(;) mbetag[3+&s1p,1] = &s2bmbeta2%str(;) Dbetag[3+&s1p,3+&s1p] = &s2bpbeta2;
%if &s2bflag1=1 or &s2bflag4=1 
	%then %let initmbeta = &initmbeta%str(;) mbetag[4+&s1p,1] = &s2bmbeta3%str(;) Dbetag[4+&s1p,4+&s1p] = &s2bpbeta3;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 
	%then %let initmbeta = &initmbeta%str(;) mbetag[2+&s1p,1] = s2mb1%str(;) Dbetag[2+&s1p,2+&s1p] = 1/s2sb1**2;
%if &s2bflag1f=1 or &s2bflag2f=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[3+&s1p,1] = s2mb2%str(;) Dbetag[3+&s1p,3+&s1p] = 1/s2sb2**2;
%if &s2bflag1f=1
	%then %let initmbeta = &initmbeta%str(;) mbetag[4+&s1p,1] = s2mb3%str(;) Dbetag[4+&s1p,4+&s1p] = 1/s2sb3**2;

/* eMKF v2.4: Initial values for intercepts and regression parameters in segment 1 */
%let initlines1a=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlines1a = &initlines1a s1ag&_i = &s1bmalpha+sqrt(1/&s1bpalpha)*rand('normal')%str(;) ;
%end;
%let initlines1b1=; %let initlines1b2=; %let initlines1b3=; %let _i=0;
%if &s1bflag1f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b3 = &initlines1b3 s1b3g&_i=s1mb3+s1sb3*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b2 = &initlines1b2 s1b2g&_i=s1mb2+s1sb2*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b1 = &initlines1b1 s1b1g&_i=s1mb1+s1sb1*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag1=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b3 = &initlines1b3 s1b3g&_i=&s1bmbeta3+sqrt(1/&s1bpbeta3)*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag1=1 or &s1bflag2=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b2 = &initlines1b2 s1b2g&_i=&s1bmbeta2+sqrt(1/&s1bpbeta2)*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag1=1 or &s1bflag2=1 or &s1bflag3=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines1b1 = &initlines1b1 s1b1g&_i=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
	%end;
%end;
%if &s1bflag4=1 %then
	%let initlines1b3 = s1b3 = &s1bmbeta3 + sqrt(1/&s1bpbeta3)*rand('normal') ;
%if &s1bflag4=1 or &s1bflag5=1 %then
	%let initlines1b2 = s1b2 = &s1bmbeta2 + sqrt(1/&s1bpbeta2)*rand('normal') ;
%if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then
	%let initlines1b1 = s1b1 = &s1bmbeta1 + sqrt(1/&s1bpbeta1)*rand('normal') ;

/* eMKF v2.4: Initial values for intercepts and regression parameters in segment 2 */
%let initlines2a=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlines2a = &initlines2a s2ag&_i = &s2bmalpha+sqrt(1/&s2bpalpha)*rand('normal')%str(;) ;
%end;
%let initlines2b1=; %let initlines2b2=; %let initlines2b3=; %let _i=0;
%if &s2bflag1f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b3 = &initlines2b3 s2b3g&_i=s2mb3+s2sb3*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b2 = &initlines2b2 s2b2g&_i=s2mb2+s2sb2*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag1f=1 or &s2bflag2f=1 or &s2bflag3f=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b1 = &initlines2b1 s2b1g&_i=s2mb1+s2sb1*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag1=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b3 = &initlines2b3 s2b3g&_i=&s2bmbeta3+sqrt(1/&s2bpbeta3)*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag1=1 or &s2bflag2=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b2 = &initlines2b2 s2b2g&_i=&s2bmbeta2+sqrt(1/&s2bpbeta2)*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag1=1 or &s2bflag2=1 or &s2bflag3=1 %then %do;
	%do _i = 1 %to &g; 
		%let initlines2b1 = &initlines2b1 s2b1g&_i=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
	%end;
%end;
%if &s2bflag4=1 %then
	%let initlines2b3 = s2b3 = &s2bmbeta3 + sqrt(1/&s2bpbeta3)*rand('normal') ;
%if &s2bflag4=1 or &s2bflag5=1 %then
	%let initlines2b2 = s2b2 = &s2bmbeta2 + sqrt(1/&s2bpbeta2)*rand('normal') ;
%if &s2bflag4=1 or &s2bflag5=1 or &s2bflag6=1 %then
	%let initlines2b1 = s2b1 = &s2bmbeta1 + sqrt(1/&s2bpbeta1)*rand('normal') ;

/* eMKF v2.4: Initial values for unobserved true states predictions given regression parameters */
/* eMKF v2.4: To keep length of macro variable under control, calculations are split up by segment here */

%let _i = 0; %let _j = 0; /* Segment 1 */
%if &s1bflag1f=1 or &s1bflag1=1 %then %do;
    %do _i = 1 %to &g; 
	    %local inits1etamnarr&_i;   /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	    %do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i+X[&_j,3]*s1b2g&_i+X[&_j,4]*s1b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if &s1bflag2f=1 or &s1bflag2=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	  		%let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i+X[&_j,3]*s1b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if &s1bflag3f=1 or &s1bflag3=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
			%let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i%str(;) ;
		%end;
	%end;
%end;
%if &s1bflag4=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1+X[&_j,3]*s1b2+X[&_j,4]*s1b3%str(;) ;
		%end;
	%end;
%end;
%if &s1bflag5=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1+X[&_j,3]*s1b2%str(;) ;
		%end;
	%end;
%end;
%if &s1bflag6=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1%str(;) ;
		%end;
	%end;
%end;
%if &s1bflag7=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i%str(;) ;
		%end;
	%end;
%end;
%let _i = 0; %let _j = 0; /* Segment 2 */
%if &s2bflag1f=1 or &s2bflag1=1 %then %do;
    %do _i = 1 %to &g; 
	    %local inits2etamnarr&_i;  
  	    %do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i+X[&_j,3+&s1p]*s2b2g&_i+X[&_j,4+&s1p]*s2b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if &s2bflag2f=1 or &s2bflag2=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	  		%let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i+X[&_j,3+&s1p]*s2b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if &s2bflag3f=1 or &s2bflag3=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
			%let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i%str(;) ;
		%end;
	%end;
%end;
%if &s2bflag4=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1+X[&_j,3+&s1p]*s2b2+X[&_j,4+&s1p]*s2b3%str(;) ;
		%end;
	%end;
%end;
%if &s2bflag5=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1+X[&_j,3+&s1p]*s2b2%str(;) ;
		%end;
	%end;
%end;
%if &s2bflag6=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1%str(;) ;
		%end;
	%end;
%end;
%if &s2bflag7=1 %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
/* eMKF v2.4: modified to allow for segment-specific intercepts */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &s1brtm.0 %if &s1d > 1 %then &s1brtm.1; %if &s1d > 2 %then &s1brtm.2; %if &s1d > 3 %then &s1brtm.3; 
  	   &s2brtm.0 %if &s2d > 1 %then &s2brtm.1; %if &s2d > 2 %then &s2brtm.2; %if &s2d > 3 %then &s2brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
/* eMKF v2.4: note change in dimensionality */
%let rcXline = ;
%if &s1p = 1 and &s2p = 1 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s2brtm.0'));
%if &s1p = 2 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s2brtm.0'),resolve('&s2brtm.1'));
%if &s1p = 3 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s2brtm.0'),resolve('&s2brtm.1'));
%if &s1p = 3 and &s2p = 3 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s2brtm.0'),resolve('&s2brtm.1'), resolve('&s2brtm.2'));
%if &s1p = 4 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'));
%if &s1p = 4 and &s2p = 3 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'), resolve('&s2brtm.2'));
%if &s1p = 4 and &s2p = 4 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'), resolve('&s2brtm.2'), resolve('&s2brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions */
/*       These will be applied in the order defined here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ; 

/* eMKF v2.4: UDS statement for mean hyper-parameters in fully Bayesian models (if applicable), revised for increased dimension */
/* The pseudo-parameters mbetag and Dbetag are also updated in those UDS subroutines */
/* Note that the sb1-sb3 are updated via the M-H sampler, which is applied before the UDS per SAS documentation */
%if &s1bflag1f=1 and &s2bflag1f=1 %then
	%let udsline = &udsline uds MP_xptf_bfc_bfc(s1mb1, s1mb2, s1mb3, s2mb1, s2mb2, s2mb3, mbetag, Dbetag, s1b1g, s1b2g, s1b3g, s2b1g, s2b2g, s2b3g, 
												s1mb1hyp, s1mb2hyp, s1mb3hyp, s2mb1hyp, s2mb2hyp, s2mb3hyp, s1sb1, s1sb2, s1sb3, s2sb1, s2sb2, s2sb3)%str(;) ;
%if &s1bflag1f=1 and &s2bflag2f=1 %then
	%let udsline = &udsline uds MP_xptf_bfc_bfq(s1mb1, s1mb2, s1mb3, s2mb1, s2mb2, mbetag, Dbetag, s1b1g, s1b2g, s1b3g, s2b1g, s2b2g, 
												s1mb1hyp, s1mb2hyp, s1mb3hyp, s2mb1hyp, s2mb2hyp, s1sb1, s1sb2, s1sb3, s2sb1, s2sb2)%str(;) ;
%if &s1bflag1f=1 and &s2bflag3f=1 %then
	%let udsline = &udsline uds MP_xptf_bfc_bfl(s1mb1, s1mb2, s1mb3, s2mb1, mbetag, Dbetag, s1b1g, s1b2g, s1b3g, s2b1g, 
												s1mb1hyp, s1mb2hyp, s1mb3hyp, s2mb1hyp, s1sb1, s1sb2, s1sb3, s2sb1)%str(;) ;
%if &s1bflag2f=1 and &s2bflag2f=1 %then
	%let udsline = &udsline uds MP_xptf_bfq_bfq(s1mb1, s1mb2, s2mb1, s2mb2, mbetag, Dbetag, s1b1g, s1b2g, s2b1g, s2b2g, 
												s1mb1hyp, s1mb2hyp, s2mb1hyp, s2mb2hyp, s1sb1, s1sb2, s2sb1, s2sb2)%str(;) ;
%if &s1bflag2f=1 and &s2bflag3f=1 %then
	%let udsline = &udsline uds MP_xptf_bfq_bfl(s1mb1, s1mb2, s2mb1, mbetag, Dbetag, s1b1g, s1b2g, s2b1g, 
												s1mb1hyp, s1mb2hyp, s2mb1hyp, s1sb1, s1sb2, s2sb1)%str(;) ;
%if &s1bflag3f=1 and &s2bflag3f=1 %then
	%let udsline = &udsline uds MP_xptf_bfl_bfl(s1mb1, s2mb1, mbetag, Dbetag, s1b1g, s2b1g, 
												s1mb1hyp, s2mb1hyp, s1sb1, s2sb1)%str(;) ;

/* eMKF v2.4: UDS statement for regression coefficients, revised to accomodate additional intercept for segment 2  */
/* The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if &s1bflag7=1 and &s2bflag7=1 %then
	%let udsline = &udsline uds CP_xptf_b0_b0(s1ag, s2ag, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

%if &s1bflag6=1 and &s2bflag6=1 %then
	%let udsline = &udsline uds CP_xptf_b1l_b1l(s1ag, s1b1, s2ag, s2b1, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if &s1bflag5=1 and &s2bflag6=1 %then
	%let udsline = &udsline uds CP_xptf_b1q_b1l(s1ag, s1b1, s1b2, s2ag, s2b1, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if &s1bflag5=1 and &s2bflag5=1 %then
	%let udsline = &udsline uds CP_xptf_b1q_b1q(s1ag, s1b1, s1b2, s2ag, s2b1, s2b2, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if &s1bflag4=1 and &s2bflag6=1 %then
	%let udsline = &udsline uds CP_xptf_b1c_b1l(s1ag, s1b1, s1b2, s1b3, s2ag, s2b1, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if &s1bflag4=1 and &s2bflag5=1 %then
	%let udsline = &udsline uds CP_xptf_b1c_b1q(s1ag, s1b1, s1b2, s1b3, s2ag, s2b1, s2b2, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;
%if &s1bflag4=1 and &s2bflag4=1 %then
	%let udsline = &udsline uds CP_xptf_b1c_b1c(s1ag, s1b1, s1b2, s1b3, s2ag, s2b1, s2b2, s2b3, etamnarr, ambetag, bmbetag, aDbetag, bDbetag, rhoarr, nuarr, rts, aX, bX, Yarr, Sarr)%str(;) ;

%if (&s1bflag3=1 or &s1bflag3f=1) and (&s2bflag3=1 or &s2bflag3f=1) %then
	%let udsline = &udsline uds CP_xptf_bgl_bgl(s1ag, s1b1g, s2ag, s2b1g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if (&s1bflag2=1 or &s1bflag2f=1) and (&s2bflag3=1 or &s2bflag3f=1) %then
	%let udsline = &udsline uds CP_xptf_bgq_bgl(s1ag, s1b1g, s1b2g, s2ag, s2b1g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if (&s1bflag2=1 or &s1bflag2f=1) and (&s2bflag2=1 or &s2bflag2f=1) %then
	%let udsline = &udsline uds CP_xptf_bgq_bgq(s1ag, s1b1g, s1b2g, s2ag, s2b1g, s2b2g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if (&s1bflag1=1 or &s1bflag1f=1) and (&s2bflag3=1 or &s2bflag3f=1) %then
	%let udsline = &udsline uds CP_xptf_bgc_bgl(s1ag, s1b1g, s1b2g, s1b3g, s2ag, s2b1g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if (&s1bflag1=1 or &s1bflag1f=1) and (&s2bflag2=1 or &s2bflag2f=1) %then
	%let udsline = &udsline uds CP_xptf_bgc_bgq(s1ag, s1b1g, s1b2g, s1b3g, s2ag, s2b1g, s2b2g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if (&s1bflag1=1 or &s1bflag1f=1) and (&s2bflag1=1 or &s2bflag1f=1) %then
	%let udsline = &udsline uds CP_xptf_bgc_bgc(s1ag, s1b1g, s1b2g, s1b3g, s2ag, s2b1g, s2b2g, s2b3g, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then 
	%let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%let monitorline = &s1sbparline &s2sbparline &s1mbparline &s2mbparline &parline etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;
proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, %eval(&s1p+&s2p)];						/* eMKF v2.4: design matrix to use in matrix multiplication */
	  array mbetag[%eval(&s1p+&s2p), 1];					/* eMKF v2.4: prior mean vector for betas (assumed common accross groups) */
	  array Dbetag[%eval(&s1p+&s2p), %eval(&s1p+&s2p)];		/* eMKF v2.4: diagonal prior precision matrix for betas (assumed common accross groups) */
	  %if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then %do;	/* conformal arrays used in UDS subroutines for common trend models */
		 array aX[&n, 2];									/* eMKF v2.4: design matrix now has two intercept columns */
		 array bX[&n, %eval(&s1p+&s2p-2)];					/* eMKF v2.4: design matrix (excl. two intercept columns) */
	  	 array ambetag[2, 1];								/* eMKF v2.4: hyper parameter vector (intercepts only) */
		 array bmbetag[%eval(&s1p+&s2p-2), 1];				/* eMKF v2.4: hyper parameter vector (excl. intercepts) */
		 array aDbetag[2, 2];								/* eMKF v2.4: hyper parameter matrix (intercepts only) */
		 array bDbetag[%eval(&s1p+&s2p-2),%eval(&s1p+&s2p-2)];/* eMKF v2.4: hyper parameter matrix (excl. intercepts) */
	  %end;
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  array s1ag[&g] s1ag1-s1ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 1 */
	  &s1b1line;;											/* eMKF v2.4: named 1-dimensional array of group-specific linear coefficients for segment 1 (if requested) */
 	  &s1b2line;;                     						/* eMKF v2.4: named 1-dimensional array of group-specific quad coefficients for segment 1 (if requested) */
	  &s1b3line;; 											/* eMKF v2.4: named 1-dimensional array of group-specific cubic coefficients for segment 1 (if requested) */
	  array s2ag[&g] s2ag1-s2ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 2 */
	  &s2b1line;;											/* eMKF v2.4: named 1-dimensional array of group-specific linear coefficients for segment 2 (if requested) */
 	  &s2b2line;;                     						/* eMKF v2.4: named 1-dimensional array of group-specific quad coefficients for segment 2 (if requested) */
	  &s2b3line;; 											/* eMKF v2.4: named 1-dimensional array of group-specific cubic coefficients for segment 2 (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
	 	  do i = 1 to &n;
		 	  do m = 1 to &s1p+&s2p;
				  X[i,m] = Xarr[i,m];						/* eMKF v2.4: Xarr remains a 2-dimensional array even in dropped case due to 2 intercept columns */
		  	  end;
	  	  end;
		  %if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then %do; /* conformal subarrays used in UDS subroutines for common trend models */
			  do i = 1 to &n;								
				  aX[i, 1] = X[i, 1];						/* eMKF v2.4: segment 1 intercept */
				  aX[i, 2] = X[i, &s1p+1];					/* eMKF v2.4: segment 2 intercept */
				  do m = 2 to &s1p;							/* eMKF v2.4: s1p must be ge 2 */
					  bX[i, m-1] = X[i, m];
				  end;
				  do m = &s1p+2 to &s1p+&s2p;				/* eMKF v2.4: s2p must be ge 2 */
					  bX[i, m-2] = X[i, m];
				  end;
			  end;
		  %end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k = 1 to &g;								/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initlines1sb1;;									/* eMKF v2.4: initialize SD hyperparameter sb1 for segment 1(if applicable) */
		  &initlines2sb1;;									/* eMKF v2.4: initialize SD hyperparameter sb1 for segment 1(if applicable) */
	  	  &initlines1sb2;;									/* eMKF v2.4: initialize SD hyperparameter sb2 for segment 1 (if applicable) */
	  	  &initlines2sb2;;									/* eMKF v2.4: initialize SD hyperparameter sb2 for segment 1 (if applicable) */
	  	  &initlines1sb3;;									/* eMKF v2.4: initialize SD hyperparameter sb3 for segment 1 (if applicable) */
	  	  &initlines2sb3;;									/* eMKF v2.4: initialize SD hyperparameter sb3 for segment 1 (if applicable) */
		  &initlines1mb1;;									/* eMKF v2.4: initialize mean hyperparameter mb1 for segment 1 (if applicable) */
		  &initlines2mb1;;									/* eMKF v2.4: initialize mean hyperparameter mb1 for segment 1 (if applicable) */
	  	  &initlines1mb2;;									/* eMKF v2.4: initialize mean hyperparameter mb2 for segment 1 (if applicable) */
	  	  &initlines2mb2;;									/* eMKF v2.4: initialize mean hyperparameter mb2 for segment 1 (if applicable) */
	  	  &initlines1mb3;;									/* eMKF v2.4: initialize mean hyperparameter mb3 for segment 1 (if applicable) */
	  	  &initlines2mb3;;									/* eMKF v2.4: initialize mean hyperparameter mb3 for segment 1 (if applicable) */
		  &initmbeta;;							 			/* initialize mbetag and Dbetag */
		  %if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then %do;	/* conformal subarrays used in UDS subroutines for common trend models */
			  call zeromatrix(aDbetag);
			  call zeromatrix(bDbetag); 
		  	  ambetag[1,1] = mbetag[1,1];		  	 		/* eMKF v2.4: segment 1 intercept */ 	
		  	  aDbetag[1,1] = Dbetag[1,1];	
			  ambetag[2,1] = mbetag[&s1p+1,1]; 				/* eMKF v2.4: segment 2 intercept */ 
		  	  aDbetag[2,2] = Dbetag[&s1p+1,&s1p+1];	
			  do m = 2 to &s1p;								/* eMKF v2.4: s1p must be ge 2 */
				  bmbetag[m-1, 1] = mbetag[m,1];
			      bDbetag[m-1, m-1] = Dbetag[m,m];	
			  end;
			  do m = &s1p+2 to &s1p+&s2p;					/* eMKF v2.4: s2p must be ge 2 */
				  bmbetag[m-2, 1] = mbetag[m,1];
			      bDbetag[m-2, m-2] = Dbetag[m,m];	
			  end;
		  %end;

		  &initlines1a;;									/* eMKF v2.4: initialize intercepts for segment 1 */
		  &initlines1b1;;									/* eMKF v2.4: initialize linear coefficients for segment 1 (if applicable) */
		  &initlines1b2;;									/* eMKF v2.4: initialize quad coefficients for segment 1 (if applicable) */	
		  &initlines1b3;;									/* eMKF v2.4: initialize cubic coefficients for segment 1 (if applicable) */
		  &initlines2a;;									/* eMKF v2.4: initialize intercepts for segment 2 */
		  &initlines2b1;;									/* eMKF v2.4: initialize linear coefficients for segment 1 (if applicable) */
		  &initlines2b2;;									/* eMKF v2.4: initialize quad coefficients for segment 1 (if applicable) */	
		  &initlines2b3;;									/* eMKF v2.4: initialize cubic coefficients for segment 1 (if applicable) */

          %do _i = 1 %to &g; 
		      &&inits1etamnarr&_i;;						    /* eMKF v2.4: initialize conditional mean for true states in segment 1 */ 
		      &&inits2etamnarr&_i;;						    /* eMKF v2.4: initialize conditional mean for true states in segment 2 */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /********************/
	  /* UDS declarations */
	  /********************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  &s1sbparline2;;										/* eMKF v2.4: SD hyper-parameters in segment 1 (if any) */
	  &s2sbparline2;;										/* eMKF v2.4: SD hyper-parameters in segment 2 (if any) */
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			 *   end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;

	  	  &hplines1sb1;;						 	 		/* eMKF v2.4: SD hyper-priors in the full_linear, full_quad, and full_cubic cases for segment 1 */
	  	  &hplines2sb1;;						 	 		/* eMKF v2.4: SD hyper-priors in the full_linear, full_quad, and full_cubic cases for segment 2 */
	  	  &hplines1sb2;;						 	 		/* eMKF v2.4: SD hyper-priors in the full_quad and full_cubic cases for segment 1 */
	  	  &hplines2sb2;;						 	 		/* eMKF v2.4: SD hyper-priors in the full_quad and full_cubic cases for segment 2 */
	  	  &hplines1sb3;;						 	 		/* eMKF v2.4: SD hyper-prior in the full_cubic case for segment 1 */
	  	  &hplines2sb3;;						 	 		/* eMKF v2.4: SD hyper-prior in the full_cubic case for segment 2 */
	      &hplines1mb1;;						 	 		/* eMKF v2.4: Mean hyper-priors in the full_linear, full_quad, and full_cubic cases for segment 1 */
	      &hplines2mb1;;						 	 		/* eMKF v2.4: Mean hyper-priors in the full_linear, full_quad, and full_cubic cases for segment 2 */
	  	  &hplines1mb2;;						 	 		/* eMKF v2.4: Mean hyper-priors in the full_quad and full_cubic cases for segment 1 */	
	  	  &hplines2mb2;;						 	 		/* eMKF v2.4: Mean hyper-priors in the full_quad and full_cubic cases for segment 2 */	
      	  &hplines1mb3;; 						 	 		/* eMKF v2.4: Mean hyper-prior in the full_cubic case for segment 1 */
      	  &hplines2mb3;; 						 	 		/* eMKF v2.4: Mean hyper-prior in the full_cubic case for segment 2 */
		  %if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then	
		  	  prior mbetag Dbetag ~ general(0);;			/* pseudo-parameters mbetag and Dbetag do no contribute to prior */
	  	  &plines1a;; 							 			/* eMKF v2.4: prior for intercepts in segment 1 */
	  	  &plines1b1;;							 			/* eMKF v2.4: prior for linear coefficients in segment 1 (if those were requested) */
	  	  &plines1b2;;							 			/* eMKF v2.4: prior for quadratic coefficients in segment 1 (if those were requested) */
	  	  &plines1b3;;							 			/* eMKF v2.4: prior for cubic coefficients in segment 1 (if those were requested) */
	  	  &plines2a;; 							 			/* eMKF v2.4: prior for intercepts in segment 2 */
	  	  &plines2b1;;							 			/* eMKF v2.4: prior for linear coefficients in segment 2 (if those were requested) */
	  	  &plines2b2;;							 			/* eMKF v2.4: prior for quadratic coefficients in segment 2 (if those were requested) */
	  	  &plines2b3;;							 			/* eMKF v2.4: prior for cubic coefficients in segment 2 (if those were requested) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		  	  lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;

		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= etamn: Log: spsi mpsi &tauparline &psiparline
				    	%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then mbetag: Dbetag: ; ) 
			&blog(keep = spsi mpsi)
      ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: &tauparline psi
				    	%if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then mbetag: Dbetag: ; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: tau psi
				       %if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then mbetag: Dbetag: ; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF v2.4: order columns by segment then by group */
    %if &s1bflag4 = 0 and &s1bflag5 = 0 and &s1bflag4 = 0 %then %do; /* eMKF v2.4: full or indep trend models */
		data _blogc2_;
  	  		retain Iteration 
			  %do _i=1 %to &g;
				  s1ag&_i
				  %if &s1bflag3f = 1 or &s1bflag3 = 1 %then s1b1g&_i;
				  %if &s1bflag2f = 1 or &s1bflag2 = 1 %then s1b1g&_i s1b2g&_i;
				  %if &s1bflag1f = 1 or &s1bflag1 = 1 %then s1b1g&_i s1b2g&_i s1b3g&_i;
			  %end;
			  %do _i=1 %to &g;
				  s2ag&_i
				  %if &s2bflag3f = 1 or &s2bflag3 = 1 %then s2b1g&_i;
				  %if &s2bflag2f = 1 or &s2bflag2 = 1 %then s2b1g&_i s2b2g&_i;
				  %if &s2bflag1f = 1 or &s2bflag1 = 1 %then s2b1g&_i s2b2g&_i s2b3g&_i;
			  %end;
	  		;
	  		set &blog(keep = Iteration s1a: %if &s1p > 1 %then s1b: ; s2a: %if &s2p > 1 %then s2b: ;);
		run;
	%end;
	%else %do;  /* eMKF v2.4: common trend models */
		data _blogc2_;
  	  		retain Iteration 
			  %do _i=1 %to &g; s1ag&_i %end;
			  %if &s1bflag6 = 1 %then s1b1 ; 
			  %if &s1bflag5 = 1 %then s1b1 s1b2 ; 
			  %if &s1bflag4 = 1 %then s1b1 s1b2 s1b3 ; 
			  %do _i=1 %to &g; s2ag&_i %end;
			  %if &s2bflag6 = 1 %then s2b1 ; 
			  %if &s2bflag5 = 1 %then s2b1 s2b2 ; 
			  %if &s2bflag4 = 1 %then s2b1 s2b2 s2b3 ; 
	  		;
	  		set &blog(keep = Iteration s1a: %if &s1p > 1 %then s1b: ; s2a: %if &s2p > 1 %then s2b: ;);
		run;
	%end;

	/* eMKF v2.4: block diagonal by group modified to account for 2 segments */
	%let s1oPPmat = ; %let _i = 0; 	/* eMKF v2.4: block diagonal by group for segment 1 */
	%do _i=1 %to &g; 
		%if &_i = 1 %then %let s1oPPmat = block( s1oP ;
		%if &_i > 1 and &_i < &g %then %let s1oPPmat = &s1oPPmat , block ( s1oP ;
		%if &_i = &g and &g > 1  %then %let s1oPPmat = &s1oPPmat , s1oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let s1oPPmat = &s1oPPmat );
	%end;
	%let s2oPPmat = ; %let _i = 0;	/* eMKF v2.4: block diagonal by group for segment 2 */
	%do _i=1 %to &g;  
		%if &_i = 1 %then %let s2oPPmat = block( s2oP ;
		%if &_i > 1 and &_i < &g %then %let s2oPPmat = &s2oPPmat , block ( s2oP ;
		%if &_i = &g and &g > 1  %then %let s2oPPmat = &s2oPPmat , s2oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let s2oPPmat = &s2oPPmat );
	%end;

	%let _i = 0;

	/* eMKF v2.4: call to proc iml to perform matrix multiplication splits up segments 1 and 2 for matrix operation purposes */
	proc iml;

		/* eMKF 2.3: segment 1 */
		use _oPmat_;
		read all into s1oP; close _oPmat_;
		s1oP = s1oP[1:&s1p, 1:&s1p];
		s1oPP = &s1oPPmat;;

		/* eMKF 2.3: segment 2 */
		use _oPmat_;
		read all into s2oP; close _oPmat_;
		s2oP = s2oP[(1+&s1d):(&s1d+&s2p), (1+&s1d):(&s1d+&s2p)];
		s2oPP = &s2oPPmat;;

		/* eMKF v2.4: re-structure segment 1's block matrix in the common trend cases (where &s1p > 1) */
		%if &s1bflag4=1 or &s1bflag5=1 or &s1bflag6=1 %then %do;
			s1oPP1 = s1oPP[do(1, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)];
			s1oPP2 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(2, &g*&s1p, &s1p)]);
			s1ToPP2 = vecdiag(s1oPP[do(2, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
			s1oPP1 = s1oPP1 // T(s1ToPP2);
			s1oPP0 = s1oPP2;
			%if &s1p > 2 %then %do;
				s1oPP3 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(3, &g*&s1p, &s1p)]);
				s1ToPP3 = vecdiag(s1oPP[do(3, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
				s1oPP1 = s1oPP1 // T(s1ToPP3);
				s1oPP0 = s1oPP0 || s1oPP3;
			%end;
			%if &s1p > 3 %then %do;
				s1oPP4 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(4, &g*&s1p, &s1p)]);
				s1ToPP4 = vecdiag(s1oPP[do(4, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
				s1oPP1 = s1oPP1 // T(s1ToPP4);
				s1oPP0 = s1oPP0 || s1oPP4;
			%end;
			s1oPP0 = s1oPP0 // s1oPP[2:&s1p, 2:&s1p];
			s1oPP = s1oPP1 || s1oPP0;
		%end;

		/* eMKF 2.3: re-structure segment 2's block matrix in the common trend cases (where &s2p > 1) */
		%if &s2bflag4=1 or &s2bflag5=1 or &s2bflag6=1 %then %do;
			s2oPP1 = s2oPP[do(1, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)];
			s2oPP2 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(2, &g*&s2p, &s2p)]);
			s2ToPP2 = vecdiag(s2oPP[do(2, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
			s2oPP1 = s2oPP1 // T(s2ToPP2);
			s2oPP0 = s2oPP2;
			%if &s2p > 2 %then %do;
				s2oPP3 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(3, &g*&s2p, &s2p)]);
				s2ToPP3 = vecdiag(s2oPP[do(3, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
				s2oPP1 = s2oPP1 // T(s2ToPP3);
				s2oPP0 = s2oPP0 || s2oPP3;
			%end;
			%if &s2p > 3 %then %do;
				s2oPP4 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(4, &g*&s2p, &s2p)]);
				s2ToPP4 = vecdiag(s2oPP[do(4, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
				s2oPP1 = s2oPP1 // T(s2ToPP4);
				s2oPP0 = s2oPP0 || s2oPP4;
			%end;
			s2oPP0 = s2oPP0 // s2oPP[2:&s2p, 2:&s2p];
			s2oPP = s2oPP1 || s2oPP0;
		%end;

		/* eMKF v2.4: variable names for segment 1 */
		varNames1 = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames1 = varNames1 || {"s1ag&_i"};
		  %if &s1bflag3f = 1 or &s1bflag3 = 1 %then varNames1 = varNames1 || {"s1b1g&_i"};;
		  %if &s1bflag2f = 1 or &s1bflag2 = 1 %then varNames1 = varNames1 || {"s1b1g&_i"} || {"s1b2g&_i"};;
		  %if &s1bflag1f = 1 or &s1bflag1 = 1 %then varNames1 = varNames1 || {"s1b1g&_i"} || {"s1b2g&_i"} || {"s1b3g&_i"};;
		%end;
		%if &s1bflag6 = 1 %then varNames1 = varNames1 || {"s1b1"};;
		%if &s1bflag5 = 1 %then varNames1 = varNames1 || {"s1b1" "s1b2"};;
		%if &s1bflag4 = 1 %then varNames1 = varNames1 || {"s1b1" "s1b2" "s1b3"};;

		/* eMKF v2.4: variable names for segment 2 */
		varNames2 = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames2 = varNames2 || {"s2ag&_i"};
		  %if &s2bflag3f = 1 or &s2bflag3 = 1 %then varNames2 = varNames2 || {"s2b1g&_i"};;
		  %if &s2bflag2f = 1 or &s2bflag2 = 1 %then varNames2 = varNames2 || {"s2b1g&_i"} || {"s2b2g&_i"};;
		  %if &s2bflag1f = 1 or &s2bflag1 = 1 %then varNames2 = varNames2 || {"s2b1g&_i"} || {"s2b2g&_i"} || {"s2b3g&_i"};;
		%end;
		%if &s2bflag6 = 1 %then varNames2 = varNames2 || {"s2b1"};;
		%if &s2bflag5 = 1 %then varNames2 = varNames2 || {"s2b1" "s2b2"};;
		%if &s2bflag4 = 1 %then varNames2 = varNames2 || {"s2b1" "s2b2" "s2b3"};;

		/* eMKF v2.4: combined variable names for later use */
		varNames = varNames1 || varNames2[, 2:ncol(varNames2)];

		/* eMKF v2.4: apply orthogonal transformation separately for each segment then combine */
		/* segment 1 */
		use _blogc2_(keep= Iteration s1a: %if &s1p > 1 %then s1b: ;); 
		read all into s1oB; close _blogc2_;
		s1oB1 = s1oB[,1];
		s1oB = s1oB[,2:ncol(s1oB)];
		s1oBB = s1oPP * T(s1oB);
		/* segment 2 */
		use _blogc2_(keep= Iteration s2a: %if &s2p > 1 %then s2b: ;);
		read all into s2oB; close _blogc2_;
		s2oB1 = s2oB[,1];
		s2oB = s2oB[,2:ncol(s2oB)];
		s2oBB = s2oPP * T(s2oB);
		/* combined */
		oBB = s1oB1 || T(s1oBB) || T(s2oBB);
		create _tblogc2_ var varNames;
		append from oBB; close _tblogc2_;
	quit;

	/* eMKF v2.4: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration 
			  s1ag1-s1ag&g 
			  %if &s1bflag3f = 1 or &s1bflag3 = 1 %then s1b1g1-s1b1g&g ; 
			  %if &s1bflag2f = 1 or &s1bflag2 = 1 %then %do; %do _i = 1 %to &g; s1b1g&_i s1b2g&_i %end; %end;
			  %if &s1bflag1f = 1 or &s1bflag1 = 1 %then %do; %do _i = 1 %to &g; s1b1g&_i s1b2g&_i s1b3g&_i %end; %end;
			  %if &s1bflag6 = 1 %then s1b1 ; 
			  %if &s1bflag5 = 1 %then s1b1 s1b2 ; 
			  %if &s1bflag4 = 1 %then s1b1 s1b2 s1b3 ; 
			  s2ag1-s2ag&g  
			  %if &s2bflag3f = 1 or &s2bflag3 = 1 %then s2b1g1-s2b1g&g ; 
			  %if &s2bflag2f = 1 or &s2bflag2 = 1 %then %do; %do _i = 1 %to &g; s2b1g&_i s2b2g&_i %end; %end;
			  %if &s2bflag1f = 1 or &s2bflag1 = 1 %then %do; %do _i = 1 %to &g; s2b1g&_i s2b2g&_i s2b3g&_i %end; %end;
			  %if &s2bflag6 = 1 %then s2b1 ; 
			  %if &s2bflag5 = 1 %then s2b1 s2b2 ; 
			  %if &s2bflag4 = 1 %then s2b1 s2b2 s2b3 ; 
			  ;
	  set _tblogc2_;
	run;
	
	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration %if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then s1sb: s1mb: s2sb: s2mb: ;)
	        _tblogc_
			&blog(drop = %if &s1bflag1f=1 or &s1bflag2f=1 or &s1bflag3f=1 %then s1sb: s1mb: s2sb: s2mb: ;
						 s1a: %if &s1p > 1 %then s1b: ; s2a: %if &s2p > 1 %then s2b: ; )
	  ;
	  by Iteration;
	run;

%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bfreqs1n_ _bfreqs2n_ _bbjunk _oXmat_ _oPmat_ _tblogc_ _tblogc2_ _blogc2_;
run ;
quit;

%mend bayesfitxptf;

data _null_;
run;

/* eMKF: BAYESBMA -- Implements Bayesian model averaging via mixture prior approach -- 2023 Q2 by M. Talih
 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 btype              : bma_cubic, bma_quad, or bma_linear
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior
 bslicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling step 
					  Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression if borpoly=YES.
 bmalpha , bpalpha 	: prior mean and precision for intercepts
 bmbeta1 , bpbeta1	: prior mean and precision for mean linear coefficient(s) across groups
 bmbeta2 , bpbeta2	: prior mean and precision for mean quadratic coefficient(s) across groups
 bmbeta3 , bpbeta3  : prior mean and precision for mean cubic coefficient(s) across groups
					  [eMKF v2.4 streamlining: removed unused arguments bbeta1l, bbeta1u, bbeta2l, bbeta2u, bbeta3l, bbeta3u]
 bmrho, bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul, btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bdirichlet			: [eMKF v2.4 streamlining] Whether to use the Dirichlet prior for model weights (default = NO)
 bwshape			: Common shape parameter to use for Dirichlet prior on model indicators in mixture prior
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of CMP library (usually set in parent macro mkf)

*/
%macro bayesBMA(
             bdata	= , 
			 blog	= ,
			 btype	= bma_linear, 
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time, 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of %mkf(). 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values*/
			 bmalpha  = ,  bpalpha  = ,
			 bmbeta1  = 0, bpbeta1  = ,     /* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 bmbeta2  = 0, bpbeta2  = ,
			 bmbeta3  = 0, bpbeta3  = ,
             bmrho    = 0, bprho    = 1,	/* eMKF: Constants c9 and c10  in RAND's MKF User's Guide */
			 btaul    = 0.0001,	btauu  = ,  /* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape  = ,  bvscale  = ,
			 bdirichlet = NO,
			 bwshape  = 2,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc  = work.funcs
             ) / minoperator; /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */
 
%local g n p d brtm _brtimess brangeY bqrangeV bmedianV formatted dsop dscl _i _j _l _ll oPPmat
       b1line b2line b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline wtsline
       parline parline2 aparline vparline udsparline tauparline2 psiparline2 bslice
       plinea plineb1 plineb2 plineb3 plinev plinetau plinepsi plinewts plineflg hplinempsi hplinespsi
	   initlinea initlineb1 initlineb2 initlineb3 initlinevarr initlinetau initlinepsi initlinewts initlineflg
       monitorline optionline udsline rcXline rcNline initmbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformat(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, randomVars = &brndvars, outformat= _bbdata_);
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF: variable that will be used for real time in case times are irregular */
%let brtm  = _rtime;

/* eMKF v2.4 streamlining: Error check to make sure there are at least 2 timepoints */
%if &n < 2 %then %do;
	%put ERROR: bayesBMA macro requires at least 2 timepoints. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p = 1;
%if %upcase(&btype) = BMA_CUBIC  %then %let p = 4;
%if %upcase(&btype) = BMA_QUAD   %then %let p = 3;
%if %upcase(&btype) = BMA_LINEAR %then %let p = 2;
%let p = %eval(0+&p);

/* eMKF v2.4 streamlining: max polynomial rank d-1 to use in orpoly */
%let d = 1;
%if &n > 4 %then %let d = 4;	/* cubic allowed */
%else %do;
	%if &n > 3 %then %let d = 3;	/* quad allowed */
	%else %do;
		%if &n > 2 %then %let d = 2;	/* linear allowed */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4 streamlining: Error check to make sure requested trend models can be fit */
%if &p > &d or &p = 1 %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%put ERROR- Either &btype is not supported or there are only enough data for a degree %eval(&d-1) polynomial.; 
  	%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF: Modified to use orthogonal cubic polynomial design matrix */

data _oXmat_ _oPmat_;
run;

/* eMKF v2.4 streamlining: accounted for max polynomial degree in case of fewer timepoints than 5 */
%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  x = { &_brtimess };								/* eMKF v2.4 correction: use &_brtimess instead of &_rtimess */
	  x = T(x);											/* eMKF: column vector with real times */
	  %if &d = 1 %then oP = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP = orpol(x, &d - 1);;			/* eMKF v2.4: orthonormal design matrix oP */
	  x0 = { %cnstss(1, &n) };
	  x0 = T(x0);
	  %if &n > 2 %then x1 = x;;
	  %if &n > 3 %then x2 = x#x1;;
	  %if &n > 4 %then x3 = x#x2;;
	  uP = x0;										
	  %if &n > 2 %then uP = uP || x1;;	
	  %if &n > 3 %then uP = uP || x2;;	
	  %if &n > 4 %then uP = uP || x3;;					/* eMKF v2.4: raw/unstandardized design matrix uP */
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
      %if &n > 2 %then oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];;
      %if &n > 3 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &n > 4 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
	  oPP = oP1;									
	  %if &n > 2 %then oPP = oPP || oP2;;
	  %if &n > 3 %then oPP = oPP || oP3;;
	  %if &n > 4 %then oPP = oPP || oP4;;				/* eMKF: right multiplication of uP with oPP produces oP */
	  y = T(do(1, &n, 1));								/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1" "&brtm.2" "&brtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1" "&brtm.2"} ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0" "&brtm.1"} ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&brtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"t0"} ] ;;
	  append from oPP; close _oPmat_;	
    quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4 streamlining: Add raw predictor variables */
	  set _bbdata_;
	  &brtm.0 = 1;
	  %if &d > 1 %then &brtm.1 = &brtm;;
	  %if &d > 2 %then &brtm.2 = &brtm**2;;
	  %if &d > 3 %then &brtm.3 = &brtm**3;;
	run;
%end;

/* eMKF: Evaluate range of the data to use in setting prior parameters, as in MKF */
%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF: c1 in RAND's MKF User's Guide */
%if &bmalpha = %str() %then %let bmalpha = %sysevalf(0.5 * &brangeY);;

/* eMKF: 1/c2 in RAND's MKF User's Guide */	
%if &bpalpha = %str() %then %let bpalpha = %sysevalf(0.000001/(&brangeY**2));; 

/* eMKF: c7 in RAND's MKF User's Guide */
%if &bmbeta1 = %str() %then %let bmbeta1 = %sysevalf(0);;

/* eMKF: 1/c8 in RAND's MKF User's Guide */	
%if &bpbeta1  = %str() %then %let bpbeta1  = %sysevalf(0.000001/(&brangeY**2));;

/* eMKF v2.4: added check for negative value */
%if &bmrho  ^= %str() and &bmrho < 0 %then %do;
	%put WARNING: Prior mean &bmrho for transformed AR(1) correlation coefficient is expected to be positive.;
	%put WARNING- Its absolute value will be used instead.;
	%let bmrho = %sysevalf(- &bmrho);
%end;

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho    = %str() %then %let  bmrho  = %sysevalf(0);;	

/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho    = %str() %then %let  bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul    = %str() %then %let  btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu    = %str() %then %let  btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &bmbeta2 = %str() %then %let bmbeta2 = %sysevalf(0);; 
%if &bpbeta2 = %str() %then %let bpbeta2 = %sysevalf(2.0 * &bpbeta1);; 
%if &bmbeta3 = %str() %then %let bmbeta3 = %sysevalf(0);; 	
%if &bpbeta3 = %str() %then %let bpbeta3 = %sysevalf(4.0 * &bpbeta1);; 		

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF: Array structures for BMA weights and prior mixtures */
/* Recall: 1=indep_cubic, 2=indep_quad, 3=indep_linear, 4=common_cubic, 5=common_quad, 6=common_linear, 7=dropped */
%if &bwshape = %str() %then %let bwshape = %eval(2);; /* eMKF v2.4 streamlining: added default value in case parameter was left empty */
%let wtsline = ; 
%if %upcase(&btype) = BMA_CUBIC %then %do;		  /* eMKF v2.4 correction: used local bwshape instead of wshape from parent mkf macro */
	%let wtsline = &wtsline array wtsshape[7] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
	%let wtsline = &wtsline array wts[7]%str(;);  /*  model weights */
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let wtsline = &wtsline array wtsshape[5] (&bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
	%let wtsline = &wtsline array wts[5]%str(;);
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let wtsline = &wtsline array wtsshape[3] (&bwshape &bwshape &bwshape)%str(;) ;
	%let wtsline = &wtsline array wts[3]%str(;); 
%end;

/* eMKF: Named 1-dimensional arrays of regression parameters other than intercept */
%let b1line=; %let b2line=; %let b3line=; 
%if %upcase(&btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %let b1line = array b1g[&g] b1g1-b1g&g ;
%if %upcase(&btype) in BMA_CUBIC BMA_QUAD %then %let b2line = array b2g[&g] b2g1-b2g&g ;
%if %upcase(&btype) = BMA_CUBIC %then %let b3line = array b3g[&g] b3g1-b3g&g ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF: Intercepts */
%let aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let aparline = &aparline ag&_i ; 
%end; 

/* eMKF: Linear, quadratic, and cubic coefficients, as needed */
%let parline = &aparline; %let parline2 = &aparline; %let _i = 0;
%if %upcase(&btype) = BMA_CUBIC %then %do;
	%let parline = &parline b1 b2 b3;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i b3g&_i ;
		%let parline2 = &parline2 b1g&_i b2g&_i b3g&_i ;
	%end;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let parline = &parline b1 b2;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i ;
		%let parline2 = &parline2 b1g&_i b2g&_i ;
	%end;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let parline = &parline b1;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i ;
		%let parline2 = &parline2 b1g&_i ;
	%end;
%end;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* model flags updated in a separate UDS block */
%let udsparline = &udsparline parms flg %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF: Prior for mixture weights */
%let plinewts = ;
%if %upcase(&bdirichlet) = YES %then 
	%let plinewts = prior wts ~ dirichlet(wtsshape);

/* eMKF: Prior for latent variable flg */
%let plineflg = prior flg ~ table(wts);

/* eMKF: Prior for intercepts ag1 through ag&g */
%let plinea = prior &aparline ~ normal(&bmalpha, prec=&bpalpha);

/****************************************************************/
/* eMKF: Priors for regression parameters other than intercepts */
/****************************************************************/

%let plineb1=; %let plineb2=; %let plineb3=;

%if %upcase(&btype) = BMA_CUBIC %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=4 or flg=5 or flg=6 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 or flg=2 or flg=3 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=7 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if (flg=4 or flg=5 or flg=6) and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let plineb2 = &plineb2 if flg=4 or flg=5 then lpb2=lpb2+lpdfnorm(b2,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
	%let plineb2 = &plineb2 if flg=6 and %str(abs(b2)> %sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b2-mean(of b2g1-b2g&g))>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 prior b2 ~ general(lpb2)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb2 = &plineb2 if flg=1 or flg=2 then lpb2=lpb2+lpdfnorm(b2g&_i,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
		%let plineb2 = &plineb2 if (flg=3 or flg=7) and %str(abs(b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
		%let plineb2 = &plineb2 if (flg=4 or flg=5 or flg=6) and %str(abs(b2-b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb2 = &plineb2 prior b2g: ~ general(lpb2)%str(;);

	%let plineb3 = &plineb3 lpb3=0%str(;) ;
	%let plineb3 = &plineb3 if flg=4 then lpb3=lpb3+lpdfnorm(b3,&bmbeta3,sqrt(1/&bpbeta3))%str(;) ;
	%let plineb3 = &plineb3 if (flg=5 or flg=6) and %str(abs(b3)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%let plineb3 = &plineb3 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b3-mean(of b3g1-b3g&g))>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%let plineb3 = &plineb3 prior b3 ~ general(lpb3)%str(;);

	%let plineb3 = &plineb3 lpb3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb3 = &plineb3 if flg=1 then lpb3=lpb3+lpdfnorm(b3g&_i,&bmbeta3,sqrt(1/&bpbeta3))%str(;) ;
		%let plineb3 = &plineb3 if (flg=2 or flg=3 or flg=7) and %str(abs(b3g&_i)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
		%let plineb3 = &plineb3 if (flg=4 or flg=5 or flg=6) and %str(abs(b3-b3g&_i)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb3 = &plineb3 prior b3g: ~ general(lpb3)%str(;);

%end;
%if %upcase(&btype) = BMA_QUAD %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=3 or flg=4 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=2 or flg=5) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 or flg=2 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=5 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if (flg=3 or flg=4) and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let plineb2 = &plineb2 if flg=3 then lpb2=lpb2+lpdfnorm(b2,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
	%let plineb2 = &plineb2 if flg=4 and %str(abs(b2)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 if (flg=1 or flg=2 or flg=5) and %str(abs(b2-mean(of b2g1-b2g&g))>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 prior b2 ~ general(lpb2)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb2 = &plineb2 if flg=1 then lpb2=lpb2+lpdfnorm(b2g&_i,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
		%let plineb2 = &plineb2 if (flg=2 or flg=5) and %str(abs(b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
		%let plineb2 = &plineb2 if (flg=3 or flg=4) and %str(abs(b2-b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb2 = &plineb2 prior b2g: ~ general(lpb2)%str(;);

%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=2 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=3) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=3 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if flg=2 and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

%end;

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then 
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF: Dimensionality for do loops to initialize mixture parameters */
%let _ll=0;
%if %upcase(&btype) = BMA_CUBIC  %then %let _ll = 7;
%if %upcase(&btype) = BMA_QUAD 	 %then %let _ll = 5;
%if %upcase(&btype) = BMA_LINEAR %then %let _ll = 3;
%let _ll = %eval(0+&_ll);

/* eMKF: Initial values for mixture weights */
%let initlinewts = wtssum = 0%str(;) ; %let _l=0; 
%do _l=1 %to &_ll; 
	%if %upcase(&bdirichlet) = YES %then %do; /* eMKF v2.4 streamlining: Added explicit Dirichlet option */
		%let initlinewts = &initlinewts wts[&_l] = rand('gamma', wtsshape[&_l])%str(;) ;
	%end;
	%else %do;
		%let initlinewts = &initlinewts wts[&_l] = wtsshape[&_l]%str(;) ; 
	%end;
	%let initlinewts = &initlinewts wtssum = wtssum + wts[&_l]%str(;) ;
%end;

/* eMKF: Rescale wts to sum to one */
%let _l=0;
%do _l=1 %to &_ll;		
	%let initlinewts = &initlinewts wts[&_l] = wts[&_l]/wtssum%str(;) ;
%end;

/* eMKF: Initial values for latent variable flg */
%let initlineflg = ; %let _l=0;
%do _l=1 %to &_ll; 
	%let initlineflg = &initlineflg %str(,) wts[&_l]; 
%end;
%let initlineflg = flg = rand('table' &initlineflg);

/* eMKF: Initial/constant values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
%let initmbeta = call zeromatrix(Dbetag);	
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &bmalpha%str(;) Dbetag[1,1] = &bpalpha;
%if %upcase(&btype) = BMA_CUBIC %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &bmbeta1%str(;) Dbetag[2,2] = &bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta2%str(;) Dbetag[3,3] = &bpbeta2;
	%let initmbeta = &initmbeta%str(;) mbetag[4,1] = &bmbeta3%str(;) Dbetag[4,4] = &bpbeta3;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &bmbeta1%str(;) Dbetag[2,2] = &bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta2%str(;) Dbetag[3,3] = &bpbeta2;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &bmbeta1%str(;) Dbetag[2,2] = &bpbeta1;
%end;

/* eMKF: Initial values for intercepts */
%let initlinea=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlinea = &initlinea ag&_i = &bmalpha+sqrt(1/&bpalpha)*rand('normal')%str(;) ;
%end;

/*********************************************************************************/
/* eMKF: Initial values for regression parameters and applicable hyperparameters */
/*********************************************************************************/

%let initlineb1=; %let initlineb2=; %let initlineb3=; 

%if %upcase(&btype) = BMA_CUBIC %then %do;

	%let initlineb3 = &initlineb3 if flg=4 then b3=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
	%let initlineb3 = &initlineb3 if flg=5 or flg=6 then b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 if flg=1 then b3g&_i=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
		%let initlineb3 = &initlineb3 if flg=2 or flg=3 or flg=7 then b3g&_i=0%str(;) ;
		%let initlineb3 = &initlineb3 if flg=4 or flg=5 or flg=6 then b3g&_i=b3%str(;) ;
	%end;
	%let initlineb3 = &initlineb3 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b3=mean(of b3g1-b3g&g);) ;

	%let initlineb2 = &initlineb2 if flg=4 or flg=5 then b2=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%let initlineb2 = &initlineb2 if flg=6 then b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 if flg=1 or flg=2 then b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
		%let initlineb2 = &initlineb2 if flg=3 or flg=7 then b2g&_i=0%str(;) ;
		%let initlineb2 = &initlineb2 if flg=4 or flg=5 or flg=6 then b2g&_i=b2%str(;) ;
	%end;
	%let initlineb2 = &initlineb2 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b2= mean(of b2g1-b2g&g);) ;

	%let initlineb1 = &initlineb1 if flg=4 or flg=5 or flg=6 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 or flg=2 or flg=3 then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=7 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=4 or flg=5 or flg=6 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b1=mean(of b1g1-b1g&g);) ;

%end;
%if %upcase(&btype) = BMA_QUAD %then %do;

	%let initlineb2 = &initlineb2 if flg=3 then b2=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%let initlineb2 = &initlineb2 if flg=4 then b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 if flg=1 then b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
		%let initlineb2 = &initlineb2 if flg=2 or flg=5 then b2g&_i=0%str(;) ;
		%let initlineb2 = &initlineb2 if flg=3 or flg=4 then b2g&_i=b2%str(;) ;
	%end;
	%let initlineb2 = &initlineb2 %str(if flg=1 or flg=2 or flg=5 then b2=mean(of b2g1-b2g&g);) ;

	%let initlineb1 = &initlineb1 if flg=3 or flg=4 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 or flg=2  then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=5 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=3 or flg=4 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=2 or flg=5 then b1=mean(of b1g1-b1g&g);) ;

%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;

	%let initlineb1 = &initlineb1 if flg=2 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=3 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=2 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=3 then b1=mean(of b1g1-b1g&g);) ;

%end;

/* eMKF: Initial values for unobserved true states predictions given regression parameters */
%let _i = 0; %let _j = 0; 
%if %upcase(&btype) = BMA_CUBIC %then %do;
  %do _i = 1 %to &g; 
  	%local initetamnarr&_i; /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	%do _j = 1 %to &n; 
	  %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i+X[&_j,3]*b2g&_i+X[&_j,4]*b3g&_i%str(;) ;
    %end;
  %end;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%do _i = 1 %to &g; 
	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 																/* eMKF v2.4 correction to selected columns in X */
	  		%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i+X[&_j,3]*b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%do _i = 1 %to &g; 
	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
			%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*ag&_i+X[&_j,2]*b1g&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &brtm.0 %if &d > 1 %then &brtm.1; %if &d > 2 %then &brtm.2; %if &d > 3 %then &brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
%let rcXline = ;
%if &p = 2 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'));
%if &p = 3 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'));
%if &p = 4 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'), resolve('&brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions  */
/*      These will be applied in the order provided here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ;
 
/* eMKF: UDS statement for model flag */
%if %upcase(&btype) = BMA_CUBIC %then
	%let udsline = &udsline uds FP_bmac(flg, wts, ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = BMA_QUAD %then
	%let udsline = &udsline uds FP_bmaq(flg, wts, ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = BMA_LINEAR %then
	%let udsline = &udsline uds FP_bmal(flg, wts, ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for regression coefficients  */
/*      The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if %upcase(&btype) = BMA_CUBIC %then
	%let udsline = &udsline uds CP_bmac(ag, b1g, b2g, b3g, b1, b2, b3, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%if %upcase(&btype) = BMA_QUAD %then
	%let udsline = &udsline uds CP_bmaq(ag, b1g, b2g, b1, b2, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%if %upcase(&btype) = BMA_LINEAR %then
	%let udsline = &udsline uds CP_bmal(ag, b1g, b1, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then 
	%let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%if %upcase(&bdirichlet) = YES %then %let monitorline = wts;
%let monitorline = &monitorline flg &parline2 etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;

proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, &p];										/* design matrix to use in matrix multiplication */
	  array mbetag[&p, 1];									/* prior mean vector for betas (assumed common across groups) */
	  array Dbetag[&p, &p];									/* diagonal prior precision matrix for betas (assumed common across groups) */
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho  */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  &wtsline;;											/* mixture weights and model flags */
	  array ag[&g] ag1-ag&g;								/* named 1-dimensional array of group-specific intercepts */
	  &b1line;;												/* named 1-dimensional array of group-specific linear coefficients (if requested) */
 	  &b2line;;                     						/* named 1-dimensional array of group-specific quad coefficients (if requested) */
	  &b3line;; 											/* named 1-dimensional array of group-specific cubic coefficients (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array of group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
		  do i = 1 to &n;								    /* Xarr is a 2-dimensional array for p > 1 */
		  	  do m = 1 to &p;
				  X[i,m] = Xarr[i,m];						
			  end;
		  end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initmbeta;;							 			/* initialize constant vector mbetag and constant matrix Dbetag */

		  &initlinewts;;									/* initialize model weights and related arrays */
		  &initlineflg;;									/* initialize model flags */

		  &initlinea;;										/* initialize intercepts */
		  &initlineb1;;										/* initialize linear coefficients and related arrays (if applicable) */
		  &initlineb2;;										/* initialize quad coefficients and related arrays (if applicable) */	
		  &initlineb3;;										/* initialize cubic coefficients and related arrays (if applicable) */

          %do _i = 1 %to &g; 
		      &&initetamnarr&_i;;						    /* initialize conditional mean for true states  */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /*******************/
	  /* UDS declaration */
	  /*******************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  %if %upcase(&bdirichlet) = YES %then %do;				/* eMKF v2.4 streamlining: explicitly included dirichlet prior option */
		  parms wts &bslice; 								/* Dirichlet mixture weights */
	  %end;
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*    end;
			*    if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
 
		  %if %upcase(&bdirichlet) = YES %then %do;			/* eMKF v2.4 streamlining: explicitly included dirichlet prior option */
		      &plinewts;;									/* Dirichlet prior for model weights */
		  %end;
		  &plineflg;;										/* Discrete prior for model flag */

	  	  &plinea;; 							 			/* prior for intercepts */
	  	  &plineb1;;							 			/* conditional prior for linear coefficients given model flag (if applicable) */
	  	  &plineb2;;							 			/* conditional prior for quadratic coefficients given model flag (if applicable) */
	  	  &plineb3;;							 			/* conditional prior for cubic coefficients given model flag (if applicable) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		      lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;
		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= etamn: Log: spsi mpsi &tauparline &psiparline
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; ) 
			&blog(keep = spsi mpsi)
      ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: &tauparline psi
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
		set &blog(drop= etamn: Log: tau psi
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF: order columns by group */
	data _blogc2_;
  	  retain  Iteration 
			  %do _i=1 %to &g;
				  ag&_i
				  %if %upcase(&btype) = BMA_LINEAR %then b1g&_i;
				  %if %upcase(&btype) = BMA_QUAD   %then b1g&_i b2g&_i;
				  %if %upcase(&btype) = BMA_CUBIC  %then b1g&_i b2g&_i b3g&_i;
			  %end;
	  ;
	  set &blog(keep = Iteration ag: b:);
	run;

	/* eMKF: block diagonal by group */
	%let oPPmat = ; %let _i = 0;
	%do _i=1 %to &g; 
		%if &_i = 1 %then %let oPPmat = block( oP ;
		%if &_i > 1 and &_i < &g %then %let oPPmat = &oPPmat , block ( oP ;
		%if &_i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let oPPmat = &oPPmat );
	%end;

	%let _i = 0;

	/* eMKF: call proc iml to perform matrix multiplication */
	proc iml;

		use _oPmat_;
		read all into oP; close _oPmat_;
		oP = oP[1:&p, 1:&p];
		oPP = &oPPmat;;

		varNames = {"Iteration"};
		%if %upcase(&btype) = BMA_LINEAR %then %do;
			%do _i = 1 %to &g;
				varNames = varNames || {"ag&_i"} || {"b1g&_i"};
			%end;
		%end;
		%if %upcase(&btype) = BMA_QUAD   %then %do; 
			%do _i = 1 %to &g;
				varNames = varNames || {"ag&_i"} || {"b1g&_i"} || {"b2g&_i"};
			%end;
		%end;
		%if %upcase(&btype) = BMA_CUBIC  %then %do;
			%do _i = 1 %to &g;
	 			varNames = varNames || {"ag&_i"} || {"b1g&_i"} || {"b2g&_i"} || {"b3g&_i"};
			%end;
		%end;

		use _blogc2_;
		read all into oB;
		close _blogc2_;

		oB1 = oB[,1];
		oB = T(oB[,2:ncol(oB)]);
		oBB = oPP * oB;
		oBB = oB1 || T(oBB);

		create _tblogc2_ var varNames;
		append from oBB;
		close _tblogc2_;

	quit;

	/* eMKF: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration ag1-ag&g 
			  %if %upcase(&btype) = BMA_LINEAR  %then b1g1-b1g&g ; 
			  %if %upcase(&btype) = BMA_QUAD    %then b1g1-b1g&g b2g1-b2g&g ; 
			  %if %upcase(&btype) = BMA_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g ; 
	  ;
	  set _tblogc2_;
	run;

	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration flg %if %upcase(&bdirichlet) = YES %then wts; )
	        _tblogc_
			&blog(drop = ag: b:)
	  ;
	  by Iteration;
	run;
	  
%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bbjunk _oXmat_ _oPmat_ _blogc2_ _tblogc2_ _tblogc_;
run ;
quit;

%mend bayesBMA;

data _null_;
run;

/* eMKF v2.4: Version of BAYESBMA to allow intercept-only (level) shift in trend.
 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 btype              : bma_cubic, bma_quad, or bma_linear
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 bxpt               : value of timepoint at which trend break occurs.
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar (default) if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior;
					: common_arh (new in eMKF v2.4) if AR correlation is common but variance parameters are independent.
 bslicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling step 
					  Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression if borpoly=YES.
 s1bmalpha,s1bpalpha: prior mean and precision for intercepts in segment 1
 s2bmalpha,s2bpalpha: prior mean and precision for intercepts in segment 2
 bmbeta1 , bpbeta1	: prior mean and precision for mean linear coefficient(s) across groups
 bmbeta2 , bpbeta2	: prior mean and precision for mean quadratic coefficient(s) across groups
 bmbeta3 , bpbeta3 	: prior mean and precision for mean cubic coefficient(s) across groups
 bmrho, bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul, btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bdirichlet			: [eMKF v2.4 streamlining] Whether to use the Dirichlet prior for model weights (default = NO)
 bwshape			: Common shape parameter to use for Dirichlet prior on model indicators in mixture prior
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of CMP library (usually set in parent macro mkf)

*/
%macro bayesBMAxptl(
             bdata	= , 
			 blog	= ,
			 btype	= bma_linear, 
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time,
			 bxpt	= , 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of %mkf(). 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values*/
			 s1bmalpha  = , s1bpalpha= ,
			 s2bmalpha  = , s2bpalpha= ,
			 bmbeta1  = 0,  bpbeta1  = ,    /* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 bmbeta2  = 0,  bpbeta2  = ,
			 bmbeta3  = 0,  bpbeta3  = ,
             bmrho    = 0,	bprho    = 1,	/* eMKF: bmrho is constant c9 and bprho is c10 in RAND's MKF User's Guide */
			 btaul    = 0.0001,	btauu= ,	/* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape  = ,   bvscale  = ,
			 bdirichlet = NO, bwshape= 2,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc  = work.funcs
             ) / minoperator;
 
%local g n s1n s2n p d brtm s1brtm s2brtm _brtimess brangeY s1brangeY s2brangeY bqrangeV bmedianV formatted dsop dscl _i _j _l _ll oPPmat
       b1line b2line b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline wtsline
       parline parline2 s1aparline s2aparline vparline udsparline tauparline2 psiparline2
       plines1a plines2a plineb1 plineb2 plineb3 plinev plinetau plinepsi plinewts plineflg bslice hplinempsi hplinespsi
	   initlines1a initlines2a initlineb1 initlineb2 initlineb3 initlinevarr initlinetau initlinepsi initlinewts initlineflg
       monitorline optionline udsline rcXline rcNline initmbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformatXPT(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, xpt=&bxpt, randomVars = &brndvars, outformat= _bbdata_);
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1 */
%let s1n=0;
data _bfreqs1n_;
run;
proc freq data=_bbdata_ noprint;
 tables _s1rtime /list out=_bfreqs1n_;
run;
data _bfreqs1n_;
 set _bfreqs1n_(where=(_s1rtime ne 0));
 _s1tm +1;
 call symput('s1n',_s1tm);
 keep _s1tm _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2 */
%let s2n=0;
data _bfreqs2n_;
run;
proc freq data=_bbdata_ noprint;
 tables _s2rtime /list out=_bfreqs2n_;
run;
data _bfreqs2n_;
 set _bfreqs2n_(where=(_s2rtime ne 0));
 _s2tm +1;
 call symput('s2n',_s2tm);
 keep _s2tm _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _bfreqs2n_;
  set _bfreqs2n_;
  _s2tm = _s2tm + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: variables that will be used for real time in case times are irregular */
%let brtm  = _rtime; %let s1brtm  = _s1rtime; %let s2brtm  = _s2rtime;

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure model type has been specified */
%if &btype = %str() %then %do;
	%put ERROR: BMA model must be specified. Please review!;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure requested model is supported */
%if not(%upcase(&btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
	%put ERROR: Requested BMA model is unsupported. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p = 2;
%if %upcase(&btype) = BMA_CUBIC  %then %let p = 5;
%if %upcase(&btype) = BMA_QUAD   %then %let p = 4;
%if %upcase(&btype) = BMA_LINEAR %then %let p = 3;
%let p = %eval(0+&p);

/* eMKF v2.4: max polynomial rank d-1 to use in orpoly */
%let d = 1;
%if &s1n > 4 or &s2n > 4 %then %let d = 4; /* cubic allowed with 5+ timepoints in either segments 1 or 2 */
%else %do;
	%if &s1n > 3 or &s2n > 3 %then %let d = 3; /* quad allowed with 4+ timepoints in either segments 1 or 2 */
	%else %do;
		%if &s1n > 2 or &s2n > 2 %then %let d = 2; /* linear allowed with 3+ timepoints in either segments 1 or 2 */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4 streamlining: Error check to make sure requested trend models can be fit */
%if (&p > &d+1) %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%put ERROR- &btype was requested, yet there are only enough data for a degree %eval(&d-1) polynomial.; 
  	%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  s1x0 = { %cnstss(1, &s1n) %cnstss(0, &s2n)};
	  s1x0 = T(s1x0);										/* eMKF v2.4: Intercepts for segment 1 */
	  s2x0 = { %cnstss(0, &s1n) %cnstss(1, &s2n)}; 
	  s2x0 = T(s2x0);										/* eMKF v2.4: Intercepts for segment 2 */
	  x = { &_brtimess };
	  x = T(x);												/* eMKF: column vector with real times */
	  oP0 = orpol(x, &d-1);									/* eMKF v2.4: orthonormal design matrix oP (d > 1 here) */
	  oP = (oP0[,1]#s1x0) || (oP0[,1]#s2x0);
	  oP = oP || oP0[,2];
	  %if &s1n > 3 or &s2n > 3 %then oP = oP || oP0[,3];;
	  %if &s1n > 4 or &s2n > 4 %then oP = oP || oP0[,4];;
	  x1 = x;
	  %if &s1n > 3 or &s2n > 3 %then x2 = x#x1;;
	  %if &s1n > 4 or &s2n > 4 %then x3 = x#x2;;
	  uP = s1x0 || s2x0;									/* eMKF v2.4: raw/unstandardized design matrix uP */
	  uP = uP || x1;
	  %if &s1n > 3 or &s2n > 3 %then uP = uP || x2;;
	  %if &s1n > 4 or &s2n > 4 %then uP = uP || x3;;
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
	  oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];
      oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];
      %if &s1n > 3 or &s2n > 3 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
      %if &s1n > 4 or &s2n > 4 %then oP5 = inv(T(uP)*uP)*T(uP)*oP[,5];;
	  oPP = oP1 || oP2;										/* eMKF: right multiplication of uP with oPP produces oP */
	  oPP = oPP || oP3;
	  %if &s1n > 3 or &s2n > 3 %then oPP = oPP || oP4;;
	  %if &s1n > 4 or &s2n > 4 %then oPP = oPP || oP5;;
	  y = T(do(1, &n, 1));									/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" "&brtm.2" "&brtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" "&brtm.2" } ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s2brtm.0" "&brtm.1" } ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _bbdata_ */
	  set _bbdata_;
	  if &s1brtm > 0 then &s1brtm.0 = 1; else &s1brtm.0 = 0;
	  if &s2brtm > 0 then &s2brtm.0 = 1; else &s2brtm.0 = 0;
	  &brtm.1 = &brtm;
	  %if &d > 2 %then &brtm.2 = &brtm**2;;
	  %if &d > 3 %then &brtm.3 = &brtm**3;;
	run;
%end;

%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

%let s1brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s1brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s1brangeY", range);
run;
%let s1brangeY = %sysevalf(&s1brangeY + 0);

%let s2brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s2brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s2brangeY", range);
run;
%let s2brangeY = %sysevalf(&s2brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF: c1 in RAND's MKF User's Guide */
%if &s1bmalpha = %str() %then %let s1bmalpha = %sysevalf(0.5 * &s1brangeY);;
%if &s2bmalpha = %str() %then %let s2bmalpha = %sysevalf(0.5 * &s2brangeY);;

/* eMKF: 1/c2 in RAND's MKF User's Guide */	
%if &s1bpalpha = %str() %then %let s1bpalpha = %sysevalf(0.000001/(&s1brangeY**2));; 
%if &s2bpalpha = %str() %then %let s2bpalpha = %sysevalf(0.000001/(&s2brangeY**2));; 

/* eMKF: c7 in RAND's MKF User's Guide */
%if &bmbeta1 = %str() %then %let bmbeta1 = %sysevalf(0);;

/* eMKF: 1/c8 in RAND's MKF User's Guide */	
%if &bpbeta1  = %str() %then %let bpbeta1  = %sysevalf(0.000001/(&brangeY**2));;

/* eMKF v2.4: added check for negative value */
%if &bmrho  ^= %str() and &bmrho < 0 %then %do;
	%put WARNING: Prior mean &bmrho for transformed AR(1) correlation coefficient is expected to be positive.;
	%put WARNING- Its absolute value will be used instead.;
	%let bmrho = %sysevalf(- &bmrho);
%end;

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho    = %str() %then %let  bmrho  = %sysevalf(0);;	

/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho    = %str() %then %let  bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul    = %str() %then %let  btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu    = %str() %then %let  btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &bmbeta2 = %str() %then %let bmbeta2 = %sysevalf(0);; 
%if &bpbeta2 = %str() %then %let bpbeta2 = %sysevalf(2.0 * &bpbeta1);; 
%if &bmbeta3 = %str() %then %let bmbeta3 = %sysevalf(0);; 	
%if &bpbeta3 = %str() %then %let bpbeta3 = %sysevalf(4.0 * &bpbeta1);; 		

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF: Array structures for BMA weights and prior mixtures */
/* Recall: 1=indep_cubic, 2=indep_quad, 3=indep_linear, 4=common_cubic, 5=common_quad, 6=common_linear, 7=dropped */
%if &bwshape = %str() %then %let bwshape = %eval(2);;
%let wtsline = ; 
%if %upcase(&btype) = BMA_CUBIC %then %do;
	%let wtsline = &wtsline array wtsshape[7] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
	%let wtsline = &wtsline array wts[7]%str(;);  /*  model weights */
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let wtsline = &wtsline array wtsshape[5] (&bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
	%let wtsline = &wtsline array wts[5]%str(;);
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let wtsline = &wtsline array wtsshape[3] (&bwshape &bwshape &bwshape)%str(;) ;
	%let wtsline = &wtsline array wts[3]%str(;); 
%end;

/* eMKF: Named 1-dimensional arrays of regression parameters other than intercept */
%let b1line=; %let b2line=; %let b3line=; 
%if %upcase(&btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %let b1line = array b1g[&g] b1g1-b1g&g ;
%if %upcase(&btype) in BMA_CUBIC BMA_QUAD %then %let b2line = array b2g[&g] b2g1-b2g&g ;
%if %upcase(&btype) = BMA_CUBIC %then %let b3line = array b3g[&g] b3g1-b3g&g ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF v2.4: Segment 1 intercepts */
%let s1aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s1aparline = &s1aparline s1ag&_i ; 
%end; 

/* eMKF v2.4: Segment 2 intercepts */
%let s2aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s2aparline = &s2aparline s2ag&_i ; 
%end; 

/* eMKF: Linear, quadratic, and cubic coefficients, as needed */
%let parline = &s1aparline &s2aparline; /* eMKF v2.4: parline accounts for two sets of intercepts */ 
%let parline2 = &s1aparline &s2aparline; 
%let _i = 0;
%if %upcase(&btype) = BMA_CUBIC %then %do;
	%let parline = &parline b1 b2 b3;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i b3g&_i ;
		%let parline2 = &parline2 b1g&_i b2g&_i b3g&_i ;
	%end;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let parline = &parline b1 b2;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i b2g&_i ;
		%let parline2 = &parline2 b1g&_i b2g&_i ;
	%end;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let parline = &parline b1;
	%do _i = 1 %to &g; 
		%let parline = &parline b1g&_i ;
		%let parline2 = &parline2 b1g&_i ;
	%end;
%end;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* model flags updated in a separate UDS block */
%let udsparline = &udsparline parms flg %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF: Prior for mixture weights */
%let plinewts = ;
%if %upcase(&bdirichlet) = YES %then 
	%let plinewts = prior wts ~ dirichlet(wtsshape);

/* eMKF: Prior for latent variable flg */
%let plineflg = prior flg ~ table(wts);

/* eMKF v2.4: Prior for intercepts ag1 through ag&g in segments 1 and 2 */
%let plines1a = prior &s1aparline ~ normal(&s1bmalpha, prec=&s1bpalpha);
%let plines2a = prior &s2aparline ~ normal(&s2bmalpha, prec=&s2bpalpha);

/****************************************************************/
/* eMKF: Priors for regression parameters other than intercepts */
/****************************************************************/

%let plineb1=; %let plineb2=; %let plineb3=;

%if %upcase(&btype) = BMA_CUBIC %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=4 or flg=5 or flg=6 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 or flg=2 or flg=3 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=7 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if (flg=4 or flg=5 or flg=6) and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let plineb2 = &plineb2 if flg=4 or flg=5 then lpb2=lpb2+lpdfnorm(b2,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
	%let plineb2 = &plineb2 if flg=6 and %str(abs(b2)> %sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b2-mean(of b2g1-b2g&g))>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 prior b2 ~ general(lpb2)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb2 = &plineb2 if flg=1 or flg=2 then lpb2=lpb2+lpdfnorm(b2g&_i,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
		%let plineb2 = &plineb2 if (flg=3 or flg=7) and %str(abs(b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
		%let plineb2 = &plineb2 if (flg=4 or flg=5 or flg=6) and %str(abs(b2-b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb2 = &plineb2 prior b2g: ~ general(lpb2)%str(;);

	%let plineb3 = &plineb3 lpb3=0%str(;) ;
	%let plineb3 = &plineb3 if flg=4 then lpb3=lpb3+lpdfnorm(b3,&bmbeta3,sqrt(1/&bpbeta3))%str(;) ;
	%let plineb3 = &plineb3 if (flg=5 or flg=6) and %str(abs(b3)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%let plineb3 = &plineb3 if (flg=1 or flg=2 or flg=3 or flg=7) and %str(abs(b3-mean(of b3g1-b3g&g))>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%let plineb3 = &plineb3 prior b3 ~ general(lpb3)%str(;);

	%let plineb3 = &plineb3 lpb3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb3 = &plineb3 if flg=1 then lpb3=lpb3+lpdfnorm(b3g&_i,&bmbeta3,sqrt(1/&bpbeta3))%str(;) ;
		%let plineb3 = &plineb3 if (flg=2 or flg=3 or flg=7) and %str(abs(b3g&_i)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
		%let plineb3 = &plineb3 if (flg=4 or flg=5 or flg=6) and %str(abs(b3-b3g&_i)>%sysevalf(1e-11)) then lpb3=lpb3-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb3 = &plineb3 prior b3g: ~ general(lpb3)%str(;);

%end;
%if %upcase(&btype) = BMA_QUAD %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=3 or flg=4 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=2 or flg=5) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 or flg=2 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=5 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if (flg=3 or flg=4) and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let plineb2 = &plineb2 if flg=3 then lpb2=lpb2+lpdfnorm(b2,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
	%let plineb2 = &plineb2 if flg=4 and %str(abs(b2)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 if (flg=1 or flg=2 or flg=5) and %str(abs(b2-mean(of b2g1-b2g&g))>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%let plineb2 = &plineb2 prior b2 ~ general(lpb2)%str(;);

	%let plineb2 = &plineb2 lpb2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb2 = &plineb2 if flg=1 then lpb2=lpb2+lpdfnorm(b2g&_i,&bmbeta2,sqrt(1/&bpbeta2))%str(;) ;
		%let plineb2 = &plineb2 if (flg=2 or flg=5) and %str(abs(b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
		%let plineb2 = &plineb2 if (flg=3 or flg=4) and %str(abs(b2-b2g&_i)>%sysevalf(1e-11)) then lpb2=lpb2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb2 = &plineb2 prior b2g: ~ general(lpb2)%str(;);

%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let plineb1 = &plineb1 if flg=2 then lpb1=lpb1+lpdfnorm(b1,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
	%let plineb1 = &plineb1 if (flg=1 or flg=3) and %str(abs(b1-mean(of b1g1-b1g&g))>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%let plineb1 = &plineb1 prior b1 ~ general(lpb1)%str(;);

	%let plineb1 = &plineb1 lpb1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plineb1 = &plineb1 if flg=1 then lpb1=lpb1+lpdfnorm(b1g&_i,&bmbeta1,sqrt(1/&bpbeta1))%str(;) ;
		%let plineb1 = &plineb1 if flg=3 and %str(abs(b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
		%let plineb1 = &plineb1 if flg=2 and %str(abs(b1-b1g&_i)>%sysevalf(1e-11)) then lpb1=lpb1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plineb1 = &plineb1 prior b1g: ~ general(lpb1)%str(;);

%end;

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then 
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF: Dimensionality for do loops to initialize mixture parameters */
%let _ll=0;
%if %upcase(&btype) = BMA_CUBIC  %then %let _ll = 7;
%if %upcase(&btype) = BMA_QUAD 	 %then %let _ll = 5;
%if %upcase(&btype) = BMA_LINEAR %then %let _ll = 3;
%let _ll = %eval(0+&_ll);

/* eMKF: Initial values for mixture weights */
%let initlinewts = wtssum = 0%str(;) ; %let _l=0; 
%do _l=1 %to &_ll; 
	%if %upcase(&bdirichlet) = YES %then %do; /* eMKF v2.4 streamlining: Added explicit Dirichlet option */
		%let initlinewts = &initlinewts wts[&_l] = rand('gamma', wtsshape[&_l])%str(;) ;
	%end;
	%else %do;
		%let initlinewts = &initlinewts wts[&_l] = wtsshape[&_l]%str(;) ; 
	%end;
	%let initlinewts = &initlinewts wtssum = wtssum + wts[&_l]%str(;) ;
%end;

/* eMKF: Rescale wts to sum to one */
%let _l=0;
%do _l=1 %to &_ll;		
	%let initlinewts = &initlinewts wts[&_l] = wts[&_l]/wtssum%str(;) ;
%end;

/* eMKF: Initial values for latent variable flg */
%let initlineflg = ; %let _l=0;
%do _l=1 %to &_ll; 
	%let initlineflg = &initlineflg %str(,) wts[&_l]; 
%end;
%let initlineflg = flg = rand('table' &initlineflg);

/* eMKF: Initial/constant values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
%let initmbeta = call zeromatrix(Dbetag);	
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &s1bmalpha%str(;) Dbetag[1,1] = &s1bpalpha;
%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s2bmalpha%str(;) Dbetag[2,2] = &s2bpalpha;

%if %upcase(&btype) = BMA_CUBIC %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta1%str(;) Dbetag[3,3] = &bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[4,1] = &bmbeta2%str(;) Dbetag[4,4] = &bpbeta2;
	%let initmbeta = &initmbeta%str(;) mbetag[5,1] = &bmbeta3%str(;) Dbetag[5,5] = &bpbeta3;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta1%str(;) Dbetag[3,3] = &bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[4,1] = &bmbeta2%str(;) Dbetag[4,4] = &bpbeta2;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &bmbeta1%str(;) Dbetag[3,3] = &bpbeta1;
%end;

/* eMKF v2.4: Initial values for intercepts in segments 1 and 2 */
%let initlines1a=; %let initlines2a=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlines1a = &initlines1a s1ag&_i = &s1bmalpha+sqrt(1/&s1bpalpha)*rand('normal')%str(;) ;
	%let initlines2a = &initlines2a s2ag&_i = &s2bmalpha+sqrt(1/&s2bpalpha)*rand('normal')%str(;) ;
%end;

/*********************************************************************************/
/* eMKF: Initial values for regression parameters and applicable hyperparameters */
/*********************************************************************************/

%let initlineb1=; %let initlineb2=; %let initlineb3=; 

%if %upcase(&btype) = BMA_CUBIC %then %do;

	%let initlineb3 = &initlineb3 if flg=4 then b3=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
	%let initlineb3 = &initlineb3 if flg=5 or flg=6 then b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb3 = &initlineb3 if flg=1 then b3g&_i=&bmbeta3+sqrt(1/&bpbeta3)*rand('normal')%str(;) ;
		%let initlineb3 = &initlineb3 if flg=2 or flg=3 or flg=7 then b3g&_i=0%str(;) ;
		%let initlineb3 = &initlineb3 if flg=4 or flg=5 or flg=6 then b3g&_i=b3%str(;) ;
	%end;
	%let initlineb3 = &initlineb3 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b3=mean(of b3g1-b3g&g);) ;

	%let initlineb2 = &initlineb2 if flg=4 or flg=5 then b2=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%let initlineb2 = &initlineb2 if flg=6 then b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 if flg=1 or flg=2 then b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
		%let initlineb2 = &initlineb2 if flg=3 or flg=7 then b2g&_i=0%str(;) ;
		%let initlineb2 = &initlineb2 if flg=4 or flg=5 or flg=6 then b2g&_i=b2%str(;) ;
	%end;
	%let initlineb2 = &initlineb2 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b2= mean(of b2g1-b2g&g);) ;

	%let initlineb1 = &initlineb1 if flg=4 or flg=5 or flg=6 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 or flg=2 or flg=3 then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=7 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=4 or flg=5 or flg=6 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=2 or flg=3 or flg=7 then b1=mean(of b1g1-b1g&g);) ;

%end;
%if %upcase(&btype) = BMA_QUAD %then %do;

	%let initlineb2 = &initlineb2 if flg=3 then b2=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
	%let initlineb2 = &initlineb2 if flg=4 then b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb2 = &initlineb2 if flg=1 then b2g&_i=&bmbeta2+sqrt(1/&bpbeta2)*rand('normal')%str(;) ;
		%let initlineb2 = &initlineb2 if flg=2 or flg=5 then b2g&_i=0%str(;) ;
		%let initlineb2 = &initlineb2 if flg=3 or flg=4 then b2g&_i=b2%str(;) ;
	%end;
	%let initlineb2 = &initlineb2 %str(if flg=1 or flg=2 or flg=5 then b2=mean(of b2g1-b2g&g);) ;

	%let initlineb1 = &initlineb1 if flg=3 or flg=4 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 or flg=2  then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=5 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=3 or flg=4 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=2 or flg=5 then b1=mean(of b1g1-b1g&g);) ;

%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;

	%let initlineb1 = &initlineb1 if flg=2 then b1=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlineb1 = &initlineb1 if flg=1 then b1g&_i=&bmbeta1+sqrt(1/&bpbeta1)*rand('normal')%str(;) ;
		%let initlineb1 = &initlineb1 if flg=3 then b1g&_i=0%str(;) ;
		%let initlineb1 = &initlineb1 if flg=2 then b1g&_i=b1%str(;) ;
	%end;
	%let initlineb1 = &initlineb1 %str(if flg=1 or flg=3 then b1=mean(of b1g1-b1g&g);) ;

%end;

/* eMKF: Initial values for unobserved true states predictions given regression parameters */
%let _i = 0; %let _j = 0; 
%if %upcase(&btype) = BMA_CUBIC %then %do;
  %do _i = 1 %to &g; 
  	%local initetamnarr&_i; /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	%do _j = 1 %to &n; 
	  %let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i+X[&_j,4]*b2g&_i+X[&_j,5]*b3g&_i%str(;) ;
    %end;
  %end;
%end;
%if %upcase(&btype) = BMA_QUAD %then %do;
	%do _i = 1 %to &g; 
	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
	  		%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i+X[&_j,4]*b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&btype) = BMA_LINEAR %then %do;
	%do _i = 1 %to &g; 
	    %local initetamnarr&_i;
  		%do _j = 1 %to &n; 
			%let initetamnarr&_i = &&initetamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s2ag&_i+X[&_j,3]*b1g&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
/* eMKF v2.4: modified to allow for segment-specific intercepts */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &s1brtm.0 &s2brtm.0 &brtm.1 %if &d > 2 %then &brtm.2; %if &d > 3 %then &brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
/* eMKF v2.4: note change in dimensionality */
%let rcXline = ;
%if &p = 3 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'));
%if &p = 4 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'));
%if &p = 5 %then %let rcXline = rcX = read_array('_bbdata1_', Xarr, resolve('&s1brtm.0'), resolve('&s2brtm.0'), resolve('&brtm.1'), resolve('&brtm.2'), resolve('&brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions  */
/*      These will be applied in the order provided here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ;
 
/* eMKF v2.4: UDS statement for model flag */
%if %upcase(&btype) = BMA_CUBIC %then
	%let udsline = &udsline uds FP_xptl_bmac(flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = BMA_QUAD %then
	%let udsline = &udsline uds FP_xptl_bmaq(flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%if %upcase(&btype) = BMA_LINEAR %then
	%let udsline = &udsline uds FP_xptl_bmal(flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;

/* eMKF v2.4: UDS statement for regression coefficients, revised to accomodate additional intercept for segment 2  */
/* The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if %upcase(&btype) = BMA_CUBIC %then
	%let udsline = &udsline uds CP_xptl_bmac(s1ag, s2ag, b1g, b2g, b3g, b1, b2, b3, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%if %upcase(&btype) = BMA_QUAD %then
	%let udsline = &udsline uds CP_xptl_bmaq(s1ag, s2ag, b1g, b2g, b1, b2, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%if %upcase(&btype) = BMA_LINEAR %then
	%let udsline = &udsline uds CP_xptl_bmal(s1ag, s2ag, b1g, b1, etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then 
	%let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%if %upcase(&bdirichlet) = YES %then %let monitorline = wts;
%let monitorline = &monitorline flg &parline2 etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;

proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, &p];										/* design matrix to use in matrix multiplication */
	  array mbetag[&p, 1];									/* prior mean vector for betas (assumed common across groups) */
	  array Dbetag[&p, &p];									/* diagonal prior precision matrix for betas (assumed common across groups) */
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho  */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  &wtsline;;											/* mixture weights and model flags */
	  array s1ag[&g] s1ag1-s1ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 1 */
	  array s2ag[&g] s2ag1-s2ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 2 */
	  &b1line;;												/* named 1-dimensional array of group-specific linear coefficients (if requested) */
 	  &b2line;;                     						/* named 1-dimensional array of group-specific quad coefficients (if requested) */
	  &b3line;; 											/* named 1-dimensional array of group-specific cubic coefficients (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array of group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
		  do i = 1 to &n;								    /* Xarr is a 2-dimensional array for p > 1 */
		  	  do m = 1 to &p;
				  X[i,m] = Xarr[i,m];						
			  end;
		  end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initmbeta;;							 			/* initialize constant vector mbetag and constant matrix Dbetag */

		  &initlinewts;;									/* initialize model weights and related arrays */
		  &initlineflg;;									/* initialize model flags */

		  &initlines1a;;									/* eMKF v2.4: initialize intercepts for segment 1 */
		  &initlines2a;;									/* eMKF v2.4: initialize intercepts for segment 2 */
		  &initlineb1;;										/* initialize linear coefficients and related arrays (if applicable) */
		  &initlineb2;;										/* initialize quad coefficients and related arrays (if applicable) */	
		  &initlineb3;;										/* initialize cubic coefficients and related arrays (if applicable) */

          %do _i = 1 %to &g; 
		      &&initetamnarr&_i;;						    /* initialize conditional mean for true states  */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /*******************/
	  /* UDS declaration */
	  /*******************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  %if %upcase(&bdirichlet) = YES %then %do;				/* eMKF v2.4 streamlining: explicitly included dirichlet prior option */
		  parms wts &bslice; 								/* Dirichlet mixture weights */
	  %end;
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			 * dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			 * do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			  *  dg[k] = nu[k]**&n;
			  *  do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*    end;
			*    if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
 
		  &plinewts;;										/* Dirichlet prior for model weights */
		  &plineflg;;										/* Discrete prior for model flag */

	  	  &plines1a;; 							 			/* eMKF v2.4: prior for intercepts in segment 1 */
	  	  &plines2a;; 							 			/* eMKF v2.4: prior for intercepts in segment 2 */
	  	  &plineb1;;							 			/* conditional prior for linear coefficients given model flag (if applicable) */
	  	  &plineb2;;							 			/* conditional prior for quadratic coefficients given model flag (if applicable) */
	  	  &plineb3;;							 			/* conditional prior for cubic coefficients given model flag (if applicable) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		      lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;
		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= etamn: Log: spsi mpsi &tauparline &psiparline
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; ) 
			&blog(keep = spsi mpsi)
      ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= etamn: Log: &tauparline psi
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
		set &blog(drop= etamn: Log: tau psi
						%if %upcase(&btype) = BMA_CUBIC %then b1 b2 b3; 
  						%if %upcase(&btype) = BMA_QUAD %then b1 b2; 
						%if %upcase(&btype) = BMA_LINEAR %then b1; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF: order columns by group */
	data _blogc2_;
  	  retain  Iteration 
			  %do _i=1 %to &g;
				  s1ag&_i s2ag&_i
				  %if %upcase(&btype) = BMA_LINEAR %then b1g&_i;
				  %if %upcase(&btype) = BMA_QUAD   %then b1g&_i b2g&_i;
				  %if %upcase(&btype) = BMA_CUBIC  %then b1g&_i b2g&_i b3g&_i;
			  %end;
	  ;
	  set &blog(keep = Iteration s1a: s2a: b:);
	run;

	/* eMKF: block diagonal by group */
	%let oPPmat = ; %let _i = 0;
	%do _i=1 %to &g; 
		%if &_i = 1 %then %let oPPmat = block( oP ;
		%if &_i > 1 and &_i < &g %then %let oPPmat = &oPPmat , block ( oP ;
		%if &_i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let oPPmat = &oPPmat );
	%end;

	%let _i = 0;

	/* eMKF: call proc iml to perform matrix multiplication */
	proc iml;

		use _oPmat_;
		read all into oP; close _oPmat_;
		oP = oP[1:&p, 1:&p];
		oPP = &oPPmat;;

		varNames = {"Iteration"};
		%if %upcase(&btype) = BMA_LINEAR %then %do;
			%do _i = 1 %to &g;
				varNames = varNames || {"s1ag&_i"} || {"s2ag&_i"} || {"b1g&_i"};
			%end;
		%end;
		%if %upcase(&btype) = BMA_QUAD   %then %do; 
			%do _i = 1 %to &g;
				varNames = varNames || {"s1ag&_i"} || {"s2ag&_i"} || {"b1g&_i"} || {"b2g&_i"};
			%end;
		%end;
		%if %upcase(&btype) = BMA_CUBIC  %then %do;
			%do _i = 1 %to &g;
	 			varNames = varNames || {"s1ag&_i"} || {"s2ag&_i"} || {"b1g&_i"} || {"b2g&_i"} || {"b3g&_i"};
			%end;
		%end;

		use _blogc2_;
		read all into oB;
		close _blogc2_;

		oB1 = oB[,1];
		oB = T(oB[,2:ncol(oB)]);
		oBB = oPP * oB;
		oBB = oB1 || T(oBB);

		create _tblogc2_ var varNames;
		append from oBB;
		close _tblogc2_;

	quit;

	/* eMKF: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration s1ag1-s1ag&g s2ag1-s2ag&g 
			  %if %upcase(&btype) = BMA_LINEAR  %then b1g1-b1g&g ; 
			  %if %upcase(&btype) = BMA_QUAD    %then b1g1-b1g&g b2g1-b2g&g ; 
			  %if %upcase(&btype) = BMA_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g ; 
	  ;
	  set _tblogc2_;
	run;

	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration flg %if %upcase(&bdirichlet) = YES %then wts; )
	        _tblogc_
			&blog(drop = s1a: s2a: b:)
	  ;
	  by Iteration;
	run;
	  
%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bfreqs1n_ _bfreqs2n_ _bbjunk _oXmat_ _oPmat_ _blogc2_ _tblogc2_ _tblogc_;
run ;
quit;

%mend bayesBMAxptl;

data _null_;
run;

/* eMKF v2.4: Version of BAYESBMA to allow full break in trend.
 bdata              : Name of the data to be used
 blog               : Name of the output data containing full set of &biter/&bthin posterior draws
 s1btype , s2btype  : bma_cubic, bma_quad, or bma_linear
 bgroup             : Group variable in the dataset 
 btime              : Time variable in the dataset 
 bxpt               : value of timepoint at which trend break occurs.
 boutcome           : Outcome of interest variable in the dataset 
 bse                : Standard error variable in the dataset 
 bn				    : Effective sample size variable in the dataset (if applicable)
 brndvars			: YES if variances should be modeled; NO if variances should be assumed known
 bARmodel			: common_ar (default) if AR parameters are common across groups; indep_ar if they are independently drawn from a common prior;
					: common_arh (new in eMKF v2.4) if AR correlation is common but variance parameters are independent.
 bslicesampler		: YES to use the slice sampler instead of MH algorithm for parameters that are not included in the Gibbs sampling step 
					  Default is NO due to heavier computational load.
 bseed              : random number generating seed that will allow the user to reproduce the same results in the Bayesian model
 bprcov				: method used in constructing initial covariance matrix for the MH algorithm (see proc mcmc documentation)
					  If empty, proc mcmc default of IND will be used.
 binit				: Option for generating initial values for the parameters (see documentation and leave empty to apply proc mcmc default)
					  eMKF default is REINIT to reset chains after tuning at the values set by the user
 bmaxt				: maximum number of proposal tuning loops (if empty, proc mcmc default of 24 is used; if 0, tuning will be skipped)
 batol				: Tolerance for acceptance probabilities (if empty, proc mcmc default of 0.075 is used in bttol +|- batol)
 bttol				: Target acceptance rate for random walk Metropolis. If empty, proc mcmc defaults are used, as follows: 
					  0.45 for models with 1 parameter, 0.35 for 2-4 parameters, and 0.234 for models with 5+ parameters.
 btune				: number of tuning iterations to use in each MCMC proposal tuning phase (if empty, proc mcmc default of 500 is used)
 bburn              : number of burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 biter              : number of post-burn-in MCMC iterations (if empty, proc mcmc default of 1000 is used)
 bthin				: controls thinning rate (if empty, proc mcmc default of 1 is used)
 borpoly  			: YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          			  If YES, regression coefficients will be reverse-transformed prior to macro end. 
					  However, prior values below are assumed to be for the coefficients of the orthogonal polynomial regression if borpoly=YES.
 s1bmalpha,s1bpalpha: prior mean and precision for intercepts in segment 1
 s1bmbeta1,s1bpbeta1: prior mean and precision for mean linear coefficient(s) across groups in segment 1
 s1bmbeta2,s1bpbeta2: prior mean and precision for mean quadratic coefficient(s) across groups in segment 1
 s1bmbeta3,s1bpbeta3: prior mean and precision for mean cubic coefficient(s) across groups in segment 1
 s2bmalpha,s2bpalpha: prior mean and precision for intercepts in segment 2
 s2bmbeta1,s2bpbeta1: prior mean and precision for mean linear coefficient(s) across groups in segment 2
 s2bmbeta2,s2bpbeta2: prior mean and precision for mean quadratic coefficient(s) across groups in segment 2
 s2bmbeta3,s2bpbeta3: prior mean and precision for mean cubic coefficient(s) across groups in segment 2
 bmrho, bprho		: prior mean and precision for transformed rho -- ie., psi = -ln[(1-rho)/(1+rho)]
 btaul, btauu		: bounds for U(a,b) prior for tau (SD of innovation variance tausq)
 bvshape , bvscale	: Shape and scale parameters for inverse gamma prior distribution of the variance (when applicable) 
 bdirichlet			: [eMKF v2.4 streamlining] Whether to use the Dirichlet prior for model weights (default = NO)
 bwshape			: Common shape parameter to use for Dirichlet prior on model indicators in mixture prior
 bprint				: If YES, posterior parameter estimates and default chain-specific convergence diagnostics are printed (default is NO)
 bplot				: If YES, trace/diagnostics plots from proc mcmc will be included (default is NO)
 bcmploc			: location of CMP library (usually set in parent macro mkf)

*/
%macro bayesBMAxptf(
             bdata	= , 
			 blog	= ,
			 s1btype = bma_linear, s2btype = bma_linear,
	   /* eMKF: Variable labels assumed to have been reformatted using macro reformat */
			 bgroup	= _group_, 
			 btime	= _time,
			 bxpt	= , 
			 boutcome= _y, 
			 bse	= _se,
			 bn 	= ,
			 brndvars = NO,
			 bARmodel = common_ar,
			 bslicesampler = NO,
	   /* eMKF v2.4 correction: added default values of tuning parameters to use when this macro is called independently of %mkf(). 
			       PROC MCMC defaults will be used when tuning parameters are left unspecified here */
			 bseed	= 1234,
			 bprcov = ,
			 binit  = reinit,
			 bmaxt  = 50,
			 batol 	= ,	
			 bttol 	= ,
			 btune	= 1000,			
			 bburn  = 1000,
			 biter  = 5000,
			 bthin 	= 1,
			 borpoly = YES,
	   /* eMKF: Model parameters: if missing, the data will be used to generate starting values*/
			 s1bmalpha = ,  s1bpalpha  = ,
			 s2bmalpha = ,  s2bpalpha  = ,
			 s1bmbeta1 = 0, s1bpbeta1  = ,    	/* eMKF: bmbeta1 is constant c3 or c7 in RAND's MKF User's Guide */
			 s2bmbeta1 = 0, s2bpbeta1  = ,
			 s1bmbeta2 = 0, s1bpbeta2  = ,
			 s2bmbeta2 = 0, s2bpbeta2  = ,
			 s1bmbeta3 = 0, s1bpbeta3  = ,
			 s2bmbeta3 = 0, s2bpbeta3  = ,
             bmrho     = 0,	bprho      = 1,		/* eMKF: bmrho is constant c9 and bprho is c10 in RAND's MKF User's Guide */
			 btaul = 0.0001,btauu      = ,		/* eMKF: btaul is constant c11 in RAND's MKF User's Guide */
			 bvshape   = ,  bvscale    = ,
			 bdirichlet=NO, bwshape	   = 2,
	    /* eMKF: Printing and diagnostic plots are off by default */
			 bprint   = NO,
			 bplot 	  = NO,
			 bcmploc  = work.funcs
             ) / minoperator;
 
%local g n s1n s2n s1p s2p s1d s2d brtm s1brtm s2brtm _brtimess _s1brtimess _s2brtimess brangeY s1brangeY s2brangeY bqrangeV bmedianV formatted dsop dscl _i _j _l _ll s1oPPmat s2oPPmat
       s1b1line s1b2line s1b3line s2b1line s2b2line s2b3line vline etaarrline etamnarrline tauparline psiparline tausqparline rhoparline wtsline
       parline parline2 s1aparline s2aparline vparline udsparline tauparline2 psiparline2 recodeflg
       plines1a plines1b1 plines1b2 plines1b3 plines2a plines2b1 plines2b2 plines2b3 plinev plinetau plinepsi plinewts plineflg bslice hplinempsi hplinespsi
	   initlines1a initlines1b1 initlines1b2 initlines1b3 initlines2a initlines2b1 initlines2b2 initlines2b3 initlinevarr initlinetau initlinepsi initlinewts initlineflg
       monitorline optionline udsline rcXline rcNline initmbeta Narrline;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&bdata));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &btime)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _bbdata_ _bbdata1_;
run;

%if &formatted = 1 %then %do;
	data _bbdata_;
	  set &bdata;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to Bayesian estimation;
	%if %upcase(&brndvars) = YES and &bn = %str() %then %do;
		%put ERROR: (Effective) sample sizes bn must be specified to fit random sampling variances.;
		%return;
	%end;
	%reformatXPT(data=&bdata, outcome=&boutcome, se=&bse, neff=&bn, group=&bgroup, time=&btime, xpt=&bxpt, randomVars = &brndvars, outformat= _bbdata_);
%end;

/* eMKF: Sort by replications, group, and time */
proc sort data= _bbdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _bfreqg_;
run;
proc freq data=_bbdata_ noprint;
 tables _group_ /list out=_bfreqg_;
run;
data _bfreqg_;
 set _bfreqg_;
 _grp_ +1;
 call symput('g',_grp_);
 keep _grp_ _group_;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _bfreqn_;
run;
proc freq data=_bbdata_ noprint;
 tables _rtime /list out=_bfreqn_;
run;
data _bfreqn_;
 set _bfreqn_;
 _tm +1;
 call symput('n',_tm);
 keep _tm _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1 */
%let s1n=0;
data _bfreqs1n_;
run;
proc freq data=_bbdata_ noprint;
 tables _s1rtime /list out=_bfreqs1n_;
run;
data _bfreqs1n_;
 set _bfreqs1n_(where=(_s1rtime ne 0));
 _s1tm +1;
 call symput('s1n',_s1tm);
 keep _s1tm _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2 */
%let s2n=0;
data _bfreqs2n_;
run;
proc freq data=_bbdata_ noprint;
 tables _s2rtime /list out=_bfreqs2n_;
run;
data _bfreqs2n_;
 set _bfreqs2n_(where=(_s2rtime ne 0));
 _s2tm +1;
 call symput('s2n',_s2tm);
 keep _s2tm _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _bfreqs2n_;
  set _bfreqs2n_;
  _s2tm = _s2tm + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _brtimess = ;
data _bfreqn_;
  set _bfreqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 1 only */
%let _s1brtimess = ;
data _bfreqs1n_;
  set _bfreqs1n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s1rtime);
  else _rts = catx(" ", _rts, _s1rtime);
  call symput('_s1brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 2 only */
%let _s2brtimess = ;
data _bfreqs2n_;
  set _bfreqs2n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s2rtime);
  else _rts = catx(" ", _rts, _s2rtime);
  call symput('_s2brtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: variables that will be used for real time in case times are irregular */
%let brtm  = _rtime; %let s1brtm  = _s1rtime; %let s2brtm  = _s2rtime;

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure model types have been specified */
%if &s1btype = %str() or &s2btype = %str() %then %do;
	%put ERROR: Models must be specified for both segments. Please review!;
  	%return;
%end;

/* eMKF v2.4: Error check to make sure requested models are supported */
%if not(%upcase(&s1btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR) or not(%upcase(&s2btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
		%put ERROR: Models for segments 1 (&s1btype) and 2 (&s2btype) are incompatible or unsupported. Please review!;
  		%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let s1p = 1; %let s2p = 1;
%if %upcase(&s1btype) = BMA_CUBIC  %then %let s1p = 4;
%if %upcase(&s1btype) = BMA_QUAD   %then %let s1p = 3;
%if %upcase(&s1btype) = BMA_LINEAR %then %let s1p = 2;
%if %upcase(&s2btype) = BMA_CUBIC  %then %let s2p = 4;
%if %upcase(&s2btype) = BMA_QUAD   %then %let s2p = 3;
%if %upcase(&s2btype) = BMA_LINEAR %then %let s2p = 2;
%let s1p = %eval(0+&s1p); %let s2p = %eval(0+&s2p);

/* eMKF v2.4: max polynomial ranks s1d-1 and s2d-1 to use in orpoly for segments 1 and 2 */
%let s1d = 1; %let s2d = 1;
%if &s1n > 4 %then %let s1d = 4;	/* cubic allowed in segment 1 */
%else %do;
	%if &s1n > 3 %then %let s1d = 3;	/* quad allowed in segment 1 */
	%else %do;
		%if &s1n > 2 %then %let s1d = 2;	/* linear allowed in segment 1 */
	%end;
%end;
%if &s2n > 4 %then %let s2d = 4;	/* cubic allowed in segment 2 */
%else %do;
	%if &s2n > 3 %then %let s2d = 3;	/* quad allowed in segment 2 */
	%else %do;
		%if &s2n > 2 %then %let s2d = 2; 	/* linear allowed in segment 2 */
	%end;
%end;
%let s1d = %eval(0+&s1d); %let s2d = %eval(0+&s2d); 

/* eMKF v2.4: Error check to make sure requested trend models can be fit */
%if (&s1p > &s1d) or (&s2p > &s2d) %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%if &s1p > &s1d %then %put ERROR- &s1btype was requested for segment 1: there are only enough data for a degree %eval(&s1d-1) polynomial.;; 
	%if &s2p > &s2d %then %put ERROR- &s2btype was requested for segment 2: there are only enough data for a degree %eval(&s2d-1) polynomial.;; 
  	%return;
%end;

/* eMKF v2.4: Error check to reduce model combinations */
%if &s2p > &s1p %then %do;
	%put ERROR: Please ensure polynomial trend for segment 2 does not have higher degree than for segment 1.;
	%put ERROR- &s2btype was requested for segment 2, yet only &s1btype was requested for segment 1.; 
  	%return;
%end;

/* eMKF: Compute variances */
data _bbdata_;
  set _bbdata_ ;
  _var = _se**2;
run;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&borpoly) = YES %then %do;
	proc iml;
	  /* eMKF v2.4: segment 1 */
	  s1x = { &_s1brtimess };
	  s1x = T(s1x);										/* eMKF: column vector with real times */
	  s1oP = orpol(s1x, &s1d - 1);						/* eMKF v2.4: orthonormal design matrix s1oP (s1d > 1 here) */
	  s1x0 = { %cnstss(1, &s1n) };
	  s1x0 = T(s1x0);
	  s1x1 = s1x;
	  %if &s1n > 3 %then s1x2 = s1x#s1x1;;
	  %if &s1n > 4 %then s1x3 = s1x#s1x2;;
	  s1uP = s1x0;										
	  s1uP = s1uP || s1x1;
	  %if &s1n > 3 %then s1uP = s1uP || s1x2;;	
	  %if &s1n > 4 %then s1uP = s1uP || s1x3;;			/* eMKF v2.4: raw/unstandardized design matrix s1uP */
	  s1oP1 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,1];
      s1oP2 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,2];
      %if &s1n > 3 %then s1oP3 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,3];;
      %if &s1n > 4 %then s1oP4 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,4];;
	  s1oPP = s1oP1;									
	  s1oPP = s1oPP || s1oP2;
	  %if &s1n > 3 %then s1oPP = s1oPP || s1oP3;;
	  %if &s1n > 4 %then s1oPP = s1oPP || s1oP4;;		/* eMKF: right multiplication of s1uP with s1oPP produces s1oP */
	  s1oP = s1oP // j(&s2n, &s1d, 0);					/* eMKF v2.4: pad with zeroes */
      /* eMKF v2.4: segment 2 */
	  s2x = { &_s2brtimess };
	  s2x = T(s2x);
 	  s2oP = orpol(s2x, &s2d - 1);
	  s2x0 = { %cnstss(1, &s2n) };
	  s2x0 = T(s2x0);
	  s2x1 = s2x;
	  %if &s2n > 3 %then s2x2 = s2x#s2x1;;
	  %if &s2n > 4 %then s2x3 = s2x#s2x2;;
	  s2uP = s2x0;	
	  s2uP = s2uP || s2x1;	
	  %if &s2n > 3 %then s2uP = s2uP || s2x2;;	
	  %if &s2n > 4 %then s2uP = s2uP || s2x3;;	
	  s2oP1 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,1];
      s2oP2 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,2];
      %if &s2n > 3 %then s2oP3 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,3];;
      %if &s2n > 4 %then s2oP4 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,4];;
	  s2oPP = s2oP1;
	  s2oPP = s2oPP || s2oP2;
	  %if &s2n > 3 %then s2oPP = s2oPP || s2oP3;;
	  %if &s2n > 4 %then s2oPP = s2oPP || s2oP4;;
	  s2oP =  j(&s1n, &s2d, 0) // s2oP;
	  /* eMKF v2.4: off-diagonal blocks and full block matrix oPP */
      s1oPP = s1oPP // j(&s2d, &s1d, 0);
	  s2oPP = j(&s1d, &s2d, 0) // s2oPP;
	  oPP = s1oPP || s2oPP;	
	  /* eMKF v2.4: consecutive time indices and block matrix oP */
	  y = T(do(1, &s1n+&s2n, 1));
	  yP = y || s1oP || s2oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &s1d = 4 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s1brtm.3" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s1brtm.2" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2" "&s2brtm.3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1" "&s2brtm.2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1brtm.0" "&s1brtm.1" "&s2brtm.0" "&s2brtm.1"} ] ;;
	  append from yP; close _oXmat_;
	  %if &s1d = 4 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_bbdata_;
	  by _time;
	run;
	data _bbdata_;
	  merge _bbdata_ _oXmat_;
	  by _time;
	run;
	proc sort data= _bbdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _bbdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _bbdata_ */
	  set _bbdata_;
	  if &s1brtm > 0 then &s1brtm.0 = 1; else &s1brtm.0 = 0;
	  &s1brtm.1 = &s1brtm;
	  %if &s1d > 2 %then &s1brtm.2 = &s1brtm**2;;
	  %if &s1d > 3 %then &s1brtm.3 = &s1brtm**3;;
	  if &s2brtm > 0 then &s2brtm.0 = 1; else &s2brtm.0 = 0;
	  &s2brtm.1 = &s2brtm;
	  %if &s2d > 2 %then &s2brtm.2 = &s2brtm**2;;
	  %if &s2d > 3 %then &s2brtm.3 = &s2brtm**3;;
	run;
%end;

%let brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_ noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("brangeY", range);
run;
%let brangeY = %sysevalf(&brangeY + 0);

%let s1brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s1brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s1brangeY", range);
run;
%let s1brangeY = %sysevalf(&s1brangeY + 0);

%let s2brangeY=;
data _bbjunk;
run;
proc means data=_bbdata_(where=(&s2brtm ne 0)) noprint;
  var _y;
  output out=_bbjunk range=range;
run;
data _null_;
 set _bbjunk;
 call symput("s2brangeY", range);
run;
%let s2brangeY = %sysevalf(&s2brangeY + 0);

/*******************************************************************/
/* eMKF: Set any prior parameters not already provided by the user */
/*******************************************************************/

/* eMKF: c1 in RAND's MKF User's Guide */
%if &s1bmalpha = %str() %then %let s1bmalpha = %sysevalf(0.5 * &s1brangeY);;
%if &s2bmalpha = %str() %then %let s2bmalpha = %sysevalf(0.5 * &s2brangeY);;

/* eMKF: 1/c2 in RAND's MKF User's Guide */	
%if &s1bpalpha = %str() %then %let s1bpalpha = %sysevalf(0.000001/(&s1brangeY**2));; 
%if &s2bpalpha = %str() %then %let s2bpalpha = %sysevalf(0.000001/(&s2brangeY**2));; 

/* eMKF: c7 in RAND's MKF User's Guide */
%if &s1bmbeta1 = %str() %then %let s1bmbeta1 = %sysevalf(0);;
%if &s2bmbeta1 = %str() %then %let s2bmbeta1 = %sysevalf(0);;

/* eMKF: 1/c8 in RAND's MKF User's Guide */	
%if &s1bpbeta1  = %str() %then %let s1bpbeta1  = %sysevalf(0.000001/(&s1brangeY**2));;
%if &s2bpbeta1  = %str() %then %let s2bpbeta1  = %sysevalf(0.000001/(&s2brangeY**2));;

/* eMKF v2.4: added check for negative value */
%if &bmrho  ^= %str() and &bmrho < 0 %then %do;
	%put WARNING: Prior mean &bmrho for transformed AR(1) correlation coefficient is expected to be positive.;
	%put WARNING- Its absolute value will be used instead.;
	%let bmrho = %sysevalf(- &bmrho);
%end;

/* eMKF: c9 in RAND's MKF User's Guide  */	
%if &bmrho    = %str() %then %let  bmrho  = %sysevalf(0);;	

/* eMKF: c10 in RAND's MKF User's Guide  */	
%if &bprho    = %str() %then %let  bprho  = %sysevalf(1);;	

/* eMKF: c11 in RAND's MKF User's Guide  */	
%if &btaul    = %str() %then %let  btaul  = %sysevalf(0.0001);;	

/* eMKF: c12 in RAND's MKF User's Guide  */	
%if &btauu    = %str() %then %let  btauu  = %sysevalf(0.1 * &brangeY);;			

/* eMKF: Set cubic and quad precisions so that the coefficients tend to be smaller in magnitude as the degree increases */
%if &s1bmbeta2 = %str() %then %let s1bmbeta2 = %sysevalf(0);; 
%if &s2bmbeta2 = %str() %then %let s2bmbeta2 = %sysevalf(0);; 
%if &s1bpbeta2 = %str() %then %let s1bpbeta2 = %sysevalf(2.0 * &s1bpbeta1);; 
%if &s2bpbeta2 = %str() %then %let s2bpbeta2 = %sysevalf(2.0 * &s2bpbeta1);; 
%if &s1bmbeta3 = %str() %then %let s1bmbeta3 = %sysevalf(0);; 	
%if &s2bmbeta3 = %str() %then %let s2bmbeta3 = %sysevalf(0);; 	
%if &s1bpbeta3 = %str() %then %let s1bpbeta3 = %sysevalf(4.0 * &s1bpbeta1);; 		
%if &s2bpbeta3 = %str() %then %let s2bpbeta3 = %sysevalf(4.0 * &s2bpbeta1);; 		

/***************************************************************************************/
/* eMKF: Use data to inform prior parameters for variances in the random variance case */
/***************************************************************************************/

%if %upcase(&brndvars) = YES %then %do;
	%let bqrangeV=0; %let bmedianV=0;
	data _bbjunk;
	run;
	proc means data=_bbdata_ noprint;
	  var _var;
	  output out=_bbjunk median=median qrange=qrange;
	run;
	data _null_;
	 set _bbjunk;
	 call symput("bqrangeV", qrange);
	 call symput("bmedianV", median);
	run;
	%let bqrangeV = %sysevalf(&bqrangeV + 0);
	%let bmedianV = %sysevalf(&bmedianV + 0);
	/* eMKF: Use median for mean and 10 times IQR for standard deviation of sampling variances (inverse gamma prior) */
	%if &bvshape = %str() %then %let bvshape = %sysevalf(2 + ( &bmedianV**2 / ((10 * &bqrangeV)**2) ) );;
	%if &bvscale = %str() %then %let bvscale = %sysevalf((&bvshape - 1)*&bmedianV);;
%end;
%else %do;
	%let bvshape =; 
	%let bvscale =;
%end;
 
/*************************************************************/
/* eMKF: Symbolic array declarations (resolved in proc mcmc) */
/*************************************************************/

/* eMKF v2.4: Array structures for BMA weights and prior mixtures */
%if &bwshape = %str() %then %let bwshape = %eval(2);;
%let wtsline = ; 
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%if %upcase(&s2btype) = BMA_CUBIC %then %do;
	    /* allowed combos are: indep cub-cub, cub-qua, cub-lin, qua-qua, qua-lin, lin-lin; common cub-cub, cub-qua, cub-lin, qua-qua, qua-lin, lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[13] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
		%let wtsline = &wtsline array wts[13]%str(;); 
	%end;
	%if %upcase(&s2btype) = BMA_QUAD %then %do;
	    /* allowed combos are: indep cub-qua, cub-lin, qua-qua, qua-lin, lin-lin; common cub-qua, cub-lin, qua-qua, qua-lin, lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[11] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
		%let wtsline = &wtsline array wts[11]%str(;); 
	%end;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	    /* allowed combos are: indep cub-lin, qua-lin, lin-lin; common cub-lin, qua-lin, lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[7] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
		%let wtsline = &wtsline array wts[7]%str(;); 
	%end;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%if %upcase(&s2btype) = BMA_QUAD %then %do;
	    /* allowed combos are: indep qua-qua, qua-lin, lin-lin; common qua-qua, qua-lin, lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[7] (&bwshape &bwshape &bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
		%let wtsline = &wtsline array wts[7]%str(;);
	%end;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	    /* allowed combos are: indep qua-lin, lin-lin; common qua-lin, lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[5] (&bwshape &bwshape &bwshape &bwshape &bwshape)%str(;) ; 
		%let wtsline = &wtsline array wts[5]%str(;);
	%end;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	    /* allowed combos are: indep lin-lin; common lin-lin; drop-drop */
		%let wtsline = &wtsline array wtsshape[3] (&bwshape &bwshape &bwshape)%str(;) ;
		%let wtsline = &wtsline array wts[3]%str(;);
	%end; 
%end;

/* eMKF v2.4: Named 1-dimensional arrays of regression parameters other than intercept (if any) for segments 1 and 2 */
%let s1b1line=; %let s1b2line=; %let s1b3line=; %let s2b1line=; %let s2b2line=; %let s2b3line=; 
%if %upcase(&s1btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %let s1b1line = array s1b1g[&g] s1b1g1-s1b1g&g ;
%if %upcase(&s1btype) in BMA_CUBIC BMA_QUAD 		   %then %let s1b2line = array s1b2g[&g] s1b2g1-s1b2g&g ;
%if %upcase(&s1btype) = BMA_CUBIC 					   %then %let s1b3line = array s1b3g[&g] s1b3g1-s1b3g&g ;
%if %upcase(&s2btype) in BMA_CUBIC BMA_QUAD BMA_LINEAR %then %let s2b1line = array s2b1g[&g] s2b1g1-s2b1g&g ;
%if %upcase(&s2btype) in BMA_CUBIC BMA_QUAD			   %then %let s2b2line = array s2b2g[&g] s2b2g1-s2b2g&g ;
%if %upcase(&s2btype) = BMA_CUBIC 					   %then %let s2b3line = array s2b3g[&g] s2b3g1-s2b3g&g ;

/* eMKF: Named 1-dimensional arrays of unobserved true states and their means
  (consistent with internal SAS names for random effects in proc mcmc) */
%let etamnarrline = array etamnarr[%eval(&g*&n)];
%let etaarrline   = array etaarr[%eval(&g*&n)];
%let _i = 0; %let _j = 0; 
%do _i = 1 %to &g;
   %do _j = 1 %to &n; 
		%let etamnarrline = &etamnarrline etamn&_j._&_i;
		%let etaarrline   = &etaarrline eta&_j._&_i;
   %end;
%end;

/* eMKF: Named 1-dimensional array of random sampling variances (if applicable) */
%let vline=;
%if %upcase(&brndvars) = YES %then %do;
	%let vline = array varr[&g] varr1-varr&g ; 
	%let vline = &vline%str(;) array vhyp[2] (&bvshape &bvscale) ; /* add array of hyperparameters to pass to UDS */
%end;

/* eMKF: Dynamic array of effective sample sizes (if applicable) to use with read_array */
%let Narrline=;
%if %upcase(&brndvars) = YES %then %let Narrline = array Narr[1] /nosymbols ;

/*****************************************************************/
/* eMKF: Symbolic parameter declarations (resolved in proc mcmc) */
/*****************************************************************/

/* eMKF: Slice sampler, if requested, would apply to parameters for which Gibbs sampling is not available */
%let bslice =%str(;) ;
%if %upcase(&bslicesampler) = YES %then %let bslice = %str(/slice ;);

/* eMKF v2.4: Modified group-specific AR parameters (if applicable) to allow for ARH option */
%let tauparline=; %let psiparline=; %let tausqparline=; %let rhoparline=; %let tauparline2=; %let psiparline2=; %let _i=0;
%if %upcase(&bARmodel) = INDEP_AR %then %do;
  	%let psiparline2 = parms spsi &bslice;						/* SD hyperparameter for mean of psi */
  	%let psiparline2 = &psiparline2 parms mpsi &bslice;			/* mean hyperparameter for mean of psi */
	%do _i = 1 %to &g; 
		%let psiparline   = &psiparline psi&_i ; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
		%let rhoparline   = &rhoparline rho&_i ; 
    	%let psiparline2  = &psiparline2 parms psi&_i &bslice;	/* Group-specific psi1 through psi&g  */
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
	%do _i = 1 %to &g; 
		%let tauparline   = &tauparline tau&_i ; 
		%let tausqparline = &tausqparline tausq&_i ; 
    	%let tauparline2  = &tauparline2 parms tau&_i &bslice;	/* Group-specific innovation SDs tau1 through tau&g */
	%end;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
    %let psiparline2 = parms psi &bslice;						/* Common psi = -ln[(1-rho)/(1+rho)] */
    %let tauparline2 = parms tau &bslice;    					/* Common innovation SD tau */
%end;

/* eMKF v2.4: Combined regression coefficients for segments 1 and 2 */
/* eMKF v2.4: Recall parline2 tracks just the group-specific coefficients while parline also track "common" coefficients */
%let parline =; %let parline2 =; 

/* eMKF v2.4: Segment 1 intercepts */
%let s1aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s1aparline = &s1aparline s1ag&_i ; 
%end; 

/* eMKF v2.4: Linear, quadratic, and cubic coefficients, as needed for segment 1 */
%let parline = &parline &s1aparline;
%let parline2 = &parline2 &s1aparline;
%let _i = 0;
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%let parline = &parline s1b1 s1b2 s1b3;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i s1b2g&_i s1b3g&_i ;
		%let parline2 = &parline2 s1b1g&_i s1b2g&_i s1b3g&_i ;
	%end;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%let parline = &parline s1b1 s1b2;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i s1b2g&_i ;
		%let parline2 = &parline2 s1b1g&_i s1b2g&_i ;
	%end;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%let parline = &parline s1b1;
	%do _i = 1 %to &g; 
		%let parline = &parline s1b1g&_i ;
		%let parline2 = &parline2 s1b1g&_i ;
	%end;
%end;

/* eMKF v2.4: Segment 2 intercepts */
%let s2aparline=; %let _i = 0;
%do _i = 1 %to &g; 
	%let s2aparline = &s2aparline s2ag&_i ; 
%end; 

/* eMKF v2.4: Linear, quadratic, and cubic coefficients, as needed for segment 2 */
%let parline = &parline &s2aparline;
%let parline2 = &parline2 &s2aparline;
%let _i = 0;
%if %upcase(&s2btype) = BMA_CUBIC %then %do;
	%let parline = &parline s2b1 s2b2 s2b3;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i s2b2g&_i s2b3g&_i ;
		%let parline2 = &parline2 s2b1g&_i s2b2g&_i s2b3g&_i ;
	%end;
%end;
%if %upcase(&s2btype) = BMA_QUAD %then %do;
	%let parline = &parline s2b1 s2b2;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i s2b2g&_i ;
		%let parline2 = &parline2 s2b1g&_i s2b2g&_i ;
	%end;
%end;
%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	%let parline = &parline s2b1;
	%do _i = 1 %to &g; 
		%let parline = &parline s2b1g&_i ;
		%let parline2 = &parline2 s2b1g&_i ;
	%end;
%end;

/* eMKF: Variance parameters (if applicable) */
%let vparline = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do;
	%do _i = 1 %to &g; 
		%let vparline = &vparline varr&_i ;
	%end;
%end;

/*************************************/
/* eMKF: UDS parameters declarations */
/*************************************/
%let udsparline = ;

/* model flags updated in a separate UDS block [eMKF v2.4: added internal flags for easier model tracking] */
%let udsparline = &udsparline parms iflg flg s1flg s2flg %str(/uds ;);

/* etamnarr updated with the regression coefficients */
%let udsparline = &udsparline parms &parline etamnarr %str(/uds ;);

/* true states updated in a separate UDS block */
%let udsparline = &udsparline parms etaarr %str(/uds ;);

/* variances updated in a separate UDS block (when applicable) */
%if &vparline ^= %str() %then %let udsparline = &udsparline parms &vparline %str(/uds ;);

/**************************************************************************/
/* eMKF: Symbolic prior/hyperprior specifications (resolved in proc mcmc) */
/**************************************************************************/

/* eMKF v2.4: Modified priors for autocorrelation parameter(s) to allow for ARH option */
%let plinetau=; %let plinepsi=; %let hplinempsi=; %let hplinespsi=;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 							/* common AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0); 	/* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior tau ~ uniform(&btaul, &btauu);     	
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 							/* group-specific AR parameters */
	%let plinepsi = prior psi ~ normal(&bmrho, prec=&bprho, lower=0);   /* eMKF v2.4: use zero-truncated normal */ 	
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; 							/* group-specific AR parameters */
	%let hplinespsi = hyperprior spsi ~ uniform(0.0001,sqrt(1/&bprho)); /* Keep away from zero */
	%let hplinempsi = hyperprior mpsi ~ normal(&bmrho, prec=&bprho, lower=0); /* eMKF v2.4: use zero-truncated normal */
	%let plinepsi = prior &psiparline ~ normal(mpsi, sd=spsi, lower=0); 	  /* eMKF v2.4: use zero-truncated normal */
	%let plinetau = prior &tauparline ~ uniform(&btaul, &btauu);   	
%end;

/* eMKF: Prior for mixture weights */
%let plinewts = ;
%if %upcase(&bdirichlet) = YES %then 
	%let plinewts = prior wts ~ dirichlet(wtsshape);

/* eMKF v2.4: Prior for internal-version of latent variable flg */
%let plineflg = prior iflg ~ table(wts);

/* eMKF v2.4: Prior for intercepts ag1 through ag&g in segments 1 and 2 */
%let plines1a = prior &s1aparline ~ normal(&s1bmalpha, prec=&s1bpalpha);
%let plines2a = prior &s2aparline ~ normal(&s2bmalpha, prec=&s2bpalpha);

/**********************************************************************************/
/* eMKF v2.4: Priors for regression parameters other than intercepts in segment 1 */
/**********************************************************************************/

%let plines1b1=; %let plines1b2=; %let plines1b3=;

%if %upcase(&s1btype) = BMA_CUBIC %then %do;

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let plines1b1 = &plines1b1 if s1flg=4 or s1flg=5 or s1flg=6 then lps1b1=lps1b1+lpdfnorm(s1b1,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
	%let plines1b1 = &plines1b1 if (s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7) and %str(abs(s1b1-mean(of s1b1g1-s1b1g&g))>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%let plines1b1 = &plines1b1 prior s1b1 ~ general(lps1b1)%str(;);

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b1 = &plines1b1 if s1flg=1 or s1flg=2 or s1flg=3 then lps1b1=lps1b1+lpdfnorm(s1b1g&_i,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
		%let plines1b1 = &plines1b1 if s1flg=7 and %str(abs(s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
		%let plines1b1 = &plines1b1 if (s1flg=4 or s1flg=5 or s1flg=6) and %str(abs(s1b1-s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b1 = &plines1b1 prior s1b1g: ~ general(lps1b1)%str(;);

	%let plines1b2 = &plines1b2 lps1b2=0%str(;) ;
	%let plines1b2 = &plines1b2 if s1flg=4 or s1flg=5 then lps1b2=lps1b2+lpdfnorm(s1b2,&s1bmbeta2,sqrt(1/&s1bpbeta2))%str(;) ;
	%let plines1b2 = &plines1b2 if s1flg=6 and %str(abs(s1b2)> %sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%let plines1b2 = &plines1b2 if (s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7) and %str(abs(s1b2-mean(of s1b2g1-s1b2g&g))>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%let plines1b2 = &plines1b2 prior s1b2 ~ general(lps1b2)%str(;);

	%let plines1b2 = &plines1b2 lps1b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b2 = &plines1b2 if s1flg=1 or s1flg=2 then lps1b2=lps1b2+lpdfnorm(s1b2g&_i,&s1bmbeta2,sqrt(1/&s1bpbeta2))%str(;) ;
		%let plines1b2 = &plines1b2 if (s1flg=3 or s1flg=7) and %str(abs(s1b2g&_i)>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
		%let plines1b2 = &plines1b2 if (s1flg=4 or s1flg=5 or s1flg=6) and %str(abs(s1b2-s1b2g&_i)>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b2 = &plines1b2 prior s1b2g: ~ general(lps1b2)%str(;);

	%let plines1b3 = &plines1b3 lps1b3=0%str(;) ;
	%let plines1b3 = &plines1b3 if s1flg=4 then lps1b3=lps1b3+lpdfnorm(s1b3,&s1bmbeta3,sqrt(1/&s1bpbeta3))%str(;) ;
	%let plines1b3 = &plines1b3 if (s1flg=5 or s1flg=6) and %str(abs(s1b3)>%sysevalf(1e-11)) then lps1b3=lps1b3-%sysevalf(1e15)%str(;) ;
	%let plines1b3 = &plines1b3 if (s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7) and %str(abs(s1b3-mean(of s1b3g1-s1b3g&g))>%sysevalf(1e-11)) then lps1b3=lps1b3-%sysevalf(1e15)%str(;) ;
	%let plines1b3 = &plines1b3 prior s1b3 ~ general(lps1b3)%str(;);

	%let plines1b3 = &plines1b3 lps1b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b3 = &plines1b3 if s1flg=1 then lps1b3=lps1b3+lpdfnorm(s1b3g&_i,&s1bmbeta3,sqrt(1/&s1bpbeta3))%str(;) ;
		%let plines1b3 = &plines1b3 if (s1flg=2 or s1flg=3 or s1flg=7) and %str(abs(s1b3g&_i)>%sysevalf(1e-11)) then lps1b3=lps1b3-%sysevalf(1e15)%str(;) ;
		%let plines1b3 = &plines1b3 if (s1flg=4 or s1flg=5 or s1flg=6) and %str(abs(s1b3-s1b3g&_i)>%sysevalf(1e-11)) then lps1b3=lps1b3-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b3 = &plines1b3 prior s1b3g: ~ general(lps1b3)%str(;);

%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let plines1b1 = &plines1b1 if s1flg=3 or s1flg=4 then lps1b1=lps1b1+lpdfnorm(s1b1,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
	%let plines1b1 = &plines1b1 if (s1flg=1 or s1flg=2 or s1flg=5) and %str(abs(s1b1-mean(of s1b1g1-s1b1g&g))>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%let plines1b1 = &plines1b1 prior s1b1 ~ general(lps1b1)%str(;);

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b1 = &plines1b1 if s1flg=1 or s1flg=2 then lps1b1=lps1b1+lpdfnorm(s1b1g&_i,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
		%let plines1b1 = &plines1b1 if s1flg=5 and %str(abs(s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
		%let plines1b1 = &plines1b1 if (s1flg=3 or s1flg=4) and %str(abs(s1b1-s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b1 = &plines1b1 prior s1b1g: ~ general(lps1b1)%str(;);

	%let plines1b2 = &plines1b2 lps1b2=0%str(;) ;
	%let plines1b2 = &plines1b2 if s1flg=3 then lps1b2=lps1b2+lpdfnorm(s1b2,&s1bmbeta2,sqrt(1/&s1bpbeta2))%str(;) ;
	%let plines1b2 = &plines1b2 if s1flg=4 and %str(abs(s1b2)>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%let plines1b2 = &plines1b2 if (s1flg=1 or s1flg=2 or s1flg=5) and %str(abs(s1b2-mean(of s1b2g1-s1b2g&g))>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%let plines1b2 = &plines1b2 prior s1b2 ~ general(lps1b2)%str(;);

	%let plines1b2 = &plines1b2 lps1b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b2 = &plines1b2 if s1flg=1 then lps1b2=lps1b2+lpdfnorm(s1b2g&_i,&s1bmbeta2,sqrt(1/&s1bpbeta2))%str(;) ;
		%let plines1b2 = &plines1b2 if (s1flg=2 or s1flg=5) and %str(abs(s1b2g&_i)>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
		%let plines1b2 = &plines1b2 if (s1flg=3 or s1flg=4) and %str(abs(s1b2-s1b2g&_i)>%sysevalf(1e-11)) then lps1b2=lps1b2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b2 = &plines1b2 prior s1b2g: ~ general(lps1b2)%str(;);

%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let plines1b1 = &plines1b1 if s1flg=2 then lps1b1=lps1b1+lpdfnorm(s1b1,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
	%let plines1b1 = &plines1b1 if (s1flg=1 or s1flg=3) and %str(abs(s1b1-mean(of s1b1g1-s1b1g&g))>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%let plines1b1 = &plines1b1 prior s1b1 ~ general(lps1b1)%str(;);

	%let plines1b1 = &plines1b1 lps1b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines1b1 = &plines1b1 if s1flg=1 then lps1b1=lps1b1+lpdfnorm(s1b1g&_i,&s1bmbeta1,sqrt(1/&s1bpbeta1))%str(;) ;
		%let plines1b1 = &plines1b1 if s1flg=3 and %str(abs(s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
		%let plines1b1 = &plines1b1 if s1flg=2 and %str(abs(s1b1-s1b1g&_i)>%sysevalf(1e-11)) then lps1b1=lps1b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines1b1 = &plines1b1 prior s1b1g: ~ general(lps1b1)%str(;);

%end;

/**********************************************************************************/
/* eMKF v2.4: Priors for regression parameters other than intercepts in segment 2 */
/**********************************************************************************/

%let plines2b1=; %let plines2b2=; %let plines2b3=;

%if %upcase(&s2btype) = BMA_CUBIC %then %do;

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let plines2b1 = &plines2b1 if s2flg=4 or s2flg=5 or s2flg=6 then lps2b1=lps2b1+lpdfnorm(s2b1,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
	%let plines2b1 = &plines2b1 if (s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7) and %str(abs(s2b1-mean(of s2b1g1-s2b1g&g))>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%let plines2b1 = &plines2b1 prior s2b1 ~ general(lps2b1)%str(;);

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b1 = &plines2b1 if s2flg=1 or s2flg=2 or s2flg=3 then lps2b1=lps2b1+lpdfnorm(s2b1g&_i,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
		%let plines2b1 = &plines2b1 if s2flg=7 and %str(abs(s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
		%let plines2b1 = &plines2b1 if (s2flg=4 or s2flg=5 or s2flg=6) and %str(abs(s2b1-s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b1 = &plines2b1 prior s2b1g: ~ general(lps2b1)%str(;);

	%let plines2b2 = &plines2b2 lps2b2=0%str(;) ;
	%let plines2b2 = &plines2b2 if s2flg=4 or s2flg=5 then lps2b2=lps2b2+lpdfnorm(s2b2,&s2bmbeta2,sqrt(1/&s2bpbeta2))%str(;) ;
	%let plines2b2 = &plines2b2 if s2flg=6 and %str(abs(s2b2)> %sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%let plines2b2 = &plines2b2 if (s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7) and %str(abs(s2b2-mean(of s2b2g1-s2b2g&g))>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%let plines2b2 = &plines2b2 prior s2b2 ~ general(lps2b2)%str(;);

	%let plines2b2 = &plines2b2 lps2b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b2 = &plines2b2 if s2flg=1 or s2flg=2 then lps2b2=lps2b2+lpdfnorm(s2b2g&_i,&s2bmbeta2,sqrt(1/&s2bpbeta2))%str(;) ;
		%let plines2b2 = &plines2b2 if (s2flg=3 or s2flg=7) and %str(abs(s2b2g&_i)>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
		%let plines2b2 = &plines2b2 if (s2flg=4 or s2flg=5 or s2flg=6) and %str(abs(s2b2-s2b2g&_i)>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b2 = &plines2b2 prior s2b2g: ~ general(lps2b2)%str(;);

	%let plines2b3 = &plines2b3 lps2b3=0%str(;) ;
	%let plines2b3 = &plines2b3 if s2flg=4 then lps2b3=lps2b3+lpdfnorm(s2b3,&s2bmbeta3,sqrt(1/&s2bpbeta3))%str(;) ;
	%let plines2b3 = &plines2b3 if (s2flg=5 or s2flg=6) and %str(abs(s2b3)>%sysevalf(1e-11)) then lps2b3=lps2b3-%sysevalf(1e15)%str(;) ;
	%let plines2b3 = &plines2b3 if (s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7) and %str(abs(s2b3-mean(of s2b3g1-s2b3g&g))>%sysevalf(1e-11)) then lps2b3=lps2b3-%sysevalf(1e15)%str(;) ;
	%let plines2b3 = &plines2b3 prior s2b3 ~ general(lps2b3)%str(;);

	%let plines2b3 = &plines2b3 lps2b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b3 = &plines2b3 if s2flg=1 then lps2b3=lps2b3+lpdfnorm(s2b3g&_i,&s2bmbeta3,sqrt(1/&s2bpbeta3))%str(;) ;
		%let plines2b3 = &plines2b3 if (s2flg=2 or s2flg=3 or s2flg=7) and %str(abs(s2b3g&_i)>%sysevalf(1e-11)) then lps2b3=lps2b3-%sysevalf(1e15)%str(;) ;
		%let plines2b3 = &plines2b3 if (s2flg=4 or s2flg=5 or s2flg=6) and %str(abs(s2b3-s2b3g&_i)>%sysevalf(1e-11)) then lps2b3=lps2b3-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b3 = &plines2b3 prior s2b3g: ~ general(lps2b3)%str(;);

%end;
%if %upcase(&s2btype) = BMA_QUAD %then %do;

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let plines2b1 = &plines2b1 if s2flg=3 or s2flg=4 then lps2b1=lps2b1+lpdfnorm(s2b1,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
	%let plines2b1 = &plines2b1 if (s2flg=1 or s2flg=2 or s2flg=5) and %str(abs(s2b1-mean(of s2b1g1-s2b1g&g))>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%let plines2b1 = &plines2b1 prior s2b1 ~ general(lps2b1)%str(;);

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b1 = &plines2b1 if s2flg=1 or s2flg=2 then lps2b1=lps2b1+lpdfnorm(s2b1g&_i,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
		%let plines2b1 = &plines2b1 if s2flg=5 and %str(abs(s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
		%let plines2b1 = &plines2b1 if (s2flg=3 or s2flg=4) and %str(abs(s2b1-s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b1 = &plines2b1 prior s2b1g: ~ general(lps2b1)%str(;);

	%let plines2b2 = &plines2b2 lps2b2=0%str(;) ;
	%let plines2b2 = &plines2b2 if s2flg=3 then lps2b2=lps2b2+lpdfnorm(s2b2,&s2bmbeta2,sqrt(1/&s2bpbeta2))%str(;) ;
	%let plines2b2 = &plines2b2 if s2flg=4 and %str(abs(s2b2)>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%let plines2b2 = &plines2b2 if (s2flg=1 or s2flg=2 or s2flg=5) and %str(abs(s2b2-mean(of s2b2g1-s2b2g&g))>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%let plines2b2 = &plines2b2 prior s2b2 ~ general(lps2b2)%str(;);

	%let plines2b2 = &plines2b2 lps2b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b2 = &plines2b2 if s2flg=1 then lps2b2=lps2b2+lpdfnorm(s2b2g&_i,&s2bmbeta2,sqrt(1/&s2bpbeta2))%str(;) ;
		%let plines2b2 = &plines2b2 if (s2flg=2 or s2flg=5) and %str(abs(s2b2g&_i)>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
		%let plines2b2 = &plines2b2 if (s2flg=3 or s2flg=4) and %str(abs(s2b2-s2b2g&_i)>%sysevalf(1e-11)) then lps2b2=lps2b2-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b2 = &plines2b2 prior s2b2g: ~ general(lps2b2)%str(;);

%end;
%if %upcase(&s2btype) = BMA_LINEAR %then %do;

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let plines2b1 = &plines2b1 if s2flg=2 then lps2b1=lps2b1+lpdfnorm(s2b1,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
	%let plines2b1 = &plines2b1 if (s2flg=1 or s2flg=3) and %str(abs(s2b1-mean(of s2b1g1-s2b1g&g))>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%let plines2b1 = &plines2b1 prior s2b1 ~ general(lps2b1)%str(;);

	%let plines2b1 = &plines2b1 lps2b1=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
	    %let plines2b1 = &plines2b1 if s2flg=1 then lps2b1=lps2b1+lpdfnorm(s2b1g&_i,&s2bmbeta1,sqrt(1/&s2bpbeta1))%str(;) ;
		%let plines2b1 = &plines2b1 if s2flg=3 and %str(abs(s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
		%let plines2b1 = &plines2b1 if s2flg=2 and %str(abs(s2b1-s2b1g&_i)>%sysevalf(1e-11)) then lps2b1=lps2b1-%sysevalf(1e15)%str(;) ;
	%end;
	%let plines2b1 = &plines2b1 prior s2b1g: ~ general(lps2b1)%str(;);

%end;

/* eMKF: Prior for variance parameters */
%let plinev=;
%if %upcase(&brndvars) = YES %then 
	%let plinev = prior varr: ~ igamma(&bvshape, scale=&bvscale);

/******************************************************************************/
/* eMKF: Symbolic initialization for model parameters (resolved in proc mcmc) */
/******************************************************************************/

/* eMKF v2.4: Modified initial values for AR parameters to allow for ARH option and sampling from zero-truncated normal */
%let initlinetau = ; %let initlinepsi = ; %let _i = 0;
%if %upcase(&bARmodel) = COMMON_AR %then %do; 	/*common AR parameters */
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%let initlinetau = tau = rand('uniform', &btaul, &btauu); 
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do; 
	%let initlinepsi = psi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I);
	%do _i = 1 %to &g;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;
%if %upcase(&bARmodel) = INDEP_AR %then %do; /* Group-specific AR parameters */
    %let initlinepsi = &initlinepsi spsi = rand('uniform', 0.0001, sqrt(1/&bprho))%str(;) ;		
    %let initlinepsi = &initlinepsi mpsi = rtnorm(&bmrho, sqrt(1/&bprho), 0, .I)%str(;) ;
	%do _i = 1 %to &g;
		%let initlinepsi = &initlinepsi psi&_i=rtnorm(mpsi, spsi, 0, .I)%str(;) ;
		%let initlinetau = &initlinetau tau&_i=rand('uniform',&btaul,&btauu)%str(;) ;
	%end;	
%end;

/* eMKF v2.4: Dimensionality for do loops to initialize mixture parameters */
%let _ll=0;
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%if %upcase(&s2btype) = BMA_CUBIC  %then %let _ll = 13;
	%if %upcase(&s2btype) = BMA_QUAD   %then %let _ll = 11;
	%if %upcase(&s2btype) = BMA_LINEAR %then %let _ll = 7;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%if %upcase(&s2btype) = BMA_QUAD   %then %let _ll = 7;
	%if %upcase(&s2btype) = BMA_LINEAR %then %let _ll = 5;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do; 
	%if %upcase(&s2btype) = BMA_LINEAR %then %let _ll = 3;
%end;
%let _ll = %eval(0+&_ll);

/* eMKF: Initial values for mixture weights */
%let initlinewts = wtssum = 0%str(;) ; %let _l=0; 
%do _l=1 %to &_ll; 
	%if %upcase(&bdirichlet) = YES %then %do; /* eMKF v2.4 streamlining: Added explicit Dirichlet option */
		%let initlinewts = &initlinewts wts[&_l] = rand('gamma', wtsshape[&_l])%str(;) ;
	%end;
	%else %do;
		%let initlinewts = &initlinewts wts[&_l] = wtsshape[&_l]%str(;) ; 
	%end;
	%let initlinewts = &initlinewts wtssum = wtssum + wts[&_l]%str(;) ;
%end;

/* eMKF: Rescale wts to sum to one */
%let _l=0;
%do _l=1 %to &_ll;		
	%let initlinewts = &initlinewts wts[&_l] = wts[&_l]/wtssum%str(;) ;
%end;

/* eMKF v2.4: Initial values for internal latent variable iflg with successive values 1 through _ll */
%let initlineflg = ; %let _l=0;
%do _l=1 %to &_ll; 
	%let initlineflg = &initlineflg %str(,) wts[&_l]; 
%end;
%let initlineflg = iflg = rand('table' &initlineflg);

/* eMKF v2.4: Recode of iflg to use parent model-specific nomenclature (flg) */
%let recodeflg = ;
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%if %upcase(&s2btype) = BMA_CUBIC %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=12%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=13%str(;);
		%let recodeflg = &recodeflg if iflg=4 then flg=22%str(;);
		%let recodeflg = &recodeflg if iflg=5 then flg=23%str(;);
		%let recodeflg = &recodeflg if iflg=6 then flg=33%str(;);
		%let recodeflg = &recodeflg if iflg=7 then flg=44%str(;);
		%let recodeflg = &recodeflg if iflg=8 then flg=45%str(;);
		%let recodeflg = &recodeflg if iflg=9 then flg=46%str(;);
		%let recodeflg = &recodeflg if iflg=10 then flg=55%str(;);
		%let recodeflg = &recodeflg if iflg=11 then flg=56%str(;);
		%let recodeflg = &recodeflg if iflg=12 then flg=66%str(;);
		%let recodeflg = &recodeflg if iflg=13 then flg=77%str(;);
	%end;
	%if %upcase(&s2btype) = BMA_QUAD %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=12%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=21%str(;);
		%let recodeflg = &recodeflg if iflg=4 then flg=22%str(;);
		%let recodeflg = &recodeflg if iflg=5 then flg=32%str(;);
		%let recodeflg = &recodeflg if iflg=6 then flg=43%str(;);
		%let recodeflg = &recodeflg if iflg=7 then flg=44%str(;);
		%let recodeflg = &recodeflg if iflg=8 then flg=53%str(;);
		%let recodeflg = &recodeflg if iflg=9 then flg=54%str(;);
		%let recodeflg = &recodeflg if iflg=10 then flg=64%str(;);
		%let recodeflg = &recodeflg if iflg=11 then flg=75%str(;);
	%end;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=21%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=31%str(;);
		%let recodeflg = &recodeflg if iflg=4 then flg=42%str(;);
		%let recodeflg = &recodeflg if iflg=5 then flg=52%str(;);
		%let recodeflg = &recodeflg if iflg=6 then flg=62%str(;);
		%let recodeflg = &recodeflg if iflg=7 then flg=73%str(;);
	%end;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%if %upcase(&s2btype) = BMA_QUAD %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=12%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=22%str(;);
		%let recodeflg = &recodeflg if iflg=4 then flg=33%str(;);
		%let recodeflg = &recodeflg if iflg=5 then flg=34%str(;);
		%let recodeflg = &recodeflg if iflg=6 then flg=44%str(;);
		%let recodeflg = &recodeflg if iflg=7 then flg=55%str(;);
	%end;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=21%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=32%str(;);
		%let recodeflg = &recodeflg if iflg=4 then flg=42%str(;);
		%let recodeflg = &recodeflg if iflg=5 then flg=53%str(;);
	%end;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%if %upcase(&s2btype) = BMA_LINEAR %then %do;
		%let recodeflg = &recodeflg if iflg=1 then flg=11%str(;);
		%let recodeflg = &recodeflg if iflg=2 then flg=22%str(;);
		%let recodeflg = &recodeflg if iflg=3 then flg=33%str(;);
	%end;
%end;

/* eMKF v2.4: Initial/constant values for prior mean vector mbetag and precision matrix Dbetag for use with matrix operations */
/* eMKF v2.4: note change in dimensionality */
%let initmbeta = call zeromatrix(Dbetag);
	
/* eMKF v2.4: segment 1 */
%let initmbeta = &initmbeta%str(;) mbetag[1,1] = &s1bmalpha%str(;) Dbetag[1,1] = &s1bpalpha;
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s1bmbeta1%str(;) Dbetag[2,2] = &s1bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &s1bmbeta2%str(;) Dbetag[3,3] = &s1bpbeta2;
	%let initmbeta = &initmbeta%str(;) mbetag[4,1] = &s1bmbeta3%str(;) Dbetag[4,4] = &s1bpbeta3;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s1bmbeta1%str(;) Dbetag[2,2] = &s1bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3,1] = &s1bmbeta2%str(;) Dbetag[3,3] = &s1bpbeta2;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2,1] = &s1bmbeta1%str(;) Dbetag[2,2] = &s1bpbeta1;
%end;

/* eMKF v2.4: segment 2 */
%let initmbeta = &initmbeta%str(;) mbetag[1+&s1p,1] = &s2bmalpha%str(;) Dbetag[1+&s1p,1+&s1p] = &s2bpalpha;
%if %upcase(&s2btype) = BMA_CUBIC %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2+&s1p,1] = &s2bmbeta1%str(;) Dbetag[2+&s1p,2+&s1p] = &s2bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3+&s1p,1] = &s2bmbeta2%str(;) Dbetag[3+&s1p,3+&s1p] = &s2bpbeta2;
	%let initmbeta = &initmbeta%str(;) mbetag[4+&s1p,1] = &s2bmbeta3%str(;) Dbetag[4+&s1p,4+&s1p] = &s2bpbeta3;
%end;
%if %upcase(&s2btype) = BMA_QUAD %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2+&s1p,1] = &s2bmbeta1%str(;) Dbetag[2+&s1p,2+&s1p] = &s2bpbeta1;
	%let initmbeta = &initmbeta%str(;) mbetag[3+&s1p,1] = &s2bmbeta2%str(;) Dbetag[3+&s1p,3+&s1p] = &s2bpbeta2;
%end;
%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	%let initmbeta = &initmbeta%str(;) mbetag[2+&s1p,1] = &s2bmbeta1%str(;) Dbetag[2+&s1p,2+&s1p] = &s2bpbeta1;
%end;

/* eMKF v2.4: Initial values for intercepts in segments 1 and 2 */
%let initlines1a=; %let initlines2a=; %let _i=0;
%do _i = 1 %to &g; 
	%let initlines1a = &initlines1a s1ag&_i = &s1bmalpha+sqrt(1/&s1bpalpha)*rand('normal')%str(;) ;
	%let initlines2a = &initlines2a s2ag&_i = &s2bmalpha+sqrt(1/&s2bpalpha)*rand('normal')%str(;) ;
%end;

/*********************************************************************/
/* eMKF v2.4: Initial values for regression parameters for segment 1 */
/*********************************************************************/

%let initlines1b1=; %let initlines1b2=; %let initlines1b3=; 

%if %upcase(&s1btype) = BMA_CUBIC %then %do;

	%let initlines1b3 = &initlines1b3 if s1flg=4 then s1b3=&s1bmbeta3+sqrt(1/&s1bpbeta3)*rand('normal')%str(;) ;
	%let initlines1b3 = &initlines1b3 if s1flg=5 or s1flg=6 then s1b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b3 = &initlines1b3 if s1flg=1 then s1b3g&_i=&s1bmbeta3+sqrt(1/&s1bpbeta3)*rand('normal')%str(;) ;
		%let initlines1b3 = &initlines1b3 if s1flg=2 or s1flg=3 or s1flg=7 then s1b3g&_i=0%str(;) ;
		%let initlines1b3 = &initlines1b3 if s1flg=4 or s1flg=5 or s1flg=6 then s1b3g&_i=s1b3%str(;) ;
	%end;
	%let initlines1b3 = &initlines1b3 %str(if s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7 then s1b3=mean(of s1b3g1-s1b3g&g);) ;

	%let initlines1b2 = &initlines1b2 if s1flg=4 or s1flg=5 then s1b2=&s1bmbeta2+sqrt(1/&s1bpbeta2)*rand('normal')%str(;) ;
	%let initlines1b2 = &initlines1b2 if s1flg=6 then s1b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b2 = &initlines1b2 if s1flg=1 or s1flg=2 then s1b2g&_i=&s1bmbeta2+sqrt(1/&s1bpbeta2)*rand('normal')%str(;) ;
		%let initlines1b2 = &initlines1b2 if s1flg=3 or s1flg=7 then s1b2g&_i=0%str(;) ;
		%let initlines1b2 = &initlines1b2 if s1flg=4 or s1flg=5 or s1flg=6 then s1b2g&_i=s1b2%str(;) ;
	%end;
	%let initlines1b2 = &initlines1b2 %str(if s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7 then s1b2=mean(of s1b2g1-s1b2g&g);) ;

	%let initlines1b1 = &initlines1b1 if s1flg=4 or s1flg=5 or s1flg=6 then s1b1=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b1 = &initlines1b1 if s1flg=1 or s1flg=2 or s1flg=3 then s1b1g&_i=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=7 then s1b1g&_i=0%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=4 or s1flg=5 or s1flg=6 then s1b1g&_i=s1b1%str(;) ;
	%end;
	%let initlines1b1 = &initlines1b1 %str(if s1flg=1 or s1flg=2 or s1flg=3 or s1flg=7 then s1b1=mean(of s1b1g1-s1b1g&g);) ;

%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;

	%let initlines1b2 = &initlines1b2 if s1flg=3 then s1b2=&s1bmbeta2+sqrt(1/&s1bpbeta2)*rand('normal')%str(;) ;
	%let initlines1b2 = &initlines1b2 if s1flg=4 then s1b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b2 = &initlines1b2 if s1flg=1 then s1b2g&_i=&s1bmbeta2+sqrt(1/&s1bpbeta2)*rand('normal')%str(;) ;
		%let initlines1b2 = &initlines1b2 if s1flg=2 or s1flg=5 then s1b2g&_i=0%str(;) ;
		%let initlines1b2 = &initlines1b2 if s1flg=3 or s1flg=4 then s1b2g&_i=s1b2%str(;) ;
	%end;
	%let initlines1b2 = &initlines1b2 %str(if s1flg=1 or s1flg=2 or s1flg=5 then s1b2=mean(of s1b2g1-s1b2g&g);) ;

	%let initlines1b1 = &initlines1b1 if s1flg=3 or s1flg=4 then s1b1=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b1 = &initlines1b1 if s1flg=1 or s1flg=2 then s1b1g&_i=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=5 then s1b1g&_i=0%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=3 or s1flg=4 then s1b1g&_i=s1b1%str(;) ;
	%end;
	%let initlines1b1 = &initlines1b1 %str(if s1flg=1 or s1flg=2 or s1flg=5 then s1b1=mean(of s1b1g1-s1b1g&g);) ;

%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;

	%let initlines1b1 = &initlines1b1 if s1flg=2 then s1b1=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines1b1 = &initlines1b1 if s1flg=1 then s1b1g&_i=&s1bmbeta1+sqrt(1/&s1bpbeta1)*rand('normal')%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=3 then s1b1g&_i=0%str(;) ;
		%let initlines1b1 = &initlines1b1 if s1flg=2 then s1b1g&_i=s1b1%str(;) ;
	%end;
	%let initlines1b1 = &initlines1b1 %str(if s1flg=1 or s1flg=3 then s1b1=mean(of s1b1g1-s1b1g&g);) ;

%end;

/*********************************************************************/
/* eMKF v2.4: Initial values for regression parameters for segment 2 */
/*********************************************************************/

%let initlines2b1=; %let initlines2b2=; %let initlines2b3=; 

%if %upcase(&s2btype) = BMA_CUBIC %then %do;

	%let initlines2b3 = &initlines2b3 if s2flg=4 then s2b3=&s2bmbeta3+sqrt(1/&s2bpbeta3)*rand('normal')%str(;) ;
	%let initlines2b3 = &initlines2b3 if s2flg=5 or s2flg=6 then s2b3=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b3 = &initlines2b3 if s2flg=1 then s2b3g&_i=&s2bmbeta3+sqrt(1/&s2bpbeta3)*rand('normal')%str(;) ;
		%let initlines2b3 = &initlines2b3 if s2flg=2 or s2flg=3 or s2flg=7 then s2b3g&_i=0%str(;) ;
		%let initlines2b3 = &initlines2b3 if s2flg=4 or s2flg=5 or s2flg=6 then s2b3g&_i=s2b3%str(;) ;
	%end;
	%let initlines2b3 = &initlines2b3 %str(if s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7 then s2b3=mean(of s2b3g1-s2b3g&g);) ;

	%let initlines2b2 = &initlines2b2 if s2flg=4 or s2flg=5 then s2b2=&s2bmbeta2+sqrt(1/&s2bpbeta2)*rand('normal')%str(;) ;
	%let initlines2b2 = &initlines2b2 if s2flg=6 then s2b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b2 = &initlines2b2 if s2flg=1 or s2flg=2 then s2b2g&_i=&s2bmbeta2+sqrt(1/&s2bpbeta2)*rand('normal')%str(;) ;
		%let initlines2b2 = &initlines2b2 if s2flg=3 or s2flg=7 then s2b2g&_i=0%str(;) ;
		%let initlines2b2 = &initlines2b2 if s2flg=4 or s2flg=5 or s2flg=6 then s2b2g&_i=s2b2%str(;) ;
	%end;
	%let initlines2b2 = &initlines2b2 %str(if s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7 then s2b2=mean(of s2b2g1-s2b2g&g);) ;

	%let initlines2b1 = &initlines2b1 if s2flg=4 or s2flg=5 or s2flg=6 then s2b1=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b1 = &initlines2b1 if s2flg=1 or s2flg=2 or s2flg=3 then s2b1g&_i=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=7 then s2b1g&_i=0%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=4 or s2flg=5 or s2flg=6 then s2b1g&_i=s2b1%str(;) ;
	%end;
	%let initlines2b1 = &initlines2b1 %str(if s2flg=1 or s2flg=2 or s2flg=3 or s2flg=7 then s2b1=mean(of s2b1g1-s2b1g&g);) ;

%end;
%if %upcase(&s2btype) = BMA_QUAD %then %do;

	%let initlines2b2 = &initlines2b2 if s2flg=3 then s2b2=&s2bmbeta2+sqrt(1/&s2bpbeta2)*rand('normal')%str(;) ;
	%let initlines2b2 = &initlines2b2 if s2flg=4 then s2b2=0%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b2 = &initlines2b2 if s2flg=1 then s2b2g&_i=&s2bmbeta2+sqrt(1/&s2bpbeta2)*rand('normal')%str(;) ;
		%let initlines2b2 = &initlines2b2 if s2flg=2 or s2flg=5 then s2b2g&_i=0%str(;) ;
		%let initlines2b2 = &initlines2b2 if s2flg=3 or s2flg=4 then s2b2g&_i=s2b2%str(;) ;
	%end;
	%let initlines2b2 = &initlines2b2 %str(if s2flg=1 or s2flg=2 or s2flg=5 then s2b2=mean(of s2b2g1-s2b2g&g);) ;

	%let initlines2b1 = &initlines2b1 if s2flg=3 or s2flg=4 then s2b1=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b1 = &initlines2b1 if s2flg=1 or s2flg=2 then s2b1g&_i=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=5 then s2b1g&_i=0%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=3 or s2flg=4 then s2b1g&_i=s2b1%str(;) ;
	%end;
	%let initlines2b1 = &initlines2b1 %str(if s2flg=1 or s2flg=2 or s2flg=5 then s2b1=mean(of s2b1g1-s2b1g&g);) ;

%end;
%if %upcase(&s2btype) = BMA_LINEAR %then %do;

	%let initlines2b1 = &initlines2b1 if s2flg=2 then s2b1=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
	%let _i = 0;
	%do _i = 1 %to &g; 
		%let initlines2b1 = &initlines2b1 if s2flg=1 then s2b1g&_i=&s2bmbeta1+sqrt(1/&s2bpbeta1)*rand('normal')%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=3 then s2b1g&_i=0%str(;) ;
		%let initlines2b1 = &initlines2b1 if s2flg=2 then s2b1g&_i=s2b1%str(;) ;
	%end;
	%let initlines2b1 = &initlines2b1 %str(if s2flg=1 or s2flg=3 then s2b1=mean(of s2b1g1-s2b1g&g);) ;

%end;

/********************************************************************************************************/
/* eMKF v2.4: Initial values for unobserved true states predictions given regression parameters         */
/* eMKF v2.4: To keep length of macro variable under control, calculations are split up by segment here */
/********************************************************************************************************/

%let _i = 0; %let _j = 0; /* Segment 1 */
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
    %do _i = 1 %to &g; 
	    %local inits1etamnarr&_i;   /* eMKF: broken up into one macro variable per group instead of single combined macro variable to avoid max length error (65534) */
  	    %do _j = 1 %to &s1n; 
	        %let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i+X[&_j,3]*s1b2g&_i+X[&_j,4]*s1b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
	  		%let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i+X[&_j,3]*s1b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local inits1etamnarr&_i;
  		%do _j = 1 %to &s1n; 
			%let inits1etamnarr&_i = &&inits1etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1]*s1ag&_i+X[&_j,2]*s1b1g&_i%str(;) ;
		%end;
	%end;
%end;

%let _i = 0; %let _j = 0; /* Segment 2 */
%if %upcase(&s2btype) = BMA_CUBIC %then %do;
    %do _i = 1 %to &g; 
	    %local inits2etamnarr&_i;  
  	    %do _j = 1+&s1n %to &n; 
	        %let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i+X[&_j,3+&s1p]*s2b2g&_i+X[&_j,4+&s1p]*s2b3g&_i%str(;) ;
	    %end;
    %end;
%end;
%if %upcase(&s2btype) = BMA_QUAD %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
	  		%let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i+X[&_j,3+&s1p]*s2b2g&_i%str(;) ;
		%end;
	%end;
%end;
%if %upcase(&s2btype) = BMA_LINEAR %then %do;
	%do _i = 1 %to &g; 
  	    %local inits2etamnarr&_i;
  		%do _j = 1+&s1n %to &n; 
			%let inits2etamnarr&_i = &&inits2etamnarr&_i etamnarr[%eval((&_i-1)*&n+&_j)]=X[&_j,1+&s1p]*s2ag&_i+X[&_j,2+&s1p]*s2b1g&_i%str(;) ;
		%end;
	%end;
%end;

/* eMKF: Initial values for variance parameters from igamma(&bvshape, scale=&bvscale) (if applicable) */
%let initlinevarr = ; %let _i = 0;
%if %upcase(&brndvars) = YES %then %do; 
	%do _i = 1 %to &g;
		%let initlinevarr = &initlinevarr varr&_i=1/rand('gamma',&bvshape,1/&bvscale)%str(;) ;
	%end;
%end;

/* eMKF: temporary dataset for building group-specific design matrix */
/* eMKF v2.4: modified to allow for segment-specific parameters */
data _bbdata1_;
  set _bbdata_(where=(_group_ = 1));
  keep &s1brtm.0 &s1brtm.1 %if &s1d > 2 %then &s1brtm.2; %if &s1d > 3 %then &s1brtm.3; 
  	   &s2brtm.0 &s2brtm.1 %if &s2d > 2 %then &s2brtm.2; %if &s2d > 3 %then &s2brtm.3; 
  ;
run;

/* eMKF: applicable read_array statement for the design matrix */
/* eMKF v2.4: note change in dimensionality */
%let rcXline = ;
%if &s1p = 2 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s2brtm.0'),resolve('&s2brtm.1'));
%if &s1p = 3 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s2brtm.0'),resolve('&s2brtm.1'));
%if &s1p = 3 and &s2p = 3 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s2brtm.0'),resolve('&s2brtm.1'), resolve('&s2brtm.2'));
%if &s1p = 4 and &s2p = 2 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'));
%if &s1p = 4 and &s2p = 3 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'), resolve('&s2brtm.2'));
%if &s1p = 4 and &s2p = 4 %then %let rcXline= rcX= read_array('_bbdata1_',Xarr, resolve('&s1brtm.0'),resolve('&s1brtm.1'),resolve('&s1brtm.2'),resolve('&s1brtm.3'),resolve('&s2brtm.0'), resolve('&s2brtm.1'), resolve('&s2brtm.2'), resolve('&s2brtm.3'));

/* eMKF: applicable read_array statement for the effective sample sizes */
%let rcNline = ;
%if %upcase(&brndvars) = YES %then %let	rcNline = rcN = read_array('_bbdata_', Narr, '_n');

/*************************************************************************************/
/* eMKF: Applicable UDS statements - see macros gibbs_uds_compile_** for definitions  */
/*      These will be applied in the order provided here, and after any M-H samplers */
/*************************************************************************************/
%let udsline = ;
 
/* eMKF v2.4: UDS statement for model flag, including both versions iflg and flg */
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%if %upcase(&s2btype) = BMA_CUBIC %then
		%let udsline = &udsline uds FP_xptf_bmac_bmac(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
	%if %upcase(&s2btype) = BMA_QUAD %then
		%let udsline = &udsline uds FP_xptf_bmac_bmaq(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds FP_xptf_bmac_bmal(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%if %upcase(&s2btype) = BMA_QUAD %then
		%let udsline = &udsline uds FP_xptf_bmaq_bmaq(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds FP_xptf_bmaq_bmal(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds FP_xptf_bmal_bmal(iflg, flg, s1flg, s2flg, wts, s1ag, s2ag, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr)%str(;) ;
%end;

/* eMKF v2.4: UDS statement for regression coefficients, revised to accomodate additional intercept for segment 2  */
/* The pseudo-parameter etamnarr is also updated in those subroutines to hold the updated regression predictions */
%if %upcase(&s1btype) = BMA_CUBIC %then %do;
	%if %upcase(&s2btype) = BMA_CUBIC %then
		%let udsline = &udsline uds CP_xptf_bmac_bmac(s1ag, s1b1g, s1b2g, s1b3g, s1b1, s1b2, s1b3, s2ag, s2b1g, s2b2g, s2b3g, s2b1, s2b2, s2b3,
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
	%if %upcase(&s2btype) = BMA_QUAD %then
		%let udsline = &udsline uds CP_xptf_bmac_bmaq(s1ag, s1b1g, s1b2g, s1b3g, s1b1, s1b2, s1b3, s2ag, s2b1g, s2b2g, s2b1, s2b2, 
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds CP_xptf_bmac_bmal(s1ag, s1b1g, s1b2g, s1b3g, s1b1, s1b2, s1b3, s2ag, s2b1g, s2b1,
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%end;
%if %upcase(&s1btype) = BMA_QUAD %then %do;
	%if %upcase(&s2btype) = BMA_QUAD %then
		%let udsline = &udsline uds CP_xptf_bmaq_bmaq(s1ag, s1b1g, s1b2g, s1b1, s1b2, s2ag, s2b1g, s2b2g, s2b1, s2b2, 
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds CP_xptf_bmaq_bmal(s1ag, s1b1g, s1b2g, s1b1, s1b2, s2ag, s2b1g, s2b1, 
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%end;
%if %upcase(&s1btype) = BMA_LINEAR %then %do;
	%if %upcase(&s2btype) = BMA_LINEAR %then
		%let udsline = &udsline uds CP_xptf_bmal_bmal(s1ag, s1b1g, s1b1, s2ag, s2b1g, s2b1, 
														etamnarr, mbetag, Dbetag, rhoarr, nuarr, rts, X, Yarr, Sarr, flg)%str(;) ;
%end;

/* eMKF: UDS statement for true states etaarr */
%let udsline = &udsline uds EP(etaarr, etamnarr, rhoarr, nuarr, rts, Yarr, Sarr)%str(;) ;

/* eMKF: UDS statement for variances (if applicable) */
%if %upcase(&brndvars) = YES %then %let udsline = &udsline uds RP(varr, vhyp, Sarr, Narr)%str(;) ;

/* eMKF: library location for pre-compiled UDS subroutines */
options cmplib = &bcmploc;

/* eMKF: Options will be the proc mcmc defaults if not specified by the user */
%let optionline=;
%if &bseed ^= %str()  %then %let optionline = &optionline seed 		= %eval(0+&bseed);;
%if &bmaxt ^= %str()  %then %let optionline = &optionline maxtune 	= %eval(0+&bmaxt);;
%if &btune ^= %str()  %then %let optionline = &optionline ntu 		= %eval(0+&btune);;
%if &bburn ^= %str()  %then %let optionline = &optionline nbi 		= %eval(0+&bburn);;
%if &biter ^= %str()  %then %let optionline = &optionline nmc 		= %eval(0+&biter);;
%if &bthin ^= %str()  %then %let optionline = &optionline thin 		= %eval(0+&bthin);;
%if &batol ^= %str()  %then %let optionline = &optionline accepttol = %sysevalf(&batol);;
%if &bttol ^= %str()  %then %let optionline = &optionline targaccept = %sysevalf(&bttol);;
%if &bprcov ^= %str() %then %let optionline = &optionline propcov 	= &bprcov;
%if &binit ^= %str()  %then %let optionline = &optionline init 		= &binit;

/* eMKF: Disable summary statistics if not requested by the user */
%if %upcase(&bprint) ^= YES %then %let optionline = &optionline stats = none;

/* eMKF: Diagnostics plots and ODS graphics enabled if requested by the user */
%if %upcase(&bplot) = YES %then %do; 
	%let optionline = &optionline plots = all;
	ods graphics on;
%end;
%else %let optionline = &optionline plots = none;

/* eMKF: Add jointmodel option (log-likelihood constructed using stored arrays) */
%let optionline = &optionline jointmodel;

/* eMKF: Monitor selected model parameters */
%if %upcase(&bdirichlet) = YES %then %let monitorline = wts;
%let monitorline = &monitorline s1flg s2flg &parline2 etaarr &vparline;
%if %upcase(&bARmodel) = INDEP_AR %then %let monitorline = spsi mpsi &tausqparline &rhoparline &monitorline ;
%if %upcase(&bARmodel) = COMMON_ARH %then %let monitorline = &tausqparline rho &monitorline ;
%if %upcase(&bARmodel) = COMMON_AR %then %let monitorline = tausq rho &monitorline ;

/* eMKF: Empty dataset to pass to proc mcmc: data from _bbdata_ will be read directly into arrays */
data _bb_;
run;

/* eMKF: Call proc mcmc using the above customizations  */
%put ;
%put Call to PROC MCMC initiated; %let _i = 0;

proc mcmc data=_bb_ outpost= &blog monitor = ( &monitorline ) &optionline;;	

	  %if %upcase(&bprint) ^=YES and %upcase(&bplot) ^=YES 	/* Disable output tables and plots as applicable */
		%then ods select none;;

	  /**********************/
	  /* Array declarations */
	  /**********************/
	  array rts[&n] (&_brtimess); 	 						/* constant array with real times */
	  array Xarr[1]						   	    /nosymbols;	/* dynamic array for predictors to read in from dataset */
	  array Yarr[1]			   	  			    /nosymbols;	/* dynamic array for _y from dataset */
	  array Sarr[1]			   	   			    /nosymbols;	/* dynamic array for _var from dataset */
	  &Narrline;;											/* dynamic array for _n from dataset (if applicable) */
	  array X[&n, %eval(&s1p+&s2p)];						/* eMKF v2.4: design matrix to use in matrix multiplication */
	  array mbetag[%eval(&s1p+&s2p), 1];					/* eMKF v2.4: prior mean vector for betas (assumed common accross groups) */
	  array Dbetag[%eval(&s1p+&s2p), %eval(&s1p+&s2p)];		/* eMKF v2.4: diagonal prior precision matrix for betas (assumed common accross groups) */
	  %if %upcase(&bARmodel) = INDEP_AR %then %do;			/* AR-related parameters in the group-specific random effects model */
	 	  array psi[&g] psi1-psi&g;							/* group-specific psi = -ln[(1-rho)/(1+rho)] */
	  	  array rho[&g] rho1-rho&g;							/* reverse-transformation for rho */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  %if %upcase(&bARmodel) = COMMON_ARH %then %do;		/* AR-related parameters in the ARH random effects model */
	  	  array tau[&g] tau1-tau&g;				    		/* group-specific innovation SD tau */
	  	  array tausq[&g] tausq1-tausq&g;					/* squares of group-specific innovation SD tau */
	  	  array nu[&g] nu1-nu&g;							/* innovation variance parameters under stationarity */
	  	  *array dg[&g] dg1-dg&g;							/* determinants of AR variance-covariance matrices */
	  %end;
	  array rhoarr[&g]; 									/* temporary 1-dimensional array with group-specific parameters rho  */
	  array nuarr[&g]; 										/* temporary 1-dimensional array with group-specific parameters nu */
	  &wtsline;;											/* mixture weights and model flags */
	  array s1ag[&g] s1ag1-s1ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 1 */
	  &s1b1line;;											/* eMKF v2.4: named 1-dimensional array of group-specific linear coefficients for segment 1 (if requested) */
 	  &s1b2line;;                     						/* eMKF v2.4: named 1-dimensional array of group-specific quad coefficients for segment 1 (if requested) */
	  &s1b3line;; 											/* eMKF v2.4: named 1-dimensional array of group-specific cubic coefficients for segment 1 (if requested) */
	  array s2ag[&g] s2ag1-s2ag&g;							/* eMKF v2.4: named 1-dimensional array of group-specific intercepts for segment 2 */
	  &s2b1line;;											/* eMKF v2.4: named 1-dimensional array of group-specific linear coefficients for segment 2 (if requested) */
 	  &s2b2line;;                     						/* eMKF v2.4: named 1-dimensional array of group-specific quad coefficients for segment 2 (if requested) */
	  &s2b3line;; 											/* eMKF v2.4: named 1-dimensional array of group-specific cubic coefficients for segment 2 (if requested) */
	  &etamnarrline;;										/* named 1-dimensional array etamnarr (gxn) for predictions from regression */
	  &vline;;												/* named 1-dimensional array of group-specific variance parameters (if requested) */
	  &etaarrline;;											/* named 1-dimensional array etaarr (gxn) for unobserved true states */

	  begincnst;

		  /*****************/
	  	  /* Design matrix */
		  /*****************/
	  	  &rcXline;;										/* read in dynamic array of predictors Xarr */  
		  call zeromatrix(X);								/* initialize design matrix X to all zeroes */
		  do i = 1 to &n;
		 	  do m = 1 to &s1p+&s2p;
				  X[i,m] = Xarr[i,m];						/* eMKF v2.4: Xarr remains a 2-dimensional array */
		  	  end;
		  end;

		  /**********************/
		  /* Group sample means */
		  /**********************/
		  rcY = read_array('_bbdata_', Yarr, '_y');			/* read in 1-dimensional array of _y from dataset */

		  /**********************/
	  	  /* Sampling variances */
		  /**********************/
		  rcS = read_array('_bbdata_', Sarr, '_var');		/* read in 1-dimensional array of _var from dataset */

		  /******************************************/
		  /* Effective sample sizes (if applicable) */
		  /******************************************/
		  &rcNline;;										/* read in 1-dimensional array of _n from dataset (if applicable) */

		  /******************/
	 	  /* Initialization */
	  	  /******************/
		  call streaminit(%eval(0+&bseed));					/* set seed */

		  &initlinepsi;;									/* initialize psi = -ln[(1-rho)/(1+rho)] */
		  &initlinetau;;									/* initialize innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* common AR parameters across groups */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 		 	/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 		 	/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1])))); 
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* temp parameter arrays (e.g., to pass to UDS subroutines) */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
		  %if %upcase(&bARmodel) = COMMON_ARH %then %do;	/* eMKF v2.4: new ARH option */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  do k=1 to &g;
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu[k];
			  end;
		  %end;
		  %if %upcase(&bARmodel) = INDEP_AR %then %do;		/* independent AR parameters across groups */
			  do k=1 to &g;
		  		  rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
				  tausq[k] = tau[k]**2;		 	
		  		  nu[k] = tausq[k]/(1-rho[k]**2);
				*  dg[k] = nu[k]**&n;
				*  do i = 2 to &n;
				*	  dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
				*  end;
				*  if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
				*	  rho[k] = 0;             
				*	  nu[k] = tausq[k]; 		 
				*      dg[k] = nu[k]**&n;
				*  end;
				  rhoarr[k] = rho[k];
			  	  nuarr[k] = nu[k];
			  end;
		  %end;

		  &initmbeta;;							 			/* initialize constant vector mbetag and constant matrix Dbetag */

		  &initlinewts;;									/* initialize model weights and related arrays */
		  &initlineflg;;									/* eMKF v2.4: initialize internal flags iflg */
		  &recodeflg;;										/* eMKF v2.4: initialize model flags flg */
		  s1flg = intz(flg/10);								/* eMKF v2.4: initialize model flags s1flg and s2flg for tracking */
		  s2flg = modz(flg, 10);

		  &initlines1a;;									/* eMKF v2.4: initialize intercepts for segment 1 */
		  &initlines1b1;;									/* eMKF v2.4: initialize linear coefficients for segment 1 (if applicable) */
		  &initlines1b2;;									/* eMKF v2.4: initialize quad coefficients for segment 1 (if applicable) */	
		  &initlines1b3;;									/* eMKF v2.4: initialize cubic coefficients for segment 1(if applicable) */
		  &initlines2a;;									/* eMKF v2.4: initialize intercepts for segment 2 */
		  &initlines2b1;;									/* eMKF v2.4: initialize linear coefficients for segment 1 (if applicable) */
		  &initlines2b2;;									/* eMKF v2.4: initialize quad coefficients for segment 1 (if applicable) */	
		  &initlines2b3;;									/* eMKF v2.4: initialize cubic coefficients for segment 1(if applicable) */

          %do _i = 1 %to &g; 
		      &&inits1etamnarr&_i;;						    /* eMKF v2.4: initialize conditional mean for true states in segment 1 */ 
		      &&inits2etamnarr&_i;;						    /* eMKF v2.4: initialize conditional mean for true states in segment 2 */ 
		  %end;

		  do k = 1 to &g; 			  						/* initialize etaarr using Markov property of AR process */
			  etaarr[(k-1)*&n+1] = etamnarr[(k-1)*&n+1] + 
							sqrt(nuarr[k])*rand('normal'); 	/* first timepoint from stationary distribution of AR process */

		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      etaarr[(k-1)*&n+i] = etamnarr[(k-1)*&n+i] + 
							((rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1])) + 
							sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))*rand('normal');
		  	  end;
		  end;

		  &initlinevarr;;									/* initialize sampling variances (if applicable) */

	  endcnst;

	  /*******************/
	  /* UDS declaration */
	  /*******************/
	  &udsline;;											/* Gibbs sampling done in the order specified in udsline */
	  														/* Per SAS documentation, parameters that use M-H will be sampled first */
	  /**************************/
	  /* Parameter declarations */
	  /**************************/
	  &psiparline2;;										/* psi = -ln[(1-rho)/(1+rho)] and any hyperparameters */
	  &tauparline2;;										/* innovation SD tau */
	  %if %upcase(&bdirichlet) = YES %then %do;				/* eMKF v2.4 streamlining: explicitly included dirichlet prior option */
		  parms wts &bslice; 								/* Dirichlet mixture weights */
	  %end;
	  &udsparline;;											/* UDS parameter blocks, one for each Gibbs sampler */

	  beginnodata;

	  	  /********************/
	  	  /* Prior statements */
	  	  /********************/
		  &hplinespsi;;										/* SD hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &hplinempsi;;										/* Mean hyper-prior for mean of psi = -ln[(1-rho)/(1+rho)] (if applicable) */
		  &plinepsi;;										/* prior for psi = -ln[(1-rho)/(1+rho)] */
		  &plinetau;;										/* prior for innovation SD tau */
		  %if %upcase(&bARmodel) = COMMON_AR %then %do;		/* AR parameters in the common case */
	  		  rho = (exp(psi)-1)/(exp(psi)+1); 		 		/* reverse-transformation for rho */
			  tausq = tau**2;					 			/* track tau-squared */
	  		  nu = tausq/(1-rho**2);			 			/* innovation variance parameter under stationarity */
			*  dg = nu**&n;									/* recursive formula for determinant of Vgamma (assuming 2+ points) */
			*  do i = 2 to &n;								
			*	  dg = dg*(1-(rho**(2*(rts[i]-rts[i-1]))));
			*  end;
			*  if abs(rho) ge 1 or dg= . or dg le 0 then do; /* guard against numerical singularities */
			*	  rho = 0;
			*	  nu = tausq;
			*	  dg = nu**&n;
			*  end;
			  do k=1 to &g;									/* parameter arrays to pass to UDS subroutines */
				  rhoarr[k] = rho;
			  	  nuarr[k] = nu;
			  end;
		  %end;
	      %if %upcase(&bARmodel) = COMMON_ARH %then %do;	 /* eMKF v2.4: new ARH option */
		  	 rho = (exp(psi)-1)/(exp(psi)+1);
			 do k = 1 to &g; 
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho;
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
	      %if %upcase(&bARmodel) = INDEP_AR %then %do;	 	/* Group-specific AR parameters */
			 do k = 1 to &g; 
		  	    rho[k] = (exp(psi[k])-1)/(exp(psi[k])+1);
			    tausq[k] = tau[k]**2;
		  	    nu[k] = tausq[k]/(1-rho[k]**2);
			 *   dg[k] = nu[k]**&n;
			 *   do i = 2 to &n;
			*	    dg[k] = dg[k]*(1-(rho[k]**(2*(rts[i]-rts[i-1]))));
			 *   end;
			 *   if abs(rho[k]) ge 1 or dg[k] = . or dg[k] le 0 then do;
			*	    rho[k] = 0;             
			*	    nu[k] = tausq[k]; 		 
			*	    dg[k] = nu[k]**&n;
			*    end;
				rhoarr[k] = rho[k];
			  	nuarr[k] = nu[k];		
			 end;
		  %end;
 
		  &plinewts;;										/* Dirichlet prior for model weights (if requested) */
		  &plineflg;;										/* Discrete prior for model flag */
		  prior flg s1flg s2flg ~ general(0);				/* eMKF v2.4: flg, s1flg, and s2flg treated as pseudo-parameters, not contributing to prior */

	  	  &plines1a;; 							 			/* eMKF v2.4: prior for intercepts in segment 1 */
	  	  &plines1b1;;							 			/* eMKF v2.4: prior for linear coefficients in segment 1 (if those were requested) */
	  	  &plines1b2;;							 			/* eMKF v2.4: prior for quadratic coefficients in segment 1 (if those were requested) */
	  	  &plines1b3;;							 			/* eMKF v2.4: prior for cubic coefficients in segment 1 (if those were requested) */
	  	  &plines2a;; 							 			/* eMKF v2.4: prior for intercepts in segment 2 */
	  	  &plines2b1;;							 			/* eMKF v2.4: prior for linear coefficients in segment 2 (if those were requested) */
	  	  &plines2b2;;							 			/* eMKF v2.4: prior for quadratic coefficients in segment 2 (if those were requested) */
	  	  &plines2b3;;							 			/* eMKF v2.4: prior for cubic coefficients in segment 2 (if those were requested) */

		  prior etamnarr ~ general(0);						/* pseudo-parameters etamnarr do no contribute to prior */

		  lpr = 0; 											/* calculation of log-prior for etaarr from univariate conditionals */
		  do k = 1 to &g;
		  	  lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+1], 		/* etaarr is updated in the UDS call for the true states */
								   etamnarr[(k-1)*&n+1], 	/* etamnarr is updated in the UDS call for the regression coefficients */
								   sqrt(nuarr[k]));			/* first timepoint from stationary distribution of AR process */
		  	  do i = 2 to &n; 								/* subsequent timepoints from implied conditional distributions */
			      lpr = lpr + lpdfnorm(etaarr[(k-1)*&n+i], 
									   etamnarr[(k-1)*&n+i] + 
									    (rhoarr[k]**(rts[i] - rts[i-1]))*(etaarr[(k-1)*&n+i-1] - etamnarr[(k-1)*&n+i-1]), 
									   sqrt(nuarr[k]*(1-(rhoarr[k]**(2*(rts[i] - rts[i-1])))))); 
		  	  end;
		  end;
		  prior etaarr ~ general(lpr);						/* prior for unobserved true states */

		  &plinev;;								 			/* Inverse gamma prior for sampling variances (if applicable) */

		  /********************************/
	  	  /* Loglikelihood calculation(s) */
	  	  /********************************/
	  	  lp = 0;		  									/* log of joint distribution of sample means */
		  do k = 1 to &g*&n;
		      lp = lp + lpdfnorm(Yarr[k], etaarr[k], sqrt(Sarr[k]));
		  end;
		  %if %upcase(&brndvars) = YES %then %do;		  	/* log of joint distribution of sample variances (if applicable) */
			  do k = 1 to &g;
				  do j = 1 to &n;
					  lp = lp + lpdfgamma(Sarr[(k-1)*&n+j],
										  (Narr[(k-1)*&n+j]-1)/2,
										  (2*varr[k])/(Narr[(k-1)*&n+j]-1)); /* varr is updated in the UDS call for the variances */
			 	  end;
			  end;
		  %end;

	  endnodata;

	  /*******************/
	  /* Model statement */
	  /*******************/
	  model general(lp);

run;

/* eMKF: Re-enable output tables and plots */
%if %upcase(&bprint) ^= YES and %upcase(&bplot) ^= YES %then ods select all;;

/* eMKF: Disable ODS graphics */
%if %upcase(&bplot) = YES %then ods graphics off;;

%put Call to PROC MCMC concluded;

/* eMKF: Keep only the desired columns in the posterior log dataset */
%if %upcase(&bARmodel) = INDEP_AR %then %do;
	data &blog;
	  merge &blog(drop= iflg flg etamn: Log: spsi mpsi &tauparline &psiparline
						%if %upcase(&s1btype) = BMA_CUBIC %then s1b1 s1b2 s1b3; 
  						%if %upcase(&s1btype) = BMA_QUAD %then s1b1 s1b2; 
						%if %upcase(&s1btype) = BMA_LINEAR %then s1b1; 
						%if %upcase(&s2btype) = BMA_CUBIC %then s2b1 s2b2 s2b3; 
  						%if %upcase(&s2btype) = BMA_QUAD %then s2b1 s2b2; 
						%if %upcase(&s2btype) = BMA_LINEAR %then s2b1; ) 
			&blog(keep = spsi mpsi)
      ;
	run;
%end;
%if %upcase(&bARmodel) = COMMON_ARH %then %do;
	data &blog;
	  set &blog(drop= iflg flg etamn: Log: &tauparline psi
						%if %upcase(&s1btype) = BMA_CUBIC %then s1b1 s1b2 s1b3; 
  						%if %upcase(&s1btype) = BMA_QUAD %then s1b1 s1b2; 
						%if %upcase(&s1btype) = BMA_LINEAR %then s1b1; 
						%if %upcase(&s2btype) = BMA_CUBIC %then s2b1 s2b2 s2b3; 
  						%if %upcase(&s2btype) = BMA_QUAD %then s2b1 s2b2; 
						%if %upcase(&s2btype) = BMA_LINEAR %then s2b1; ); 
	run;
%end;
%if %upcase(&bARmodel) = COMMON_AR %then %do;
	data &blog;
		set &blog(drop= iflg flg etamn: Log: tau psi
						%if %upcase(&s1btype) = BMA_CUBIC %then s1b1 s1b2 s1b3; 
  						%if %upcase(&s1btype) = BMA_QUAD %then s1b1 s1b2; 
						%if %upcase(&s1btype) = BMA_LINEAR %then s1b1; 
						%if %upcase(&s2btype) = BMA_CUBIC %then s2b1 s2b2 s2b3; 
  						%if %upcase(&s2btype) = BMA_QUAD %then s2b1 s2b2; 
						%if %upcase(&s2btype) = BMA_LINEAR %then s2b1; );
	run;
%end;

/****************************************************/
/* eMKF: Reverse-transform regression coefficients  */
/****************************************************/

data _blogc2_ _tblogc2_ _tblogc_  ;
run;

%let _i = 0; 

%if %upcase(&borpoly) = YES %then %do;

	/* eMKF v2.4: order columns by segment then by group */
	data _blogc2_;
    	retain Iteration 
		  %do _i=1 %to &g;
			  s1ag&_i
			  %if %upcase(&s1btype) = BMA_LINEAR %then s1b1g&_i;
			  %if %upcase(&s1btype) = BMA_QUAD %then s1b1g&_i s1b2g&_i;
			  %if %upcase(&s1btype) = BMA_CUBIC %then s1b1g&_i s1b2g&_i s1b3g&_i;
		  %end;
		  %do _i=1 %to &g;
			  s2ag&_i
			  %if %upcase(&s2btype) = BMA_LINEAR %then s2b1g&_i;
			  %if %upcase(&s2btype) = BMA_QUAD %then s2b1g&_i s2b2g&_i;
			  %if %upcase(&s2btype) = BMA_CUBIC %then s2b1g&_i s2b2g&_i s2b3g&_i;
		  %end;
  		;
  		set &blog(keep = Iteration s1a: s1b: s2a: s2b: );
	run;

	/* eMKF v2.4: block diagonal by group modified to account for 2 segments */
	%let s1oPPmat = ; %let _i = 0; 	/* eMKF v2.4: block diagonal by group for segment 1 */
	%do _i=1 %to &g; 
		%if &_i = 1 %then %let s1oPPmat = block( s1oP ;
		%if &_i > 1 and &_i < &g %then %let s1oPPmat = &s1oPPmat , block ( s1oP ;
		%if &_i = &g and &g > 1  %then %let s1oPPmat = &s1oPPmat , s1oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let s1oPPmat = &s1oPPmat );
	%end;
	%let s2oPPmat = ; %let _i = 0;	/* eMKF v2.4: block diagonal by group for segment 2 */
	%do _i=1 %to &g;  
		%if &_i = 1 %then %let s2oPPmat = block( s2oP ;
		%if &_i > 1 and &_i < &g %then %let s2oPPmat = &s2oPPmat , block ( s2oP ;
		%if &_i = &g and &g > 1  %then %let s2oPPmat = &s2oPPmat , s2oP %sysfunc(repeat( %str(%)), &g-2));
		%if &_i = &g and &g = 1  %then %let s2oPPmat = &s2oPPmat );
	%end;

	%let _i = 0;

	/* eMKF v2.4: call to proc iml to perform matrix multiplication splits up segments 1 and 2 for matrix operation purposes */
	proc iml;

		/* eMKF 2.3: segment 1 */
		use _oPmat_;
		read all into s1oP; close _oPmat_;
		s1oP = s1oP[1:&s1p, 1:&s1p];
		s1oPP = &s1oPPmat;;

		/* eMKF 2.3: segment 2 */
		use _oPmat_;
		read all into s2oP; close _oPmat_;
		s2oP = s2oP[(1+&s1d):(&s1d+&s2p), (1+&s1d):(&s1d+&s2p)];
		s2oPP = &s2oPPmat;;

		/* eMKF v2.4: variable names for segment 1 */
		varNames1 = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames1 = varNames1 || {"s1ag&_i"};
		  %if %upcase(&s1btype) = BMA_LINEAR %then varNames1 = varNames1 || {"s1b1g&_i"};;
		  %if %upcase(&s1btype) = BMA_QUAD %then varNames1 = varNames1 || {"s1b1g&_i"} || {"s1b2g&_i"};;
		  %if %upcase(&s1btype) = BMA_CUBIC %then varNames1 = varNames1 || {"s1b1g&_i"} || {"s1b2g&_i"} || {"s1b3g&_i"};;
		%end;

		/* eMKF v2.4: variable names for segment 2 */
		varNames2 = {"Iteration"};
		%do _i = 1 %to &g;
		  varNames2 = varNames2 || {"s2ag&_i"};
		  %if %upcase(&s2btype) = BMA_LINEAR %then varNames2 = varNames2 || {"s2b1g&_i"};;
		  %if %upcase(&s2btype) = BMA_QUAD %then varNames2 = varNames2 || {"s2b1g&_i"} || {"s2b2g&_i"};;
		  %if %upcase(&s2btype) = BMA_CUBIC %then varNames2 = varNames2 || {"s2b1g&_i"} || {"s2b2g&_i"} || {"s2b3g&_i"};;
		%end;

		/* eMKF v2.4: combined variable names for later use */
		varNames = varNames1 || varNames2[, 2:ncol(varNames2)];

		/* eMKF v2.4: apply orthogonal transformation separately for each segment then combine */
		/* segment 1 */
		use _blogc2_(keep= Iteration s1a: %if &s1p > 1 %then s1b: ;); 
		read all into s1oB; close _blogc2_;
		s1oB1 = s1oB[,1];
		s1oB = s1oB[,2:ncol(s1oB)];
		s1oBB = s1oPP * T(s1oB);
		/* segment 2 */
		use _blogc2_(keep= Iteration s2a: %if &s2p > 1 %then s2b: ;);
		read all into s2oB; close _blogc2_;
		s2oB1 = s2oB[,1];
		s2oB = s2oB[,2:ncol(s2oB)];
		s2oBB = s2oPP * T(s2oB);
		/* combined */
		oBB = s1oB1 || T(s1oBB) || T(s2oBB);
		create _tblogc2_ var varNames;
		append from oBB; close _tblogc2_;

	quit;

	/* eMKF: re-order columns as they were initially from PROC MCMC */
	data _tblogc_;
  	  retain  Iteration 
			  s1ag1-s1ag&g
			  %if %upcase(&s1btype) = BMA_LINEAR  %then s1b1g1-s1b1g&g ; 
			  %if %upcase(&s1btype) = BMA_QUAD    %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g ; 
			  %if %upcase(&s1btype) = BMA_CUBIC   %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g ; 
			  s2ag1-s2ag&g
			  %if %upcase(&s2btype) = BMA_LINEAR  %then s2b1g1-s2b1g&g ; 
			  %if %upcase(&s2btype) = BMA_QUAD    %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g ; 
			  %if %upcase(&s2btype) = BMA_CUBIC   %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g ; 
	  ;
	  set _tblogc2_;
	run;

	/* eMKF: merge into &blog */
	data &blog;
	  merge &blog(keep = Iteration %if %upcase(&bdirichlet) = YES %then wts; s1flg s2flg )
	        _tblogc_
			&blog(drop = s1a: s1b: s2a: s2b:)
	  ;
	  by Iteration;
	run;
	  
%end;

/* eMKF: clean-up */
proc datasets nolist;
 delete _bbdata_ _bbdata1_ _bb_ _bfreqg_ _bfreqn_ _bfreqs1n_ _bfreqs2n_ _bbjunk _oXmat_ _oPmat_ _blogc2_ _tblogc2_ _tblogc_;
run ;
quit;

%mend bayesBMAxptf;

data _null_;
run;

/*HTRPxptf macro
Version of HTRP macro for eMKF v2.4 to allow full break in trend.

data 	: name of the dataset.
outcome : outcome of interest. 
se      : standard error of the outcome. 
time    : time variable.
xpt		: value of timepoint at which trend break occurs.
by      : allows models to run for multiple strata at the same time and can be used for simulations
xtrakeep: Any variable one wants to keep in the data while runing models: weights, ... (eMKF: could be used to retain labels for multiyear data)
orpoly  : (eMKF) YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          If YES, regression coefficients and their SEs will be reverse-transformed prior to macro end.
bvalue1, bvalue2: Assumptions about the trend model for time segments 1 and 2. eMKF options are the following:
             indep_cubic	: The values of the parameters b1, b2, and b3 are computed for each group
             indep_quad		: b3=0. The values of the parameters b1 and b2 are computed for each group
             indep_linear   : (DEFAULT) b3=0 and b2=0. The value of the slope b1 is computed for each group
             common_cubic	: The values of each of the parameters b1, b2, and b3 are assumed to be the same across groups
             common_quad	: b3=0. The values of each of the parameters b1 and b2 are assumed to be the same across groups
             common_linear  : b3=0 and b2=0. The value of the slope b1 is assumed to be the same across groups
             dropped    	: A model without time trend is computed
ARvalue	: [New in eMKF v2.4] Assumption about the AR(1) model. Options are:
			common_ar (default)	: AR parameters are common across groups; 
		    common_arh			: AR correlation is common but innovation variance parameters are group-specific.
			indep_ar			: Both AR(1) parameters are group-specific. 
group   : the different groups (e.g., race/ethnicity groups) variable
nlmixedDF: Non-linear model degrees of freedom for proc nlmixed. The default is set pretty high at 10000
nlmixedDetails: (eMKF v2.4 streamlining)(default = NO) option to omit covariance matrix of parameters and other model information.
nlmixedTech:	(eMFK v2.4 streamlining) (default = NEWRAP) added to give user more control over choice of optimization algorithm
print   : Yes will print the nlmixed results and No will not. Default is No
out     : The name of the output baseline. All the following outputs (baseline + suffix) are saved. 
          Here are the suffixes:
          	_fitstat : model fit estimates from the proc nlmixed
          	_ests    : model fit estimates formated for use in the estimation of the Kalman prediction
          	_covmat  : model fit covariance matrix
          	_pred    : Kalman prediction of the outcome of interest includes original values as well as parameters
         (e.g., for OUT=result then RESULT_PRED will be the Kalman prediction data of the outcome of interest. )
*/
%macro htrpxptf(data=, 
               outcome=, 
               se=,
               group=,
               time=,
			   xpt=,
               by=, 
               xtrakeep= ,
			   orpoly=YES,
               bvalue1= indep_linear , 
			   bvalue2= indep_linear , 
			   ARvalue= common_ar,
               nlmixedDF=10000, 
			   nlmixedDetails=NO,
			   nlmixedTech=NEWRAP,
               out=param, 
               print=NO
               ) / minoperator;

%local formatted dsop dscl g n s1n s2n _rtimess _s1rtimess _s2rtimess rtm s1rtm s2rtm rlag nrep s1p s2p s1k s2k s1d s2d tline s1tline s2tline jj tauline rholine
 		s1b1line s1b2line s1b3line s2b1line s2b2line s2b3line i j nlmerr _emkfmu_ _s1emkfmu_ _s2emkfmu_ group_rep lj amat s1oPPmat s2oPPmat s1colList s2colList ;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&data));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &time)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _sdata_;
run;

%if &formatted = 1 %then %do;
	/* eMKF v2.4 note: recall that _groupnum and _reps are created before HTRP is called from parent MKF macro */
	data _sdata_;
	  set &data;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to MLE-based estimation;
	%reformatXPT(data=&data, outcome=&outcome, se=&se, group=&group, time=&time, xpt=&xpt, by=&by, outformat= _sdata_);
	/* eMKF: Create copies of _group_ and _rep variables for use in proc iml matrix calculations */
	data _sdata_; 
	  set _sdata_;
	  _groupnum = _group_; 					 
	  %if &by ^= %str() %then _reps = _rep;;
	run;
	/* eMKF: Replace &group and &by macro variables by their numeric versions */
	%let group = _groupnum; 				
	%if &by ^= %str() %then %let by = _reps;;
%end;

/* eMKF: Sort by replications (if any), group, and time */
/* eMKF: Use _time as &time could be empty if data was still in format 1 when htrp was called */
proc sort data= _sdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _freqg_;
run;
proc freq data=_sdata_ noprint;
  tables &group /list out=_freqg_;
run;
data _freqg_;
  set _freqg_;
  _group_ +1;
  call symput('g',_group_);
  keep _group_ &group;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the total number of time points */
%let n=0;
data _freqn_;
run;
proc freq data=_sdata_ noprint;
  tables _rtime /list out=_freqn_;
run;
data _freqn_;
  set _freqn_;
  _time +1;
  call symput('n',_time);
  keep _time _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1*/
%let s1n=0;
data _freqs1n_;
run;
proc freq data=_sdata_ noprint;
  tables _s1rtime /list out=_freqs1n_;
run;
data _freqs1n_;
  set _freqs1n_(where=(_s1rtime ne 0));
  _s1time + 1;
  call symput('s1n',_s1time);
  keep _s1time _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2*/
%let s2n=0;
data _freqs2n_;
run;
proc freq data=_sdata_ noprint;
  tables _s2rtime /list out=_freqs2n_;
run;
data _freqs2n_;
  set _freqs2n_(where=(_s2rtime ne 0));
  _s2time + 1;
  call symput('s2n',_s2time);
  keep _s2time _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _freqs2n_;
  set _freqs2n_;
  _s2time = _s2time + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _rtimess = ;
data _freqn_;
  set _freqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_rtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 1 only */
%let _s1rtimess = ;
data _freqs1n_;
  set _freqs1n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s1rtime);
  else _rts = catx(" ", _rts, _s1rtime);
  call symput('_s1rtimess', _rts);
  drop _rts;
run;

/* eMKF v2.4: Macro variable for the real times to use in calculations for segment 2 only */
%let _s2rtimess = ;
data _freqs2n_;
  set _freqs2n_;
  retain _rts;
  if _n_= 1 then _rts = cat(_s2rtime);
  else _rts = catx(" ", _rts, _s2rtime);
  call symput('_s2rtimess', _rts);
  drop _rts;
run;

/* eMKF allows for irregular and fractional times points */
/* eMKF v2.4: These are the variables that will be used for real time in case they are not just 1,2,3,... */
%let rtm=_rtime; %let s1rtm=_s1rtime;  %let s2rtm=_s2rtime; 

/* eMKF: macro reformat now also tracks lags between successive real time points */		
%let rlag=_rlag;

/* eMKF: Macro variable for the number of replications */
%let nrep=1;
%if &by ^=%str() %then %do;
	data _freq_;
	run;
	proc freq data=_sdata_ noprint;
	  tables &by /list out=_freq_;
	  format &by ;
	run;
	data _freq_;
	  set _freq_;
	  _rep +1;
	  call symput('nrep',_rep);
	  keep _rep &by;
	run;
%end;
%let nrep=%eval(0+&nrep);

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality s1p and s2p for easier referencing of various models instead of using labels */
%let s1p = 0; %let s2p = 0;
%if %upcase(&bvalue1) in INDEP_CUBIC COMMON_CUBIC %then %let s1p = 4;
%if %upcase(&bvalue1) in INDEP_QUAD COMMON_QUAD %then %let s1p = 3;
%if %upcase(&bvalue1) in INDEP_LINEAR COMMON_LINEAR %then %let s1p = 2;
%if %upcase(&bvalue1) = DROPPED %then %let s1p = 1;
%if %upcase(&bvalue2) in INDEP_CUBIC COMMON_CUBIC %then %let s2p = 4;
%if %upcase(&bvalue2) in INDEP_QUAD COMMON_QUAD %then %let s2p = 3;
%if %upcase(&bvalue2) in INDEP_LINEAR COMMON_LINEAR %then %let s2p = 2;
%if %upcase(&bvalue2) = DROPPED %then %let s2p = 1;
%let s1k = %eval(&s1p - 1); %let s2k = %eval(&s2p - 1);

/* eMKF v2.4: max polynomial ranks s1d-1 and s2d-1 to use in orpoly for segments 1 and 2 */
%let s1d = 0; %let s2d = 0;
%if &s1n > 4 %then %let s1d = 4;	/* cubic allowed in segment 1 */
%else %do;
	%if &s1n > 3 %then %let s1d = 3;	/* quad allowed in segment 1 */
	%else %do;
		%if &s1n > 2 %then %let s1d = 2;	/* linear allowed in segment 1 */
		%else %let s1d = 1;						/* intercepts-only model allowed in segment 1 */
	%end;
%end;
%if &s2n > 4 %then %let s2d = 4;	/* cubic allowed in segment 2 */
%else %do;
	%if &s2n > 3 %then %let s2d = 3;	/* quad allowed in segment 2 */
	%else %do;
		%if &s2n > 2 %then %let s2d = 2; 	/* linear allowed in segment 2 */
		%else %let s2d = 1;						/* intercepts-only model allowed in segment 2 */
	%end;
%end;
%let s1d = %eval(0+&s1d); %let s2d = %eval(0+&s2d); 

/* eMKF v2.4: Error check to make sure requested trend models can be fit */
%if (&s1p > &s1d) or (&s2p > &s2d) %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%if &s1p > &s1d %then %put ERROR- &bvalue1 was requested for segment 1: there are only enough data for a degree %eval(&s1d-1) polynomial.;; 
	%if &s2p > &s2d %then %put ERROR- &bvalue2 was requested for segment 2: there are only enough data for a degree %eval(&s2d-1) polynomial.;; 
  	%return;
%end;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&orpoly) = YES %then %do;
	proc iml;
	  /* eMKF v2.4: segment 1 */
	  s1x = { &_s1rtimess };
	  s1x = T(s1x);										/* eMKF: column vector with real times */
	  %if &s1d = 1 %then s1oP = orpol(s1x, 1)[,1];;
	  %if &s1d > 1 %then s1oP = orpol(s1x, &s1d - 1);;	/* eMKF v2.4: orthonormal design matrix s1oP */
	  s1x0 = { %cnstss(1, &s1n) };
	  s1x0 = T(s1x0);
	  %if &s1n > 2 %then s1x1 = s1x;;
	  %if &s1n > 3 %then s1x2 = s1x#s1x1;;
	  %if &s1n > 4 %then s1x3 = s1x#s1x2;;
	  s1uP = s1x0;										
	  %if &s1n > 2 %then s1uP = s1uP || s1x1;;	
	  %if &s1n > 3 %then s1uP = s1uP || s1x2;;	
	  %if &s1n > 4 %then s1uP = s1uP || s1x3;;			/* eMKF v2.4: raw/unstandardized design matrix s1uP */
	  s1oP1 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,1];
      %if &s1n > 2 %then s1oP2 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,2];;
      %if &s1n > 3 %then s1oP3 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,3];;
      %if &s1n > 4 %then s1oP4 = inv(T(s1uP)*s1uP)*T(s1uP)*s1oP[,4];;
	  s1oPP = s1oP1;									
	  %if &s1n > 2 %then s1oPP = s1oPP || s1oP2;;
	  %if &s1n > 3 %then s1oPP = s1oPP || s1oP3;;
	  %if &s1n > 4 %then s1oPP = s1oPP || s1oP4;;		/* eMKF: right multiplication of s1uP with s1oPP produces s1oP */
	  s1oP = s1oP // j(&s2n, &s1d, 0);					/* eMKF v2.4: pad with zeroes */
      /* eMKF v2.4: segment 2 */
	  s2x = { &_s2rtimess };
	  s2x = T(s2x);
 	  %if &s2d = 1 %then s2oP = orpol(s2x, 1)[,1];;
 	  %if &s2d > 1 %then s2oP = orpol(s2x, &s2d - 1);;
	  s2x0 = { %cnstss(1, &s2n) };
	  s2x0 = T(s2x0);
	  %if &s2n > 2 %then s2x1 = s2x;;
	  %if &s2n > 3 %then s2x2 = s2x#s2x1;;
	  %if &s2n > 4 %then s2x3 = s2x#s2x2;;
	  s2uP = s2x0;	
	  %if &s2n > 2 %then s2uP = s2uP || s2x1;;	
	  %if &s2n > 3 %then s2uP = s2uP || s2x2;;	
	  %if &s2n > 4 %then s2uP = s2uP || s2x3;;	
	  s2oP1 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,1];
      %if &s2n > 2 %then s2oP2 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,2];;
      %if &s2n > 3 %then s2oP3 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,3];;
      %if &s2n > 4 %then s2oP4 = inv(T(s2uP)*s2uP)*T(s2uP)*s2oP[,4];;
	  s2oPP = s2oP1;
	  %if &s2n > 2 %then s2oPP = s2oPP || s2oP2;;
	  %if &s2n > 3 %then s2oPP = s2oPP || s2oP3;;
	  %if &s2n > 4 %then s2oPP = s2oPP || s2oP4;;
	  s2oP =  j(&s1n, &s2d, 0) // s2oP;
	  /* eMKF v2.4: off-diagonal blocks and full block matrix oPP */
      s1oPP = s1oPP // j(&s2d, &s1d, 0);
	  s2oPP = j(&s1d, &s2d, 0) // s2oPP;
	  oPP = s1oPP || s2oPP;	
	  /* eMKF v2.4: consecutive time indices and block matrix oP */
	  y = T(do(1, &s1n+&s2n, 1));
	  yP = y || s1oP || s2oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &s1d = 4 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s1rtm.3" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2" "&s2rtm.3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s1rtm.3" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s1rtm.3" "&s2rtm.0" "&s2rtm.1"} ] ;;
	  %if &s1d = 4 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s1rtm.3" "&s2rtm.0"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2" "&s2rtm.3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s2rtm.0" "&s2rtm.1"} ] ;;
	  %if &s1d = 3 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s1rtm.2" "&s2rtm.0"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2" "&s2rtm.3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s2rtm.0" "&s2rtm.1"} ] ;;
	  %if &s1d = 2 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s1rtm.1" "&s2rtm.0"} ] ;;
	  %if &s1d = 1 and &s2d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2" "&s2rtm.3"} ] ;;
	  %if &s1d = 1 and &s2d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&s2rtm.1" "&s2rtm.2"} ] ;;
	  %if &s1d = 1 and &s2d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&s2rtm.1"} ] ;;
	  %if &s1d = 1 and &s2d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &s1d = 4 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 4 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 4 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 4 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s1t3" "s2t0"} ] ;;
	  %if &s1d = 3 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 3 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 3 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 3 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s1t2" "s2t0"} ] ;;
	  %if &s1d = 2 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 2 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 2 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 2 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s1t1" "s2t0"} ] ;;
	  %if &s1d = 1 and &s2d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1" "s2t2" "s2t3"} ] ;;
	  %if &s1d = 1 and &s2d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1" "s2t2"} ] ;;
	  %if &s1d = 1 and &s2d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "s2t1"} ] ;;
	  %if &s1d = 1 and &s2d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_sdata_;
	  by _time;
	run;
	data _sdata_;
	   merge _sdata_ _oXmat_;
	   by _time;
	run;
	proc sort data= _sdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _sdata_;
	   set _sdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _sdata_ */
	   if &s1rtm > 0 then &s1rtm.0 = 1; else &s1rtm.0 = 0;
	   %if &s1d > 1 %then &s1rtm.1 = &s1rtm;;
	   %if &s1d > 2 %then &s1rtm.2 = &s1rtm**2;;
	   %if &s1d > 3 %then &s1rtm.3 = &s1rtm**3;;
	   if &s2rtm > 0 then &s2rtm.0 = 1; else &s2rtm.0 = 0;
	   %if &s2d > 1 %then &s2rtm.1 = &s2rtm;;
	   %if &s2d > 2 %then &s2rtm.2 = &s2rtm**2;;
	   %if &s2d > 3 %then &s2rtm.3 = &s2rtm**3;;
	run;
%end;

/* eMKF v2.4: Set up model statements symbolically for use in proc reg */
%let s1tline=; %let s2tline=;
%if &s1p = 4 %then %let s1tline = &s1rtm.0 &s1rtm.1 &s1rtm.2 &s1rtm.3;
%if &s1p = 3 %then %let s1tline = &s1rtm.0 &s1rtm.1 &s1rtm.2;
%if &s1p = 2 %then %let s1tline = &s1rtm.0 &s1rtm.1;
%if &s1p = 1 %then %let s1tline = &s1rtm.0;
%if &s2p = 4 %then %let s2tline = &s2rtm.0 &s2rtm.1 &s2rtm.2 &s2rtm.3;
%if &s2p = 3 %then %let s2tline = &s2rtm.0 &s2rtm.1 &s2rtm.2;
%if &s2p = 2 %then %let s2tline = &s2rtm.0 &s2rtm.1;
%if &s2p = 1 %then %let s2tline = &s2rtm.0;

/* eMKF v2.4: Modified call to proc reg to allow for two segments (expanded design matrix) */
proc reg data=_sdata_ outest=_beta_ noprint;
   by _rep _group_;
   model _y = &s1tline &s2tline /noint;;
run;

/* eMKF v2.4: Setup initial values for use in proc nlmixed */
/* eMKF v2.4 also allows for group-specific AR parameters */

/* eMKF: Sort regression coefficients by _rep and _group_ */
proc sort data=_beta_;
  by _rep _group_;
run;

/* eMKF v2.4: Initial parameter values for the first replication */
%let jj = 1;
data _inits_;
	set _beta_(where=(_rep = &jj)) end=end;
	_rep = &jj;
   	array s1ag s1ag1-s1ag&g;
   	array s1b1g s1b1g1-s1b1g&g;
   	array s1b2g s1b2g1-s1b2g&g;
   	array s1b3g s1b3g1-s1b3g&g;
   	array s2ag s2ag1-s2ag&g;
   	array s2b1g s2b1g1-s2b1g&g;
   	array s2b2g s2b2g1-s2b2g&g;
   	array s2b3g s2b3g1-s2b3g&g;
	%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
	%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
   	retain s1ag1-s1ag&g s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g s2ag1-s2ag&g s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g  
		   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
		   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
    ;
	s1ag{_group_} = &s1rtm.0;
   	%if &s1p > 1 %then s1b1g{_group_} = &s1rtm.1 ;;
   	%if &s1p > 2 %then s1b2g{_group_} = &s1rtm.2 ;;
   	%if &s1p > 3 %then s1b3g{_group_} = &s1rtm.3 ;;
	s2ag{_group_} = &s2rtm.0;
   	%if &s2p > 1 %then s2b1g{_group_} = &s2rtm.1 ;;
   	%if &s2p > 2 %then s2b2g{_group_} = &s2rtm.2 ;;
   	%if &s2p > 3 %then s2b3g{_group_} = &s2rtm.3 ;;
	%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
	%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
   	if end then do;
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
      	output;
   	end;
   	keep _rep s1ag1-s1ag&g s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g s2ag1-s2ag&g s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
		%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
		%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
	;
run;

/* eMKF v2.4: Initial estimates from each subsequent replication */
data _initsr_;
run;
%if &nrep > 1 %then %do; 	
	%do jj = 2 %to &nrep;
		data _initsr_;
			set _beta_(where=(_rep = &jj)) end=end;
			_rep = &jj;
		   	array s1ag s1ag1-s1ag&g;
		   	array s1b1g s1b1g1-s1b1g&g;
		   	array s1b2g s1b2g1-s1b2g&g;
		   	array s1b3g s1b3g1-s1b3g&g;
		   	array s2ag s2ag1-s2ag&g;
		   	array s2b1g s2b1g1-s2b1g&g;
		   	array s2b2g s2b2g1-s2b2g&g;
		   	array s2b3g s2b3g1-s2b3g&g;
			%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
			%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
		   	retain s1ag1-s1ag&g s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g s2ag1-s2ag&g s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g  
				   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
				   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
		    ;
			s1ag{_group_} = &s1rtm.0;
		   	%if &s1p > 1 %then s1b1g{_group_} = &s1rtm.1 ;;
		   	%if &s1p > 2 %then s1b2g{_group_} = &s1rtm.2 ;;
		   	%if &s1p > 3 %then s1b3g{_group_} = &s1rtm.3 ;;
			s2ag{_group_} = &s2rtm.0;
		   	%if &s2p > 1 %then s2b1g{_group_} = &s2rtm.1 ;;
		   	%if &s2p > 2 %then s2b2g{_group_} = &s2rtm.2 ;;
		   	%if &s2p > 3 %then s2b3g{_group_} = &s2rtm.3 ;;
			%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
			%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
		   	if end then do;
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   				%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
		      	output;
		   	end;
		   	keep _rep s1ag1-s1ag&g s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g s2ag1-s2ag&g s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
				%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
				%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
			;
		run;
		data _inits_;
		  set _inits_ _initsr_;
		run;
		data _initsr_;
		run;
	%end;
%end;
  
/* eMKF v2.4: calculate initial estimates for common_* scenarios and remove extraneous variables */
data _inits_; 
	set _inits_;
	s1b1=.;
	s1b2=.;
	s1b3=.;
    %if %upcase(&bvalue1) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then s1b1 = mean(of s1b1g1-s1b1g&g);;
    %if not(%upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR) %then drop s1b1g1-s1b1g&g;;
    %if %upcase(&bvalue1) in COMMON_CUBIC COMMON_QUAD %then s1b2 = mean(of s1b2g1-s1b2g&g);;
	%if not(%upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD) %then drop s1b2g1-s1b2g&g;;
 	%if %upcase(&bvalue1) = COMMON_CUBIC %then s1b3 = mean(of s1b3g1-s1b3g&g);;
 	%if %upcase(&bvalue1) ^= INDEP_CUBIC %then drop s1b3g1-s1b3g&g;;
	%if not(%upcase(&bvalue1) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR) %then drop s1b1;;
    %if not(%upcase(&bvalue1) in COMMON_CUBIC COMMON_QUAD) %then drop s1b2;;
	%if %upcase(&bvalue1) ^= COMMON_CUBIC %then drop s1b3;;
	s2b1=.;
	s2b2=.;
	s2b3=.;
	%if %upcase(&bvalue2) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then s2b1 = mean(of s2b1g1-s2b1g&g);;
    %if not(%upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR) %then drop s2b1g1-s2b1g&g;;
    %if %upcase(&bvalue2) in COMMON_CUBIC COMMON_QUAD %then s2b2 = mean(of s2b2g1-s2b2g&g);;
	%if not(%upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD) %then drop s2b2g1-s2b2g&g;;
 	%if %upcase(&bvalue2) = COMMON_CUBIC %then s2b3 = mean(of s2b3g1-s2b3g&g);;
 	%if %upcase(&bvalue2) ^= INDEP_CUBIC %then drop s2b3g1-s2b3g&g;;
	%if not(%upcase(&bvalue2) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR) %then drop s2b1;;
    %if not(%upcase(&bvalue2) in COMMON_CUBIC COMMON_QUAD) %then drop s2b2;;
	%if %upcase(&bvalue2) ^= COMMON_CUBIC %then drop s2b3;;
run;

/* eMKF v2.4: re-order columns in common trend cases so the logitrho and logtau2 remain last and each segment's coefficients remain grouped together */
%if %upcase(&bvalue1) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
	data _inits_;
	  merge _inits_(drop = s2: logtau2: logitrho:) _inits_(keep = _rep s2:) _inits_(keep=_rep logtau2: logitrho:);
	  by _rep;
	run;
%end;
%else %do;
	%if %upcase(&bvalue2) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
		data _inits_;
		  merge _inits_(drop = logtau2: logitrho:) _inits_(keep = _rep logtau2: logitrho:);
		  by _rep;
		run;
	%end;
%end;

/* eMKF v2.4: Set up array declarations for tau and rho parameters symbolically for use in proc nlmixed */
%let tauline=; %let rholine=;
%if %upcase(&ARvalue) ^= COMMON_AR %then %let tauline = array logtau2g(&g) logtau2g1-logtau2g&g%str(;) array _tausq_(&g) _tausq_1-_tausq_&g%str(;) ;
%if %upcase(&ARvalue) = INDEP_AR %then %let rholine= array logitrhog(&g) logitrhog1-logitrhog&g%str(;) array _rho_(&g) _rho_1-_rho_&g%str(;) ; 

/* eMKF v2.4: Set up array declarations symbolically for use in proc nlmixed */
%let s1b1line=; %let s1b2line=; %let s1b3line=; %let s2b1line=; %let s2b2line=; %let s2b3line=;
%if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %let s1b1line= array s1b1g(&g) s1b1g1-s1b1g&g ;
%if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD %then %let s1b2line= array s1b2g(&g) s1b2g1-s1b2g&g ;
%if %upcase(&bvalue1) = INDEP_CUBIC %then %let s1b3line= array s1b3g(&g) s1b3g1-s1b3g&g ;
%if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %let s2b1line= array s2b1g(&g) s2b1g1-s2b1g&g ;
%if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD %then %let s2b2line= array s2b2g(&g) s2b2g1-s2b2g&g ;
%if %upcase(&bvalue2) = INDEP_CUBIC %then %let s2b3line= array s2b3g(&g) s2b3g1-s2b3g&g ;

/* eMKF v2.4: Set up model statement symbolically for use in proc nlmixed */
%let tline=; %let s1tline=; %let s2tline=;
%if %upcase(&bvalue1) = INDEP_CUBIC   %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1g[_group_]+&s1rtm.2*s1b2g[_group_]+&s1rtm.3*s1b3g[_group_];
%if %upcase(&bvalue1) = INDEP_QUAD    %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1g[_group_]+&s1rtm.2*s1b2g[_group_];
%if %upcase(&bvalue1) = INDEP_LINEAR  %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1g[_group_];
%if %upcase(&bvalue1) = COMMON_CUBIC  %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1+&s1rtm.2*s1b2+&s1rtm.3*s1b3;
%if %upcase(&bvalue1) = COMMON_QUAD   %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1+&s1rtm.2*s1b2;
%if %upcase(&bvalue1) = COMMON_LINEAR %then %let s1tline= &s1rtm.0*s1ag[_group_]+&s1rtm.1*s1b1;
%if %upcase(&bvalue1) = DROPPED       %then %let s1tline= &s1rtm.0*s1ag[_group_];
%if %upcase(&bvalue2) = INDEP_CUBIC   %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1g[_group_]+&s2rtm.2*s2b2g[_group_]+&s2rtm.3*s2b3g[_group_];
%if %upcase(&bvalue2) = INDEP_QUAD    %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1g[_group_]+&s2rtm.2*s2b2g[_group_];
%if %upcase(&bvalue2) = INDEP_LINEAR  %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1g[_group_];
%if %upcase(&bvalue2) = COMMON_CUBIC  %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1+&s2rtm.2*s2b2+&s2rtm.3*s2b3;
%if %upcase(&bvalue2) = COMMON_QUAD   %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1+&s2rtm.2*s2b2;
%if %upcase(&bvalue2) = COMMON_LINEAR %then %let s2tline= &s2rtm.0*s2ag[_group_]+&s2rtm.1*s2b1;
%if %upcase(&bvalue2) = DROPPED       %then %let s2tline= &s2rtm.0*s2ag[_group_];
%let tline = normal(&s1tline+&s2tline+gamma[_time],_se**2);

/* eMKF v2.4: Fit a Non-linear mixed model. Capture covariance matrix COV if requested.*/

data _ests _fitstat _convstat &out._fitstat &out._covmat;
run;

%put ;
%put Start model fitting using PROC NLMIXED;

/* eMKF: model print handling */
%if %upcase(&print) ^= YES %then ods exclude all;; 

/* eMKF v2.4: initialized counters for use in proc nlmixed */
%let i=0; %let j=0;

/* eMKF v2.4: Error check to make sure specified optimization method is valid */
%if not(%upcase(&nlmixedTech) in CONGRA DBLDOG NEWRAP NMSIMP NONE NRRIDG QUANEW TRUREG) %then %do;
	%put ERROR: proc nlmixed syntax error. Specified optimization algorithm &nlmixedTech not recognized. Please check!;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
/* eMKF v2.4 streamlining: omitted calculation of reverse-transformed rho and tausq (estimate statements) and ecov */ 
/* eMKF v2.4 now also allows for group-specific AR parameters (_rho_ and _tausq_ can no longer be user-supplied) */
proc nlmixed data=_sdata_ DF=&nlmixedDF %if %upcase(&nlmixedDetails) = YES %then cov; 
	tech=&nlmixedTech				 /* eMKF v2.4: can replace default (QUANEW) optimization with other available methods */
	method=firo maxiter=500; 		 /* eMKF: updated method and maxiter to match those in htrp2d */
	by _rep; 						 /* eMKF: stratified by _rep (trivial if _rep is constant = 1 (i.e., no stratification) */
	array gamma(&n) gamma1-gamma&n ; /* Give the gamma values a generic name */
	array s1ag(&g) s1ag1-s1ag&g; 	 /* eMKF v2.4: Give the a values a generic name for segment 1 */
	&s1b1line;; 					 /* eMKF v2.4: Give the bl values a generic name for segment 1 */
	&s1b2line;; 					 /* eMKF v2.4: Give the b2 values a generic name for segment 1 */
	&s1b3line;; 					 /* eMKF v2.4: Give the b3 values a generic name for segment 1 */ 
	array s2ag(&g) s2ag1-s2ag&g;	 /* eMKF v2.4: Give the a values a generic name for segment 2 */
	&s2b1line;;						 /* eMKF v2.4: Give the bl values a generic name for segment 2 */
	&s2b2line;; 					 /* eMKF v2.4: Give the b2 values a generic name for segment 2 */
	&s2b3line;;						 /* eMKF v2.4: Give the b3 values a generic name for segment 2 */
	&tauline;;						 /* eMKF v2.4: group-specific innovation variances (if any) */
	&rholine;;						 /* eMKF v2.4: group-specific autocorrelation coefficients (if any) */
	%if %upcase(&ARvalue)^=COMMON_AR 
	  %then array nu(&g) nu1-nu&g;;  /* eMKF v2.4: group-specific stationary variances (if any) */
	parms / bydata data=_inits_; 	 /* eMKF: Setup parameters and their initial values stratified by _rep */

	%if %upcase(&ARvalue)=COMMON_AR %then %do; 
		bounds logitrho >= 0;		 /* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		_tausq_ = exp(logtau2);
		nu = _tausq_/(1-(_rho_**2));
	%end;
	%if %upcase(&ARvalue)=COMMON_ARH %then %do;
		bounds logitrho >= 0;		 /* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		%do j = 1 %to &g;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_**2));
		%end;
	%end;
	%if %upcase(&ARvalue)=INDEP_AR %then %do;
		bounds logitrhog1-logitrhog&g >= 0;	/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		%do j = 1 %to &g;
			_rho_&j = 2/(1+exp(-logitrhog&j)) - 1;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_&j**2));
		%end;
	%end;

	/* Random effects gamma1 gamma2 ... gamma&n ~ normal([0,0,..,0],[nu, half triangular matrix]) */
	/* eMFK: Replaced do loop for variances with call to macro thevarcompr to allow for noninteger/unequally-spaced time points */
	/* eMKF v2.4 allows for group-specific AR coefficients */
	%if %upcase(&ARvalue) = COMMON_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu, vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = COMMON_ARH %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = INDEP_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_[_group_])) subject=_group_;
	%end;

	model _y ~ &tline;;

	/* eMKF v2.4 streamlining: added output for convergence status */
	ods output parameterestimates=_ests fitstatistics=_fitstat convergencestatus=_convstat;
	%if %upcase(&nlmixedDetails) = YES %then ods output CovMatParmEst=&out._covmat;;
run;

/* eMKF v2.4: Error check to make sure proc nlmixed converged */
%let nlmerr = 0;
data _null_;
  set _convstat;
  if Status = 1 then call symput("nlmerr" , 1);
run;
%let nlmerr = %eval(0 + &nlmerr);
%if &nlmerr %then %do;
	%put ERROR: proc nlmixed returned an error. Try specifying an optimization algorithm other than &nlmixedTech.;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
%if %upcase(&nlmixedDetails) ^= YES %then %do;
	data _ests;
	  set _ests;
	  drop StandardError DF tValue Probt Alpha Lower Upper Gradient;
	run;
%end;

/* eMKF: Replace missing values in CovMatParmEst with 0s for later use */
%if %upcase(&nlmixedDetails) = YES and %upcase(&orpoly) = YES %then %do;
	data &out._covmat;
	  set &out._covmat;
	  array NAs _numeric_;
	  do over NAs;
	      if NAs = . then NAs = 0;
	  end;
	run;
%end;

/* eMKF: Reset ODS destinations if they were turned off */
%if %upcase(&print) ^= YES %then ods exclude none;;

/* eMKF: Added put statements for log */
%put ;
%put End model fitting using PROC NLMIXED;
%if %upcase(&print) ^= YES %then %put Model printout was turned off by user.;;

/* eMKF: Model estimates */
data _fitstat;
   set _fitstat;
   if descr = "-2 Log Likelihood";
   _2loglike=value;
   keep _2loglike _rep;
run;
data &out._fitstat;
  merge _ests _fitstat;
  by _rep;
run;
data _llike_;
run;
data _llike_;
  set &out._fitstat;
  by _rep;
  if first._rep then output;
  keep _rep _2loglike;
run;
data &out._ests;
run;
proc transpose data=&out._fitstat out=&out._ests;
   by _rep;
   var estimate;
   id parameter;
run;

/* eMKF v2.4 streamlining: Macro variables for the segment-specific means; _emkfkeep_  is now defunct; p will be used to track which coefficients to keep */
%let _emkfmu_ = ; %let _s1emkfmu_ = ; %let _s2emkfmu_ = ; 
%if &s1p = 4 %then %let _s1emkfmu_ = s1a*&s1rtm.0+s1b1*&s1rtm.1+s1b2*&s1rtm.2+s1b3*&s1rtm.3;
%if &s1p = 3 %then %let _s1emkfmu_ = s1a*&s1rtm.0+s1b1*&s1rtm.1+s1b2*&s1rtm.2;
%if &s1p = 2 %then %let _s1emkfmu_ = s1a*&s1rtm.0+s1b1*&s1rtm.1;
%if &s1p = 1 %then %let _s1emkfmu_ = s1a*&s1rtm.0;
%if &s2p = 4 %then %let _s2emkfmu_ = s2a*&s2rtm.0+s2b1*&s2rtm.1+s2b2*&s2rtm.2+s2b3*&s2rtm.3;
%if &s2p = 3 %then %let _s2emkfmu_ = s2a*&s2rtm.0+s2b1*&s2rtm.1+s2b2*&s2rtm.2;
%if &s2p = 2 %then %let _s2emkfmu_ = s2a*&s2rtm.0+s2b1*&s2rtm.1;
%if &s2p = 1 %then %let _s2emkfmu_ = s2a*&s2rtm.0;
%let _emkfmu_ = mu=&_s1emkfmu_+&_s2emkfmu_;;

/* eMKF v2.4: Re-structure estimates by _rep and _group_ */
data &out._ests;
   merge &out._ests _llike_;
   by _rep;
   array s1as s1ag1-s1ag&g;
   %if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then array s1b1s s1b1g1-s1b1g&g;;
   %if %upcase(&bvalue1) = DROPPED %then s1b1 = 0;;
   %if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD %then array s1b2s s1b2g1-s1b2g&g;;
   %if %upcase(&bvalue1) = DROPPED %then s1b2 = 0;;
   %if %upcase(&bvalue1) = INDEP_CUBIC %then array s1b3s s1b3g1-s1b3g&g;;
   %if %upcase(&bvalue1) = DROPPED %then s1b3 = 0;;
   array s2as s2ag1-s2ag&g;
   %if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then array s2b1s s2b1g1-s2b1g&g;;
   %if %upcase(&bvalue2) = DROPPED %then s2b1 = 0;;
   %if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD %then array s2b2s s2b2g1-s2b2g&g;;
   %if %upcase(&bvalue2) = DROPPED %then s2b2 = 0;;
   %if %upcase(&bvalue2) = INDEP_CUBIC %then array s2b3s s2b3g1-s2b3g&g;;
   %if %upcase(&bvalue2) = DROPPED %then s2b3 = 0;;
   /* eMKF v2.4 allows for group-specific AR coefficients */
   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2s logtau2g1-logtau2g&g ;;
   %if %upcase(&ARvalue) = COMMON_AR %then _tausq_ = exp(logtau2) ;; 
   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhos logitrhog1-logitrhog&g ;;
   %if %upcase(&ARvalue) ^= INDEP_AR %then _rho_ = 2/(1+exp(-logitrho))-1 ;;
   do _group_ = 1 to &g;
      s1a = s1as{_group_};
      %if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then s1b1 = s1b1s{_group_};;
	  %if %upcase(&bvalue1) in INDEP_CUBIC INDEP_QUAD %then s1b2 = s1b2s{_group_};;
      %if %upcase(&bvalue1) = INDEP_CUBIC %then s1b3 = s1b3s{_group_};;
      s2a = s2as{_group_};
      %if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then s2b1 = s2b1s{_group_};;
	  %if %upcase(&bvalue2) in INDEP_CUBIC INDEP_QUAD %then s2b2 = s2b2s{_group_};;
      %if %upcase(&bvalue2) = INDEP_CUBIC %then s2b3 = s2b3s{_group_};;
	  %if %upcase(&ARvalue) ^= COMMON_AR %then _tausq_ = exp(logtau2s{_group_}) ;;
	  %if %upcase(&ARvalue) = INDEP_AR %then _rho_ = 2/(1+exp(-logitrhos{_group_}))-1 ;;
      output;
   end;
   keep _rep _group_ s1a %if &s1p > 1 %then s1b1-s1b&s1k ; s2a %if &s2p > 1 %then s2b1-s2b&s2k ; _tausq_ _rho_ _2loglike;
run;

/* eMKF v2.4 streamlining: reordered columns here and used &s1p and &s2p instead of &_emkfkeep_ to track which coefficients to keep */
data &out._ests; 
  merge &out._ests(keep= _rep _group_)
		&out._ests(keep= s1a) %if &s1p > 1 %then &out._ests(keep= s1b1-s1b&s1k); 
		&out._ests(keep= s2a) %if &s2p > 1 %then &out._ests(keep= s2b1-s2b&s2k);
		&out._ests(keep= _tausq_) &out._ests(keep= _rho_) &out._ests(keep= _2loglike) ;
run;

/* eMKF: Merge with group labels */
proc sort data= &out._ests;
  by _group_ ;
run;
proc sort data=_freqg_;
  by _group_;
run;
data &out._ests;
  merge &out._ests _freqg_;
  by _group_;
run;

/***************************************************************************/
/* Now let's use the Kalman technique to estimate the outcome observations */
/***************************************************************************/

data &out._pred;
run;
proc sort data=_sdata_ out=&out._pred;
  by _rep _group_ _time; 
run;

proc sort data=&out._ests;
  by _rep _group_;
run;

data &out._pred; 
  merge &out._pred &out._ests;
  by _rep _group_ ;
  &_emkfmu_;; 					/* eMKF: invoke symbolic calculation for mu */
  err=_y - mu;
run;

data _empty_;
  set &out._pred;
  if _time= 1;
  w0 = _tausq_/(1-(_rho_**2));
  gamma0 = 0 ;
  _time= 0;
  &rtm= 0;
  &rlag = .;
  keep _time &rtm 				/* eMKF v2.4: modified to keep segment-specific coefficients */
		&s1rtm.0 %if &s1d > 1 %then &s1rtm.1; %if &s1d > 2 %then &s1rtm.2; %if &s1d > 3 %then &s1rtm.3; 
		&s2rtm.0 %if &s2d > 1 %then &s2rtm.1; %if &s2d > 2 %then &s2rtm.2; %if &s2d > 3 %then &s2rtm.3; 
		&rlag &by _rep &group _group_ w0 gamma0; 
run;

data &out._pred;
 set &out._pred _empty_;
 if _time = 1 then &rlag = 1;	/* eMKF: set to lag 1 instead of missing relative to time 0 */
run;

proc sort data=&out._pred;
 by _rep _group_ _time;
run;

/* eMKF: recursion formulas modified to allow lag s > 0 between time points */
data &out._pred;
  set &out._pred;
  retain wold gamold;
  delta = ((_rho_**(2*&rlag)) * wold) + _tausq_*(1 - (_rho_**(2*&rlag)))/(1 - (_rho_**2));
  if &rlag > 0 or &rlag = . then lambda = delta/(delta + (_se**2));
  else lambda = 0; 				/* eMKF: in the limiting case, recursion breaks down: set lambda = 0 instead */
  w = delta * (1-lambda);
  gamma = (lambda* err) + (1-lambda)*(_rho_**&rlag)*gamold ; /* eMKF: &rlag=1 reduces to unit-increment case */
  prediction = mu + gamma ;
  output;
  if _time = 0 then do;
	wold=w0;
	gamold=gamma0;
  end;  
  if _time ^= 0 then do; 
	wold=w;
    gamold=gamma;
  end;
run;

/* eMKF v2.4 correction: added hyphen separator between _rep and _group_ to cover cases with more than 10 reps or groups (e.g., 1-11 vs 11-1) */
%let group_rep = compress(_rep ||"-"|| _group_);

data &out._pred;
  set &out._pred;
  group_rep= &group_rep;
  if _time ne 0;
  drop w0 gamma0 wold gamold;
run;

/* eMKF: reset lag for time 1 to missing */
data &out._pred;
  set &out._pred;
  if _time = 1 then &rlag = .; 
run;

/******************/
/* Compute the MSE*/
/******************/

data _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_  _Xmat_ _junk_ _junk0_ _junk01_;
run;

proc sort data=&out._pred(keep= _rep &by _group_ &group _time &rtm  /* eMKF v2.4: modified to keep segment-specific coefficients */
								&s1rtm.0 %if &s1d > 1 %then &s1rtm.1; %if &s1d > 2 %then &s1rtm.2; %if &s1d > 3 %then &s1rtm.3; 
								&s2rtm.0 %if &s2d > 1 %then &s2rtm.1; %if &s2d > 2 %then &s2rtm.2; %if &s2d > 3 %then &s2rtm.3; 
								&rlag _y _se _rho_ _tausq_ err lambda prediction group_rep)
  out=_Amat_ ;
  by group_rep;
run;

data _Amat_;
  set _Amat_; 
  by group_rep;
  array hs ah1-ah&n (%zeross(&n));
  if first.group_rep then do _k=1 to &n; hs{_k}=0; end;
  if _time = 1 then ah1=lambda;
  else do;
  	 /* eMKF: updated to account for &rlag if not 1 */
     do _j=1 to _time - 1;
	    hs{_j} = hs{_j}*(1-lambda)*(_rho_**&rlag) ; 
	 end;
	 hs{_time}=lambda;
  end;
  
  drop group_rep _k _j;
  keep _rep &by _group_ &group _time &rtm &rlag ah:;
run;

proc sort data=_Amat_;
  by _rep _group_ _time  ;
run;

/* Attach row number _id to each of the A Matrix so that when computing group by group the appropriate Ag could be called*/
data _Amat_;
  set _Amat_;
  _id+1;
run;

data _Dmat_;
  set &out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4: modified to keep segment-specific coefficients */
						&s1rtm.0 %if &s1d > 1 %then &s1rtm.1; %if &s1d > 2 %then &s1rtm.2; %if &s1d > 3 %then &s1rtm.3; 
						&s2rtm.0 %if &s2d > 1 %then &s2rtm.1; %if &s2d > 2 %then &s2rtm.2; %if &s2d > 3 %then &s2rtm.3; 
						&rlag _y _rho_ _tausq_ _se);
  w0 = _tausq_/(1- (_rho_**2));
run;

/* The Matrix _Dmat_ is actually the same within group and within replication*/
proc sort data= _Dmat_ nodupkey;
  by _rep _group_ _time;
run;

/* Here the standard error is the same from one replication to another by different from group to group. 
   So these matrices should just be estimated differently for each group as well as replication if possible */
data _Vmat_; 
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 			 /* eMKF: modification to deal with irregular time points */
  do i=1 to &n; 
  	 if i = _time  then ad{i} = w0 + _se**2; /* Add the variances of Y to the diagonal elements */
   	 else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* Recreate the variance where only the Variance of gamma is estimated
 This is mostly needed for check of what the estimates are giving us. */
data _Vgmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is the diagonal Variance matrix of the errors */
data _Vemat_;
  set _Dmat_;
  array ad ad1-ad&n;
  do i=1 to &n;
    if i = _time then ad{i}= _se**2;
    else ad{i} = 0;
  end;
  drop i;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is just like the _Vgmat_ but with extra variables kept to be used later for the creation of the X matrix for example*/
data _Dmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
run;

/* This is the X matrix */
data _Xmat_;
  set _Dmat_;
  /* eMKF v2.4: modification to include segments s1 and s2 */
  s1x0 = &s1rtm.0; 
  %if &s1d > 1 %then s1x1 = &s1rtm.1;;
  %if &s1d > 2 %then s1x2 = &s1rtm.2;;
  %if &s1d > 3 %then s1x3 = &s1rtm.3;;
  s2x0 = &s2rtm.0; 
  %if &s2d > 1 %then s2x1 = &s2rtm.1;;
  %if &s2d > 2 %then s2x2 = &s2rtm.2;;
  %if &s2d > 3 %then s2x3 = &s2rtm.3;;
  keep _rep &by _group_ &group 
	  s1x0 %if &s1d > 1 %then s1x1; %if &s1d > 2 %then s1x2; %if &s1d > 3 %then s1x3; 
	  s2x0 %if &s2d > 1 %then s2x1; %if &s2d > 2 %then s2x2; %if &s2d > 3 %then s2x3;
  ;
run;

data &out._H &out._PredVar &out._CovY;
run;

/*******************************************************************************************************************************/
/* eMKF v2.4 streamlining: Removed portion of code that pertained to symbolic matrix operations redundant with use of proc iml */
/*                         Those symbolic operations were stored in unused macro variables iis, vmatinv, vmat, xmat, and blmat  */
/*******************************************************************************************************************************/

/* Now let's capture the A Matrix and turn it into a diagonal block matrix  */

data _junk_;
  set _Amat_;
  by _rep;
  if first._rep then sid=0;
  sid+1;
  repgrp=&group_rep; /* eMKF v2.4 streamlining: repgrp assigned value of macro variable &group_rep */
run;

proc sort data=_junk_;
  by repgrp sid;
run;

data _junk_;
  set _junk_;
  by repgrp;
  if first.repgrp then kp=1;
  if last.repgrp then kp=2;
  if kp=1 or kp=2;
  keep _rep &by _group_ &group _time &rtm &rlag sid kp repgrp; 	/* eMKF: also keeping &rtm and &rlag */
run;

data _junk_;
  set _junk_;
  by repgrp;
  retain minid maxid;
  array Aid(1:2) minid maxid;
  if first.repgrp then do;
    do i = 1 to 2;
      Aid[i] = .; /*initializing to missing*/
    end;
  end;
  Aid(kp) = sid; 
  if last.repgrp then output; 
  drop kp sid i;
run;

proc sort data=_junk_;
 by _rep _group_ _time;
run;

%let jj = 0; %let lj = 0;
data _junk_;
  set _junk_;
  by _rep;
  mm=0;
  if last._rep then mm=1;
  amat=compress("Z["||minid||":"||maxid||",]"); 			/* Here Z will be the standard matrix definition that can be used */
  if mm=0 then amat=compress(amat||",");
  if first._rep or mm=0 then amat=compress("block("||amat); /* eMKF: modified to allow for arbitrary number of groups */
  call symput("jj", _n_);
  if last._rep then call symput("lj", length(amat));		/* eMKF: added to capture maximal length of character variable needed */
run;

/* eMKF: modification to allow for arbitrary number of groups (function block restricted to 15) */
data _junk_;
  set _junk_;
  if _n_=&jj then mm=2;
  length amat2 $ %eval(&g+&lj+10);							/* eMKF: set large enough character length to cover block( + lj + g times ) */
  amat2 = amat;
  %if &g = 1 %then %do;
  	  if mm=1 then amat2=compress(amat||") ");
  	  if mm=2 then amat2=compress(amat||") ");
  %end;
  %if &g > 1 %then %do;
      if mm=1 then amat2=compress(amat||repeat(") ", &g-2));
      if mm=2 then amat2=compress(amat||repeat(") ", &g-2));
  %end;
  drop amat;
  rename amat2 = amat;
run;

proc sort data=_junk_;
  by _rep _group_;
run;

data _junk_;
  set _junk_;
  name=compress("&group"||_group_);
run;

data _junk0_ _junk01_;
run;

proc transpose data=_junk_(keep=name _rep &by amat) out=_junk0_;
  var amat;
  by _rep;
  id name;
run;

proc sort data=_junk_ out=_junk01_ nodupkey;
  by _group_;
run;

%let amat=;
proc sql noprint;
  select name into :amat separated by ' || ' from _junk01_;
quit;

data _junk0_;
  set _junk0_;
  i+1;
  code=compress("Z"||i);
  mcode=compress("_Z"||i);
  amat=compress(code||"="||&amat);
  keep amat _rep code mcode;
run;

%let jj=0;
%do jj=1 %to &nrep;
  %local _Z&jj ;
%end;

data _null_;
  set _junk0_;
  call symput(mcode, amat);
run;

%let jj=0;

proc iml;

	 %do jj=1 %to &nrep;

		/* Next for the Xmatrix */
		/* eMKF v2.4: modified to allow for quadratic and cubic trend models in each segment */
		use _Xmat_(where=(_rep=&jj) keep= _rep s1x: s2x:);
		read all into XX; close _Xmat_; /* eMKF: also added close statements for cleanliness */
		Z = XX[,2:(1+&s1p)] || XX[,(2+&s1d):(1+&s1d+&s2p)];
		&&_Z&jj ;;
	 	Xs = Z&jj;

		/* Next for the V matrix */
		use _Vmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VV; close _Vmat_; 
		Z =VV[,2:(1+&n)];
		&&_Z&jj ;;
		Vs = Z&jj;
		invVs=inv(Vs); 

		/* Next for the Ve matrix */
		use _Vemat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVe; close _Vemat_;
		Z =VVe[,2:(1+&n)];
		&&_Z&jj ;;
		Ves = Z&jj; 

		/* Next for the Vg matrix */
		use _Vgmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVg; close _Vgmat_;
		Z =VVg[,2:(1+&n)];
		&&_Z&jj ;;
		Vgs = Z&jj; 

		/* Next for the A matrix */
		use _Amat_(where=(_rep=&jj)  keep= _rep ah:);
	    read all into AA; close _Amat_;
		Z =AA[,2:(1+&n)];
		&&_Z&jj ;;
		As = Z&jj; 

		/* Next for the data label matrix */
		use _Dmat_(where=(_rep=&jj) keep=_rep &by &group &rtm _time _y _se);  /* eMKF: also keeping &rtm */
		read all var{_y} into Y;
		read all var{_rep &by &group &rtm _time} into NM;
		close _Dmat_;

		/* Now do the estimations */
		i_&n = i(&n*&g);
		H = Xs * inv(t(Xs)*invVs*Xs)*t(Xs)*invVs;
		fH = H + As*(i_&n - H);
		fY = fH * Y;
		Vy = vecdiag(fH * Vs * t(fH));
		MSEy = vecdiag(  (fH - i_&n) * Vgs * t(fH - i_&n)   ) + vecdiag(fH * Ves * t(fH));
		ff= NM || fH;
		fV= NM || Vs;
		fVy=NM || fY || Vy || MSEy;

		%if &jj = 1 %then ffs= ff;;
		%if &jj = 1 %then fVs= fV;;
		%if &jj = 1 %then fVys= fVy;;
		%if &jj > 1 %then ffs= ffs // ff;;
		%if &jj > 1 %then fVs= fVs // fV;;
		%if &jj > 1 %then fVys= fVys // fVy;; 

	 %end;

	 /* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	 %if %upcase(&nlmixedDetails) = YES %then %do;
		 create &out._H from ffs ;
		 append from ffs; close &out._H;
		 create &out._CovY from fVs ;
		 append from fVs; close &out._CovY;
	 %end;

	 %if &by ^=%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&by" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 %if &by  =%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 append from fVys; close &out._PredVar;
	 
quit; /* eMKF: ends call to proc iml with matrix calculations*/

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;		/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;
	  %if &by  =%str() %then rename col1=_rep 	       col2= &group col3=&rtm col4=_time;;
	run;
	data &out._CovY;
	  set &out._CovY; 	/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;
	  %if &by  =%str() %then rename col1=_rep          col2= &group col3=&rtm col4=_time;;
	run;
%end;

/* eMKF: merge with predictions dataset */
data &out._pred;
  merge &out._pred &out._PredVar;
  by _rep &group _time;
  /* eMKF v2.4: remove polynomial time terms from &out._pred */
  drop &s1rtm.0 %if &s1d > 1 %then &s1rtm.1; %if &s1d > 2 %then &s1rtm.2; %if &s1d > 3 %then &s1rtm.3; 
	   &s2rtm.0 %if &s2d > 1 %then &s2rtm.1; %if &s2d > 2 %then &s2rtm.2; %if &s2d > 3 %then &s2rtm.3; 
  ;
run;

/************************/
/* End of MSE estimation*/
/************************/

/*************************************************************************/
/* eMKF: Reverse-transform regression coefficients and covariance matrix */
/*************************************************************************/

data _tests _lests _s1lests _s2lests _tfits _tcmat _tcmat1 _tcmat2 _covmat1 _covmat2 _covmat12 _covmat21
	 _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt ;
run;

%if %upcase(&orpoly) = YES %then %do;

	/* eMKF v2.4: reverse-transform regression coefficients modified for two segments */
	%let jj = 0; 
	proc iml;
		use _oPmat_;
		read all into oPP; close _oPmat_;
		oPP = block(oPP[1:&s1p, 1:&s1p], oPP[(1+&s1d):(&s1d+&s2p), (1+&s1d):(&s1d+&s2p)]);
		varNames = {"_rep" "_group_" "s1a"};
		%if &s1p > 1 %then %do;
			bNames = "s1b1":"s1b&s1k";	
			varNames = varNames || bNames;
		%end;
		varNames = varNames || {"s2a"};
		%if &s2p > 1 %then %do;
			bNames = "s2b1":"s2b&s2k";	
			varNames = varNames || bNames;
		%end;
		create _tests var varNames;
		%do jj=1 %to &nrep;
			/* eMKF v2.4 streamlining: use s1: (resp., s2:) to reference all segment 1 (resp., 2) coefficients */
			use &out._ests(where=(_rep = &jj) keep= _rep _group_ s1: s2: ); 
			read all into oB; close &out._ests;
			oB1 = oB[,1:2];
            oB = T(oB[,3:(2+&s1p+&s2p)]);
            oBB = oPP * oB;
			oBB = T(oBB);
			oBB = oB1 || oBB;
			append from oBB;
		%end;
		close _tests;
	quit;

	/* eMKF: sort by _rep and _group_ */
	proc sort data=_tests;
  	  by _rep _group_ ;
	run;

	/* eMKF v2.4: update estimates dataset modified to account for 2 segments */
	data &out._ests;
  	  merge _tests &out._ests(drop=s1: s2:) ; 
	  by _rep _group_;
	run;

	/* eMKF v2.4: update of predictions dataset modified to account for 2 segments */
	data &out._pred;
	  merge &out._pred(drop= s1: s2: _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) 
			_tests &out._pred(keep=_rep _group_ _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) ;
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;

		/* eMKF v2.4: symbolic set up for reverse-transformation of covariance matrix modified to account for 2 segments */
		%let s1oPPmat = ; %let i = 0; 	/* eMKF v2.4: block diagonal by group for segment 1 */
		%do i=1 %to &g; 
			%if &i = 1 %then %let s1oPPmat = block( s1oP ;
			%if &i > 1 and &i < &g %then %let s1oPPmat = &s1oPPmat , block ( s1oP ;
			%if &i = &g and &g > 1  %then %let s1oPPmat = &s1oPPmat , s1oP %sysfunc(repeat( %str(%)), &g-2));
			%if &i = &g and &g = 1  %then %let s1oPPmat = &s1oPPmat );
		%end;
		%let s2oPPmat = ; %let i = 0;	/* eMKF v2.4: block diagonal by group for segment 2 */
		%do i=1 %to &g;  
			%if &i = 1 %then %let s2oPPmat = block( s2oP ;
			%if &i > 1 and &i < &g %then %let s2oPPmat = &s2oPPmat , block ( s2oP ;
			%if &i = &g and &g > 1  %then %let s2oPPmat = &s2oPPmat , s2oP %sysfunc(repeat( %str(%)), &g-2));
			%if &i = &g and &g = 1  %then %let s2oPPmat = &s2oPPmat );
		%end;
		%let s1colList = ; %let i = 0;	/* eMKF v2.4: segment 1 column labels */
		%do i=1 %to &g;
			%let s1colList = &s1colList s1ag&i;
			%if %upcase(&bvalue1) in INDEP_LINEAR INDEP_QUAD INDEP_CUBIC %then %let s1colList = &s1colList s1b1g&i;;
			%if %upcase(&bvalue1) in INDEP_QUAD INDEP_CUBIC %then %let s1colList = &s1colList s1b2g&i;;
			%if %upcase(&bvalue1) = INDEP_CUBIC %then %let s1colList = &s1colList s1b3g&i;;
		%end;
		%if %upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %let s1colList = &s1colList s1b1;;
		%if %upcase(&bvalue1) in COMMON_QUAD COMMON_CUBIC %then %let s1colList = &s1colList s1b2;;
		%if %upcase(&bvalue1) = COMMON_CUBIC %then %let s1colList = &s1colList s1b3;;
		%let s2colList = ; %let i = 0; 	/* eMKF v2.4: segment 2 column labels */
		%do i=1 %to &g;
			%let s2colList = &s2colList s2ag&i;
			%if %upcase(&bvalue2) in INDEP_LINEAR INDEP_QUAD INDEP_CUBIC %then %let s2colList = &s2colList s2b1g&i;;
			%if %upcase(&bvalue2) in INDEP_QUAD INDEP_CUBIC %then %let s2colList = &s2colList s2b2g&i;;
			%if %upcase(&bvalue2) = INDEP_CUBIC %then %let s2colList = &s2colList s2b3g&i;;
		%end;
		%if %upcase(&bvalue2) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %let s2colList = &s2colList s2b1;;
		%if %upcase(&bvalue2) in COMMON_QUAD COMMON_CUBIC %then %let s2colList = &s2colList s2b2;;
		%if %upcase(&bvalue2) = COMMON_CUBIC %then %let s2colList = &s2colList s2b3;;

		/* eMKF v2.4: square block matrix of covariances for regression coefficients by group and segment */
		data _covmat1; /* Segment 1 */
		  retain _rep Row Parameter &s1colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 's1') keep = _rep Row Parameter &s1colList);;
		run;
		data _covmat2; /* Segment 2 */
		  retain _rep Row Parameter &s2colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 's2') keep = _rep Row Parameter &s2colList);;
		run;
		data _covmat12; /* Segment 1 by 2 */
		  retain _rep Row Parameter &s2colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 's1') keep = _rep Row Parameter &s2colList);;
		run;
		data _covmat21; /* Segment 2 by 1 */
		  retain _rep Row Parameter &s1colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 's2') keep = _rep Row Parameter &s1colList);;
		run;

		/* eMKF v2.4: obtain new row numbers associated with modified column order */
		data _tcmat1; /* Segment 1 */
		  set _covmat1;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat1 out=_tcmat1;
	      by _rep;
	    run;
		data _tcmat1;
		  set _tcmat1;
		  by _rep;
		  if first._rep then nRow = 0;
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col:;
		run;
		data _tcmat2; /* Segment 2 */
		  set _covmat2;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat2 out=_tcmat2;
	      by _rep;
	    run;
		data _tcmat2;
		  set _tcmat2;
		  by _rep;
		  if first._rep then nRow = 0;
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col:;
		run;

		/* eMKF v2.4 streamlining: offset to add to row numbers in _tcmat2 is now determined from model dimensions */
		data _tcmat2;
		  set _tcmat2;
		  %if not(%upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then nRow = nRow + &g*&s1p;;
		  %if %upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then nRow = nRow + &g + &s1k;;
		run;

		/* eMKF v2.4: sort, merge, and re-sort using the new row numbers */
		proc sort data=_covmat1; /* Segment 1 */
		  by _rep Parameter;
		run;
		proc sort data=_covmat12;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat1;
		  by _rep Parameter;
		run;
		data _covmat1;
		  merge _covmat1 _covmat12 _tcmat1;
		  by _rep Parameter;
		run;
		proc sort data=_covmat1;
		  by _rep nRow;
		run;
		proc sort data=_covmat2; /* Segment 2 */
		  by _rep Parameter;
		run;
		proc sort data=_covmat21;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat2;
		  by _rep Parameter;
		run;
		data _covmat2;
		  merge _covmat21 _covmat2 _tcmat2;
		  by _rep Parameter;
		run;
		proc sort data=_covmat2;
		  by _rep nRow;
		run;

		/* eMKF: set into single square block matrix */
		data _covmat;
		  set _covmat1 _covmat2;
		run;
		/* eMKF v2.4 correction: sort by _rep and nRow */
		proc sort data=_covmat;
		  by _rep nRow;
		run;

		/* eMKF: rectangular block matrix of covariances between regression coefficients and remaining parameters */
		data _covmatt;
		  retain _rep Row Parameter &s1colList &s2colList;;
		  set &out._covmat(where=(not(substr(Parameter, 1, 2) in ('s1','s2'))) keep= _rep Row Parameter &s1colList &s2colList);;
		run;

		/* eMKF 2.3: apply reverse-transformation to both square and rectangular block matrices, splitting up segments 1 and 2 for matrix operation purposes */
		%let i = 0; %let jj = 0;
		proc iml;

			/* eMKF 2.3: segment 1 */
			use _oPmat_;
			read all into s1oP; close _oPmat_;
			s1oP = s1oP[1:&s1p, 1:&s1p];
			s1oPP = &s1oPPmat;;

			/* eMKF 2.3: segment 2 */
			use _oPmat_;
			read all into s2oP; close _oPmat_;
			s2oP = s2oP[(1+&s1d):(&s1d+&s2p), (1+&s1d):(&s1d+&s2p)];
			s2oPP = &s2oPPmat;;

			/* eMKF 2.3: re-structure segment 1's block matrix in the common trend cases (where &s1p > 1) */
			%if %upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
				s1oPP1 = s1oPP[do(1, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)];
				s1oPP2 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(2, &g*&s1p, &s1p)]);
				s1ToPP2 = vecdiag(s1oPP[do(2, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
				s1oPP1 = s1oPP1 // T(s1ToPP2);
				s1oPP0 = s1oPP2;
				%if &s1p > 2 %then %do;
					s1oPP3 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(3, &g*&s1p, &s1p)]);
					s1ToPP3 = vecdiag(s1oPP[do(3, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
					s1oPP1 = s1oPP1 // T(s1ToPP3);
					s1oPP0 = s1oPP0 || s1oPP3;
				%end;
				%if &s1p > 3 %then %do;
					s1oPP4 = vecdiag(s1oPP[do(1, &g*&s1p, &s1p), do(4, &g*&s1p, &s1p)]);
					s1ToPP4 = vecdiag(s1oPP[do(4, &g*&s1p, &s1p), do(1, &g*&s1p, &s1p)]);
					s1oPP1 = s1oPP1 // T(s1ToPP4);
					s1oPP0 = s1oPP0 || s1oPP4;
				%end;
				s1oPP0 = s1oPP0 // s1oPP[2:&s1p, 2:&s1p];
				s1oPP = s1oPP1 || s1oPP0;
			%end;

			/* eMKF 2.3: re-structure segment 2's block matrix in the common trend cases (where &s2p > 1) */
			%if %upcase(&bvalue2) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
				s2oPP1 = s2oPP[do(1, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)];
				s2oPP2 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(2, &g*&s2p, &s2p)]);
				s2ToPP2 = vecdiag(s2oPP[do(2, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
				s2oPP1 = s2oPP1 // T(s2ToPP2);
				s2oPP0 = s2oPP2;
				%if &s2p > 2 %then %do;
					s2oPP3 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(3, &g*&s2p, &s2p)]);
					s2ToPP3 = vecdiag(s2oPP[do(3, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
					s2oPP1 = s2oPP1 // T(s2ToPP3);
					s2oPP0 = s2oPP0 || s2oPP3;
				%end;
				%if &s2p > 3 %then %do;
					s2oPP4 = vecdiag(s2oPP[do(1, &g*&s2p, &s2p), do(4, &g*&s2p, &s2p)]);
					s2ToPP4 = vecdiag(s2oPP[do(4, &g*&s2p, &s2p), do(1, &g*&s2p, &s2p)]);
					s2oPP1 = s2oPP1 // T(s2ToPP4);
					s2oPP0 = s2oPP0 || s2oPP4;
				%end;
				s2oPP0 = s2oPP0 // s2oPP[2:&s2p, 2:&s2p];
				s2oPP = s2oPP1 || s2oPP0;
			%end;

			/* eMKF v2.4: variable names for segment 1 */
			varNames1 = {"_rep" "Row"};
			%do i=1 %to &g;
				varNames1 = varNames1 || {"s1ag&i"};
				%if %upcase(&bvalue1) = INDEP_LINEAR %then varNames1 = varNames1 || {"s1b1g&i"};;
				%if %upcase(&bvalue1) = INDEP_QUAD   %then varNames1 = varNames1 || {"s1b1g&i"} || {"s1b2g&i"};;
				%if %upcase(&bvalue1) = INDEP_CUBIC  %then varNames1 = varNames1 || {"s1b1g&i"} || {"s1b2g&i"} || {"s1b3g&i"};;
			%end;
			%if %upcase(&bvalue1) = COMMON_LINEAR %then varNames1 = varNames1 || {"s1b1"};;
			%if %upcase(&bvalue1) = COMMON_QUAD   %then varNames1 = varNames1 || {"s1b1" "s1b2"};;
			%if %upcase(&bvalue1) = COMMON_CUBIC  %then varNames1 = varNames1 || {"s1b1" "s1b2" "s1b3"};;

			/* eMKF v2.4: variable names for segment 2 */
			varNames2 = {"_rep" "Row"};
			%do i=1 %to &g;
				varNames2 = varNames2 || {"s2ag&i"};
				%if %upcase(&bvalue2) = INDEP_LINEAR %then varNames2 = varNames2 || {"s2b1g&i"};;
				%if %upcase(&bvalue2) = INDEP_QUAD   %then varNames2 = varNames2 || {"s2b1g&i"} || {"s2b2g&i"};;
				%if %upcase(&bvalue2) = INDEP_CUBIC  %then varNames2 = varNames2 || {"s2b1g&i"} || {"s2b2g&i"} || {"s2b3g&i"};;
			%end;
			%if %upcase(&bvalue2) = COMMON_LINEAR %then varNames2 = varNames2 || {"s2b1"};;
			%if %upcase(&bvalue2) = COMMON_QUAD   %then varNames2 = varNames2 || {"s2b1" "s2b2"};;
			%if %upcase(&bvalue2) = COMMON_CUBIC  %then varNames2 = varNames2 || {"s2b1" "s2b2" "s2b3"};;

			/* eMKF v2.4: combined variable names */
			varNames = varNames1 || varNames2[, 3:ncol(varNames2)];

			/* eMKF v2.4: apply orthogonal transformation separately for each segment then combine */
			create _tcovmat var varNames;
			%do jj=1 %to &nrep;
				/* segment 1 */
				use _covmat(where=(_rep = &jj and substr(Parameter, 1, 2) = 's1') keep= _rep Row Parameter &s1colList );;
				read all into s1oB; close _covmat; 	/* eMKF v2.4 note: nonnumeric Parameter column automatically dropped here */
				s1oB1 = s1oB[,1:2];
				s1oB = s1oB[,3:ncol(s1oB)]; 
	            s1oBB = s1oPP * s1oB * T(s1oPP);
				/* segment 2 */
				use _covmat(where=(_rep = &jj and substr(Parameter, 1, 2) = 's2') keep= _rep Row Parameter &s2colList );;
				read all into s2oB; close _covmat;
				s2oB1 = s2oB[,1:2];
				s2oB = s2oB[,3:ncol(s2oB)];
	            s2oBB = s2oPP * s2oB * T(s2oPP);
				/* combine as a block matrix and append to _tcovmat */
				oBB = block(s1oBB, s2oBB);
				oB1 = s1oB1 // s2oB1;
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _tcovmat;

			create _tcovmatt var varNames;
			%do jj=1 %to &nrep;
				/* segment 1 */
				use _covmatt(where=(_rep = &jj) keep= _rep Row &s1colList);;
				read all into s1oB; close _covmatt;
				s1oB1 = s1oB[,1:2];
				s1oB = s1oB[,3:ncol(s1oB)];
				s1oBB = s1oPP * T(s1oB);
				/* segment 2 */
				use _covmatt(where=(_rep = &jj) keep= _rep Row &s2colList);; 
				read all into s2oB; close _covmatt;
				s2oB = s2oB[,3:ncol(s2oB)];
				s2oBB = s2oPP * T(s2oB);
				/* combine and append to _tcovmatt */
				oBB = s1oB1 || T(s1oBB) || T(s2oBB);
				append from oBB;
			%end;
			close _tcovmatt;

		quit;

		/* eMKF: combine both square and rectangular block matrices */
	    data _tcovmat;
		  set _tcovmat _tcovmatt;
		run;
		/* eMKF: re-sort rows */
		proc sort data=_tcovmat;
	  		by _rep Row ;
		run;

		/* eMKF v2.4: re-order columns as they were initially segmented from NLMIXED */
		data _tcovmat2;
	  	  retain  _rep Row 
				  s1ag1-s1ag&g 
				  %if %upcase(&bvalue1) = INDEP_LINEAR  %then s1b1g1-s1b1g&g ; 
				  %if %upcase(&bvalue1) = INDEP_QUAD    %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g ; 
				  %if %upcase(&bvalue1) = INDEP_CUBIC   %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g ; 
				  %if %upcase(&bvalue1) = COMMON_LINEAR %then s1b1 ; 
				  %if %upcase(&bvalue1) = COMMON_QUAD   %then s1b1 s1b2 ; 
				  %if %upcase(&bvalue1) = COMMON_CUBIC  %then s1b1 s1b2 s1b3 ; 
				  s2ag1-s2ag&g 
				  %if %upcase(&bvalue2) = INDEP_LINEAR  %then s2b1g1-s2b1g&g ; 
				  %if %upcase(&bvalue2) = INDEP_QUAD    %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g ; 
				  %if %upcase(&bvalue2) = INDEP_CUBIC   %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g ; 
				  %if %upcase(&bvalue2) = COMMON_LINEAR %then s2b1 ; 
				  %if %upcase(&bvalue2) = COMMON_QUAD   %then s2b1 s2b2 ; 
				  %if %upcase(&bvalue2) = COMMON_CUBIC  %then s2b1 s2b2 s2b3 ; 
		  ;
		  set _tcovmat; 
		run;
		data _tcovmatt2;
	  	  retain  _rep Row 
				  s1ag1-s1ag&g 
				  %if %upcase(&bvalue1) = INDEP_LINEAR  %then s1b1g1-s1b1g&g ; 
				  %if %upcase(&bvalue1) = INDEP_QUAD    %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g ; 
				  %if %upcase(&bvalue1) = INDEP_CUBIC   %then s1b1g1-s1b1g&g s1b2g1-s1b2g&g s1b3g1-s1b3g&g ; 
				  %if %upcase(&bvalue1) = COMMON_LINEAR %then s1b1 ; 
				  %if %upcase(&bvalue1) = COMMON_QUAD   %then s1b1 s1b2 ; 
				  %if %upcase(&bvalue1) = COMMON_CUBIC  %then s1b1 s1b2 s1b3 ; 
				  s2ag1-s2ag&g 
				  %if %upcase(&bvalue2) = INDEP_LINEAR  %then s2b1g1-s2b1g&g ; 
				  %if %upcase(&bvalue2) = INDEP_QUAD    %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g ; 
				  %if %upcase(&bvalue2) = INDEP_CUBIC   %then s2b1g1-s2b1g&g s2b2g1-s2b2g&g s2b3g1-s2b3g&g ; 
				  %if %upcase(&bvalue2) = COMMON_LINEAR %then s2b1 ; 
				  %if %upcase(&bvalue2) = COMMON_QUAD   %then s2b1 s2b2 ; 
				  %if %upcase(&bvalue2) = COMMON_CUBIC  %then s2b1 s2b2 s2b3 ; 
		  ;
		  set _tcovmatt; 
		run;
		
		/* eMKF: merge */
		data _tcovmatt2;
		  merge &out._covmat(where=(not(substr(Parameter, 1, 2) in ('s1','s2'))) keep = _rep Row Parameter) _tcovmatt2;
		  by _rep Row;
		run;

		/* eMKF: transpose _tcovmatt2 to add into larger matrix */
		proc transpose data=_tcovmatt2(drop=Row) out=_tcovmatt2 name = Parameter;
	      by _rep;
		  id Parameter;
	    run;

		/* eMKF: insert Row numbers */
		data _tcovmatt2;
		  set _tcovmatt2;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;

		/* eMKF: update covariance matrix dataset */
		data &out._covmat;
	  	  merge &out._covmat(keep = _rep Row Parameter) _tcovmat2 _tcovmatt2 
		  		&out._covmat(where=(not(substr(Parameter, 1, 2) in ('s1','s2'))) drop = s1: s2:) ;
		  by _rep Row;
		run;

		/* eMKF: extract variances of model parameters */
		%let jj = 0; 		
		proc iml;
			create _dcovmatt var{"_rep" "Row" "Var"};
			%do jj=1 %to &nrep;
				use &out._covmat(where=(_rep = &jj) drop= Parameter);
				read all into oB; close &out._covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = vecdiag(oB);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _dcovmatt;
		quit;
		data _dcovmatt;
		  merge _dcovmatt &out._covmat(keep = _rep Row Parameter);
		  by _rep Row;
		run;

	%end;

	/* eMKF v2.4: reverse-transformed regression estimates in long form for segment 1 */
	%if not(%upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
		data _s1lests;
		  set _tests(keep = _rep s1a rename=(s1a=Est))
			  %if &s1p > 1 %then _tests(keep = _rep s1b1 rename=(s1b1=Est));
			  %if &s1p > 2 %then _tests(keep = _rep s1b2 rename=(s1b2=Est));
			  %if &s1p > 3 %then _tests(keep = _rep s1b3 rename=(s1b3=Est));
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;
	%if %upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
		%let jj = 0; 		
		data _s1lests;
		  set _tests(keep = _rep s1a rename=(s1a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &s1p > 1 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s1b1 rename=(s1b1=Est));
			   	  %if &s1p > 2 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s1b2 rename=(s1b2=Est));
			  	  %if &s1p > 3 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s1b3 rename=(s1b3=Est));
			  %end;
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	/* eMKF v2.4: reverse-transformed regression estimates in long form for segment 2 */
	%if not(%upcase(&bvalue2) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
		data _s2lests;
		  set _tests(keep = _rep s2a rename=(s2a=Est))
			  %if &s2p > 1 %then _tests(keep = _rep s2b1 rename=(s2b1=Est));
			  %if &s2p > 2 %then _tests(keep = _rep s2b2 rename=(s2b2=Est));
			  %if &s2p > 3 %then _tests(keep = _rep s2b3 rename=(s2b3=Est));
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;
	%if %upcase(&bvalue2) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
		%let jj = 0; 		
		data _s2lests;
		  set _tests(keep = _rep s2a rename=(s2a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &s2p > 1 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s2b1 rename=(s2b1=Est));
			   	  %if &s2p > 2 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s2b2 rename=(s2b2=Est));
			  	  %if &s2p > 3 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep s2b3 rename=(s2b3=Est));
			  %end;
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	/* eMKF v2.4: continue numbering from segment 1 */
	data _s2lests;
	  set _s2lests;
	  %if not(%upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then Row = Row + &g*&s1p;;
	  %if %upcase(&bvalue1) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then Row = Row + &g + &s1k;;
	run;

	/* eMKF v2.4: combine the two segments and sort */
	data _lests;
	  set _s1lests _s2lests;
	run;
	proc sort data=_lests;
  		by _rep Row ;
	run;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;
		/* eMKF: merge reverse-transformed estimates and variances into fitstat dataset and update */
		data _tfits;
		  merge &out._fitstat _dcovmatt;
		  by _rep ;
		run;
	%end;
	%if %upcase(&nlmixedDetails) ^= YES %then %do;
		data _tfits;
		  set &out._fitstat;
		  by _rep;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

    data _tfits;
	  merge _tfits _lests;
	  by _rep Row;
	run;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	data _tfits;
	  set _tfits;
	  if Est ne . then Estimate = Est;
	  %if %upcase(&nlmixedDetails) = YES %then %do;
		  if Var > 0 then StandardError = sqrt(Var);
		  else StandardError = .;
		  tValue = Estimate/StandardError;
		  Probt = (1-probt(abs(tValue), DF))*2;
		  Lower = Estimate + tinv(Alpha/2, DF)*StandardError;
		  Upper = Estimate + tinv(1-Alpha/2, DF)*StandardError;
	  %end;
	  drop Row Est %if %upcase(&nlmixedDetails) = YES %then Var;;
	run;
	data &out._fitstat;
	  set _tfits;
	run;

%end;

/* eMKF: Add labels for stratification variable */
%if &by ^=%str() %then %do;
	data &out._ests;
 	  merge &out._ests _freq_;
 	  by _rep;
	run;
%end;

data &out._ests; /* eMKF: Added parameter estimates for quadratic and cubic terms */
   set &out._ests;
   label _2loglike =" -2 log-likelihood estimate"
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 /* eMKF: Added labels for by variable */
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
	     /* eMKF v2.4: segmented labels for regression coefficients */
	     s1a="Parameter estimate for segment 1: intercept (s1a)"
		 %if &s1p > 1 %then s1b1="Parameter estimate for segment 1: linear term (s1b1)" ;
   		 %if &s1p > 2 %then s1b2="Parameter estimate for segment 1: quadratic term (s1b2)" ;
   		 %if &s1p > 3 %then s1b3="Parameter estimate for segment 1: cubic term (s1b3)" ;
	     s2a="Parameter estimate for segment 2: intercept (s2a)"
		 %if &s2p > 1 %then s2b1="Parameter estimate for segment 2: linear term (s2b1)" ;
   		 %if &s2p > 2 %then s2b2="Parameter estimate for segment 2: quadratic term (s2b2)" ;
   		 %if &s2p > 3 %then s2b3="Parameter estimate for segment 2: cubic term (s2b3)" ;
	;
	drop &group %if &by ^= %str() %then &by; 
    ;
run;

data &out._pred; /* eMKF: added a few useful labels */
   set &out._pred(rename=(Predvar=PredOnlyVar HatMSE=PredMSE));
   PredSE= sqrt(PredMSE);
   label _2loglike =" -2 log-likelihood estimate"
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
		 &rlag = "Elapsed real time from previous time point"
		 &rtm ="Real time used in calculations "
	     _time ="Time index variable"
	     _y  ="Original outcome"
	     _se ="Original Standard Error"
		 _avgse = "Average Standard Error across timepoints used for imputation"
		 %if &by ^= %str() %then  _avgseb = "Average Standard Error across strata used for imputation";
         impute = "Whether original Standard Error was imputed using average across timepoints"
		 %if &by ^= %str() %then imputeb = "Whether original Standard Error was imputed using average across strata";
		 inputorder = "Original ordering of the groups if it was not alphabetical"
	     prediction="Kalman estimator prediction of the outcome assuming &bvalue1 trend model for segment 1 and &bvalue2 trend model for segment 2"
	     PredMSE="Prediction variability: Mean Squared Error (MSE) assuming &bvalue1 trend model for segment 1 and &bvalue2 trend model for segment 2 "
	     PredSE="Prediction standard error: Square root of MSE assuming &bvalue1 trend model for segment 1 and &bvalue2 trend model for segment 2 "
	     /* eMKF v2.4: segmented labels for regression coefficients */
		 s1a="Parameter estimate for segment 1: intercept (s1a)"
   		 %if &s1p > 1 %then s1b1="Parameter estimate for segment 1: linear term (s1b1) assuming &bvalue1 trend model " ;
   		 %if &s1p > 2 %then s1b2="Parameter estimate for segment 1: quadratic term (s1b2) assuming &bvalue1 trend model " ;
   		 %if &s1p > 3 %then s1b3="Parameter estimate for segment 1: cubic term (s1b3) assuming &bvalue1 trend model " ;
		 s2a="Parameter estimate for segment 2: intercept (s2a)"
   		 %if &s2p > 1 %then s2b1="Parameter estimate for segment 2: linear term (s2b1) assuming &bvalue2 trend model " ;
   		 %if &s2p > 2 %then s2b2="Parameter estimate for segment 2: quadratic term (s2b2) assuming &bvalue2 trend model " ;
   		 %if &s2p > 3 %then s2b3="Parameter estimate for segment 2: cubic term (s2b3) assuming &bvalue2 trend model " ;
	;
	/* These will be deleted for now. If needed they can be useful. */
   drop mu err delta lambda w gamma Hat_y PredOnlyVar &group group_rep &rlag %if &by ^= %str() %then &by; ; 
run;

/* eMKF: Rename any remaining instances of numeric &group variable to _group_ + remove numeric &by variable */
data &out._predVar;
  set &out._predVar;
  rename &group = _group_;
  %if &by ^= %str() %then drop &by;;
run;
/* eMKF v2.4 streamlining: added option to omit covariance matrices and model diagnostics */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._covY;
	  set &out._covY;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
%end;

proc datasets nolist;
 delete _freqn_ _freqs1n_ _freqs2n_ _freqg_ _freq_ _sdata_ _beta_ _inits_ _initsr_ _ests _fitstat _convstat _llike_ _empty_ _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_ _Xmat_ 
        _junk_ _junk0_ _junk01_ _oXmat_ _oPmat_ _tests _lests _s1lests _s2lests _tfits _tcmat _tcmat1 _tcmat2 _covmat1 _covmat2 _covmat12 _covmat21 
        _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt
		%if %upcase(&nlmixedDetails) ^= YES %then &out._H &out._covY &out._covmat &out._fitstat ;
		&out._predVar
        ;
run ;
quit;

%mend htrpxptf;

data _null_;
run;


/*HTRPxptl macro
Version of HTRP macro for eMKF v2.4 to allow intercept-only (level) shift in trend.

data 	: name of the dataset.
outcome : outcome of interest. 
se      : standard error of the outcome. 
time    : time variable.
xpt		: value of timepoint at which trend break occurs.
by      : allows models to run for multiple strata at the same time and can be used for simulations
xtrakeep: Any variable one wants to keep in the data while runing models: weights, ... (eMKF: could be used to retain labels for multiyear data)
orpoly  : (eMKF) YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          If YES, regression coefficients and their SEs will be reverse-transformed prior to macro end.
bvalue  : Assumptions about the trend model. eMKF options are the following:
             indep_cubic	: The values of the parameters b1, b2, and b3 are computed for each group
             indep_quad		: b3=0. The values of the parameters b1 and b2 are computed for each group
             indep_linear   : (DEFAULT) b3=0 and b2=0. The value of the slope b1 is computed for each group
             common_cubic	: The values of each of the parameters b1, b2, and b3 are assumed to be the same across groups
             common_quad	: b3=0. The values of each of the parameters b1 and b2 are assumed to be the same across groups
             common_linear  : b3=0 and b2=0. The value of the slope b1 is assumed to be the same across groups
             dropped    	: A model without time trend is computed
ARvalue	: [New in eMKF v2.4] Assumption about the AR model. Options are:
			common_ar (default)	: AR parameters are common across groups; 
		    common_arh			: AR correlation is common but innovation variance parameters are group-specific.
			indep_ar			: Both AR(1) parameters are group-specific. 
group   : the different groups (e.g., race/ethnicity groups) variable
nlmixedDF: Non-linear model degrees of freedom. The default is set pretty high at 10000
nlmixedDetails: (eMKF v2.4 streamlining)(default = NO) option to omit covariance matrix of parameters and other model information.
nlmixedTech:	(eMFK v2.4 streamlining) (default = NEWRAP) added to give user more control over choice of optimization algorithm
print   : Yes will print the nlmixed results and No will not. Default is No
out     : The name of the output baseline. All the following outputs (baseline + suffix) are saved. 
          Here are the suffixes:
          	_fitstat : model fit estimates from the proc nlmixed
          	_ests    : model fit estimates formated for use in the estimation of the Kalman prediction
          	_covmat  : model fit covariance matrix
          	_pred    : Kalman prediction of the outcome of interest includes original values as well as parameters
         (e.g., for OUT=result then RESULT_PRED will be the Kalman prediction data of the outcome of interest. )
*/
%macro htrpxptl(data=, 
               outcome=, 
               se=,
               group=,
               time=,
			   xpt=,
               by=, 
               xtrakeep= ,
			   orpoly=YES,
               bvalue= indep_linear , 
			   ARvalue= common_ar,
               nlmixedDF=10000, 
			   nlmixedDetails=NO,
			   nlmixedTech=NEWRAP,
               out=param, 
               print=NO
               ) / minoperator;

%local formatted dsop dscl g n s1n s2n _rtimess rtm s1rtm s2rtm rlag nrep p k d tline jj tauline rholine
 		b1line b2line b3line i j nlmerr _emkfmu_ _s1emkfmu_ _s2emkfmu_ group_rep lj amat oPPmat colList ;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&data));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &time)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _sdata_;
run;

%if &formatted = 1 %then %do;
	/* eMKF v2.4 note: recall that _groupnum and _reps are created before HTRP is called from parent MKF macro */
	data _sdata_;
	  set &data;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to MLE-based estimation;
	%reformatXPT(data=&data, outcome=&outcome, se=&se, group=&group, time=&time, xpt=&xpt, by=&by, outformat= _sdata_);
	/* eMKF: Create copies of _group_ and _rep variables for use in proc iml matrix calculations */
	data _sdata_; 
	  set _sdata_;
	  _groupnum = _group_; 					 
	  %if &by ^= %str() %then _reps = _rep;;
	run;
	/* eMKF: Replace &group and &by macro variables by their numeric versions */
	%let group = _groupnum; 				
	%if &by ^= %str() %then %let by = _reps;;
%end;

/* eMKF: Sort by replications (if any), group, and time */
/* eMKF: Use _time as &time could be empty if data was still in format 1 when htrp was called */
proc sort data= _sdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _freqg_;
run;
proc freq data=_sdata_ noprint;
  tables &group /list out=_freqg_;
run;
data _freqg_;
  set _freqg_;
  _group_ +1;
  call symput('g',_group_);
  keep _group_ &group;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the total number of time points */
%let n=0;
data _freqn_;
run;
proc freq data=_sdata_ noprint;
  tables _rtime /list out=_freqn_;
run;
data _freqn_;
  set _freqn_;
  _time +1;
  call symput('n',_time);
  keep _time _rtime;
run;
%let n=%eval(0+&n);

/* eMKF v2.4: Macro variable for the number of time points in segment 1*/
%let s1n=0;
data _freqs1n_;
run;
proc freq data=_sdata_ noprint;
  tables _s1rtime /list out=_freqs1n_;
run;
data _freqs1n_;
  set _freqs1n_(where=(_s1rtime ne 0));
  _s1time + 1;
  call symput('s1n',_s1time);
  keep _s1time _s1rtime;
run;
%let s1n=%eval(0+&s1n);

/* eMKF v2.4: Macro variable for the number of time points in segment 2*/
%let s2n=0;
data _freqs2n_;
run;
proc freq data=_sdata_ noprint;
  tables _s2rtime /list out=_freqs2n_;
run;
data _freqs2n_;
  set _freqs2n_(where=(_s2rtime ne 0));
  _s2time + 1;
  call symput('s2n',_s2time);
  keep _s2time _s2rtime;
run;
%let s2n=%eval(0+&s2n);

/* eMKF v2.4: continued numbering from segment 1 */
data _freqs2n_;
  set _freqs2n_;
  _s2time = _s2time + &s1n;
run;

/* eMKF: Macro variable for the real times to use in calculations */
%let _rtimess = ;
data _freqn_;
  set _freqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_rtimess', _rts);
  drop _rts;
run;

/* eMKF allows for irregular and fractional times points */
/* eMKF v2.4: These are the variables that will be used for real time in case they are not just 1,2,3,... */
%let rtm=_rtime; %let s1rtm=_s1rtime;  %let s2rtm=_s2rtime;

/* eMKF: macro reformat now also tracks lags between successive real time points */		
%let rlag=_rlag;

/* eMKF: Macro variable for the number of replications */
%let nrep=1;
%if &by ^=%str() %then %do;
	data _freq_;
	run;
	proc freq data=_sdata_ noprint;
	  tables &by /list out=_freq_;
	  format &by ;
	run;
	data _freq_;
	  set _freq_;
	  _rep +1;
	  call symput('nrep',_rep);
	  keep _rep &by;
	run;
%end;
%let nrep=%eval(0+&nrep);

/* eMKF v2.4: Error check to make sure both segments 1 and 2 contain at least 2 timepoints */
%if (&s1n < 2) or (&s2n < 2) %then %do;
	%put ERROR: Specified break point either was not found or resulted in less than 2 timepoints per segment. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p = 0; 
%if %upcase(&bvalue) in INDEP_CUBIC COMMON_CUBIC %then %let p = 5;
%if %upcase(&bvalue) in INDEP_QUAD COMMON_QUAD %then %let p = 4;
%if %upcase(&bvalue) in INDEP_LINEAR COMMON_LINEAR %then %let p = 3;
%if %upcase(&bvalue) = DROPPED %then %let p = 2;
%let k = %eval(&p - 2); 

/* eMKF v2.4: max polynomial rank to use in orpoly is d-1 */
%let d = 0;
%if &s1n > 4 or &s2n > 4 %then %let d = 4; /* cubic allowed with 5+ timepoints in either segments 1 or 2 */
%else %do;
	%if &s1n > 3 or &s2n > 3 %then %let d = 3; /* quad allowed with 4+ timepoints in either segments 1 or 2 */
	%else %do;
		%if &s1n > 2 or &s2n > 2 %then %let d = 2; /* linear allowed with 3+ timepoints in either segments 1 or 2 */
		%else %let d = 1;     /* intercepts-only model is allowed with just 2 timepoints in both segments 1 and 2 */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4: Error check to make sure requested trend model can be fit */
%if (&p > &d+1) %then %do;
	%put ERROR: Specified trend model cannot be fit. Please review!;
	%put ERROR- &bvalue was requested: there are only enough data for a degree %eval(&d-1) polynomial.;; 
  	%return;
%end;

/* eMKF v2.4: Modification to set up orthogonal cubic polynomial design matrix blocked into two segments */

data _oXmat_ _oPmat_;
run;

%if %upcase(&orpoly) = YES %then %do;
	proc iml;
	  s1x0 = { %cnstss(1, &s1n) %cnstss(0, &s2n)};
	  s1x0 = T(s1x0);										/* eMKF v2.4: Intercepts for segment 1 */
	  s2x0 = { %cnstss(0, &s1n) %cnstss(1, &s2n)}; 
	  s2x0 = T(s2x0);										/* eMKF v2.4: Intercepts for segment 2 */
	  x = { &_rtimess };	
	  x = T(x);												/* eMKF: column vector with real times */
	  %if &d = 1 %then oP0 = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP0 = orpol(x, &d-1);;				/* eMKF v2.4: orthonormal design matrix oP */
	  oP = (oP0[,1]#s1x0) || (oP0[,1]#s2x0);
	  %if &s1n > 2 or &s2n > 2 %then oP = oP || oP0[,2];;
	  %if &s1n > 3 or &s2n > 3 %then oP = oP || oP0[,3];;
	  %if &s1n > 4 or &s2n > 4 %then oP = oP || oP0[,4];;
	  %if &s1n > 2 or &s2n > 2 %then x1 = x;;
	  %if &s1n > 3 or &s2n > 3 %then x2 = x#x1;;
	  %if &s1n > 4 or &s2n > 4 %then x3 = x#x2;;
	  uP = s1x0 || s2x0;									/* eMKF v2.4: raw/unstandardized design matrix uP */
	  %if &s1n > 2 or &s2n > 2 %then uP = uP || x1;;
	  %if &s1n > 3 or &s2n > 3 %then uP = uP || x2;;
	  %if &s1n > 4 or &s2n > 4 %then uP = uP || x3;;
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
	  oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];
      %if &s1n > 2 or &s2n > 2 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &s1n > 3 or &s2n > 3 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
      %if &s1n > 4 or &s2n > 4 %then oP5 = inv(T(uP)*uP)*T(uP)*oP[,5];;
	  oPP = oP1 || oP2;										/* eMKF: right multiplication of uP with oPP produces oP */
	  %if &s1n > 2 or &s2n > 2 %then oPP = oPP || oP3;;
	  %if &s1n > 3 or &s2n > 3 %then oPP = oPP || oP4;;
	  %if &s1n > 4 or &s2n > 4 %then oPP = oPP || oP5;;
	  y = T(do(1, &n, 1));									/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&rtm.1" "&rtm.2" "&rtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&rtm.1" "&rtm.2" } ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0" "&rtm.1" } ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&s1rtm.0" "&s2rtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"s1t0" "s2t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_sdata_;
	  by _time;
	run;
	data _sdata_;
	   merge _sdata_ _oXmat_;
	   by _time;
	run;
	proc sort data= _sdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _sdata_;
	   set _sdata_; 										/* eMKF v2.4: add raw quad and cubic time terms as columns in _sdata_ */
	   if &s1rtm > 0 then &s1rtm.0 = 1; else &s1rtm.0 = 0;
	   if &s2rtm > 0 then &s2rtm.0 = 1; else &s2rtm.0 = 0;
	   %if &d > 1 %then &rtm.1 = &rtm;;
	   %if &d > 2 %then &rtm.2 = &rtm**2;;
	   %if &d > 3 %then &rtm.3 = &rtm**3;;
	run;
%end;

/* eMKF v2.4: Set up model statement symbolically for use in proc reg */
%let tline=;
%if &p = 5 %then %let tline = &s1rtm.0 &s2rtm.0 &rtm.1 &rtm.2 &rtm.3;
%if &p = 4 %then %let tline = &s1rtm.0 &s2rtm.0 &rtm.1 &rtm.2;
%if &p = 3 %then %let tline = &s1rtm.0 &s2rtm.0 &rtm.1;
%if &p = 2 %then %let tline = &s1rtm.0 &s2rtm.0;

/* eMKF v2.4: Modified call to proc reg to allow for additional intercept (expanded design matrix) */
proc reg data=_sdata_ outest=_beta_ noprint ;
   by _rep _group_;
   model _y = &tline /noint;;
run;

/* eMKF v2.4: Setup initial values for use in proc nlmixed */
/* eMKF v2.4 also allows for group-specific AR parameters */

/* eMKF: Sort regression coefficients by _rep and _group_ */
proc sort data=_beta_;
  by _rep _group_;
run;

/* eMKF v2.4: Initial parameter values for the first replication */
%let jj = 1;
data _inits_;
	set _beta_(where=(_rep = &jj)) end=end;
	_rep = &jj;
   	array s1ag s1ag1-s1ag&g;
   	array s2ag s2ag1-s2ag&g;
   	array b1g b1g1-b1g&g;
   	array b2g b2g1-b2g&g;
   	array b3g b3g1-b3g&g;
	%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
	%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
   	retain s1ag1-s1ag&g s2ag1-s2ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g  
		   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
		   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
    ;
	s1ag{_group_} = &s1rtm.0;
	s2ag{_group_} = &s2rtm.0;
    %if &p > 2 %then b1g{_group_} = &rtm.1 ;; 
   	%if &p > 3 %then b2g{_group_} = &rtm.2 ;;
   	%if &p > 4 %then b3g{_group_} = &rtm.3 ;;
	%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
	%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
   	if end then do;
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
      	output;
   	end;
   	keep _rep s1ag1-s1ag&g s2ag1-s2ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
		%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
		%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
	;
run;

/* eMKF v2.4: Initial estimates from each subsequent replication */
data _initsr_;
run;
%if &nrep > 1 %then %do; 	
	%do jj = 2 %to &nrep;
		data _initsr_;
			set _beta_(where=(_rep = &jj)) end=end;
			_rep = &jj;
		   	array s1ag s1ag1-s1ag&g;
		   	array s2ag s2ag1-s2ag&g;
		   	array b1g b1g1-b1g&g;
		   	array b2g b2g1-b2g&g;
		   	array b3g b3g1-b3g&g;
			%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
			%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
		   	retain s1ag1-s1ag&g s2ag1-s2ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g  
				   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
				   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
		    ;
			s1ag{_group_} = &s1rtm.0;
			s2ag{_group_} = &s2rtm.0;
		    %if &p > 2 %then b1g{_group_} = &rtm.1 ;; 
		   	%if &p > 3 %then b2g{_group_} = &rtm.2 ;;
		   	%if &p > 4 %then b3g{_group_} = &rtm.3 ;;
			%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
			%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
		   	if end then do;
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   				%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
		      	output;
		   	end;
		   	keep _rep s1ag1-s1ag&g s2ag1-s2ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
				%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
				%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
			;
		run;
		data _inits_;
		  set _inits_ _initsr_;
		run;
		data _initsr_;
		run;
	%end;
%end;
  
/* eMKF: calculate initial estimates for common_ scenarios and remove extraneous variables */
data _inits_; 
	set _inits_;
	b1=.;
	b2=.;
	b3=.;
    %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then b1 = mean(of b1g1-b1g&g) ;;
    %if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR) %then drop b1g1-b1g&g ;;
    %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD %then b2 = mean(of b2g1-b2g&g) ;;
	%if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD) %then drop b2g1-b2g&g ;;
 	%if %upcase(&bvalue) = COMMON_CUBIC %then b3 = mean(of b3g1-b3g&g) ;;
 	%if %upcase(&bvalue) ^= INDEP_CUBIC %then drop b3g1-b3g&g ;;
	%if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR) %then drop b1;;
    %if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD) %then drop b2;;
	%if %upcase(&bvalue) ^= COMMON_CUBIC %then drop b3;; 
run;

/* eMKF v2.4: re-order columns in common trend cases so the logitrho and logtau2 remain last */
%if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
	data _inits_;
	  merge _inits_(drop = logtau2: logitrho:) _inits_(keep=_rep logtau2: logitrho:);
	  by _rep;
	run;
%end;

/* eMKF v2.4: Set up array declarations for tau and rho parameters symbolically for use in proc nlmixed */
%let tauline=; %let rholine=;
%if %upcase(&ARvalue) ^= COMMON_AR %then %let tauline = array logtau2g(&g) logtau2g1-logtau2g&g%str(;) array _tausq_(&g) _tausq_1-_tausq_&g%str(;) ;
%if %upcase(&ARvalue) = INDEP_AR %then %let rholine= array logitrhog(&g) logitrhog1-logitrhog&g%str(;) array _rho_(&g) _rho_1-_rho_&g%str(;) ; 

/* eMKF: Set up array declarations symbolically for use in proc nlmixed */
%let b1line=; %let b2line=; %let b3line=;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %let b1line= array b1g(&g) b1g1-b1g&g ;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then %let b2line= array b2g(&g) b2g1-b2g&g ;
%if %upcase(&bvalue) = INDEP_CUBIC %then %let b3line= array b3g(&g) b3g1-b3g&g ;

/* eMKF v2.4: Set up model statement symbolically for use in proc nlmixed */
%let tline=;
%if %upcase(&bvalue)=INDEP_CUBIC %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1g[_group_]+&rtm.2*b2g[_group_]+&rtm.3*b3g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue)=INDEP_QUAD  %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1g[_group_]+&rtm.2*b2g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue)=INDEP_LINEAR %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue)=COMMON_CUBIC %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1+&rtm.2*b2+&rtm.3*b3+gamma[_time],_se**2);
%if %upcase(&bvalue)=COMMON_QUAD %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1+&rtm.2*b2+gamma[_time],_se**2);
%if %upcase(&bvalue)=COMMON_LINEAR %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+&rtm.1*b1+gamma[_time],_se**2);
%if %upcase(&bvalue)=DROPPED %then %let tline= normal(&s1rtm.0*s1ag[_group_]+&s2rtm.0*s2ag[_group_]+gamma[_time],_se**2);

/* Fit a Non-linear mixed model. Capture covariance matrix COV and covariance matrix from additional estimate ECOV */

data _ests _fitstat _convstat &out._fitstat &out._covmat;
run;

%put ;
%put Start model fitting using PROC NLMIXED;

/* eMKF: model print handling */
%if %upcase(&print) ^= YES %then ods exclude all;; 

/* eMKF v2.4: initialized counters for use in proc nlmixed */
%let i=0; %let j=0;

/* eMKF v2.4: Error check to make sure specified optimization method is valid */
%if not(%upcase(&nlmixedTech) in CONGRA DBLDOG NEWRAP NMSIMP NONE NRRIDG QUANEW TRUREG) %then %do;
	%put ERROR: proc nlmixed syntax error. Specified optimization algorithm &nlmixedTech not recognized. Please check!;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
/* eMKF v2.4 streamlining: omitted calculation of reverse-transformed rho and tausq (estimate statements) and ecov */ 
/* eMKF v2.4 now also allows for group-specific AR parameters (_rho_ and _tausq_ can no longer be user-supplied) */
proc nlmixed data=_sdata_ DF=&nlmixedDF %if %upcase(&nlmixedDetails) = YES %then cov; 
	tech=&nlmixedTech				 /* eMKF v2.4: can replace proc nlmixed default (QUANEW) optimization with other available methods (e.g., NEWRAP) */
	method=firo maxiter=500; 		 /* eMKF: updated method and maxiter to match those in htrp2d */
	by _rep; 						 /* eMKF: stratified by _rep (trivial if _rep is constant = 1 (i.e., no stratification) */
	array gamma(&n) gamma1-gamma&n ; /* Give the gamma values a generic name */
	array s1ag(&g) s1ag1-s1ag&g; 	 /* eMKF v2.4: Give the a values a generic name for segment 1 */
	array s2ag(&g) s2ag1-s2ag&g;	 /* eMKF v2.4: Give the a values a generic name for segment 2 */
	&b1line;; 						 /* Give the bl values a generic name */
	&b2line;; 						 /* eMKF: Give the b2 values a generic name */
	&b3line;; 						 /* eMKF: Give the b3 values a generic name */ 
	&tauline;;						 /* eMKF v2.4: group-specific innovation variances (if any) */
	&rholine;;						 /* eMKF v2.4: group-specific autocorrelation coefficients (if any) */
	%if %upcase(&ARvalue)^=COMMON_AR 
	  %then array nu(&g) nu1-nu&g;;  /* eMKF v2.4: group-specific stationary variances (if any) */
	parms / bydata data=_inits_; 	 /* eMKF: Setup parameters and their initial values stratified by _rep */

	%if %upcase(&ARvalue)=COMMON_AR %then %do; 
		bounds logitrho >= 0;		 /* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		_tausq_ = exp(logtau2);
		nu = _tausq_/(1-(_rho_**2));
	%end;
	%if %upcase(&ARvalue)=COMMON_ARH %then %do;
		bounds logitrho >= 0;		 /* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		%do j = 1 %to &g;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_**2));
		%end;
	%end;
	%if %upcase(&ARvalue)=INDEP_AR %then %do;
		bounds logitrhog1-logitrhog&g >= 0;	/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		%do j = 1 %to &g;
			_rho_&j = 2/(1+exp(-logitrhog&j)) - 1;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_&j**2));
		%end;
	%end;

	/* Random effects gamma1 gamma2 ... gamma&n ~ normal([0,0,..,0],[nu, half triangular matrix]) */
	/* eMFK: Replaced do loop for variances with call to macro thevarcompr to allow for noninteger/unequally-spaced time points */
	/* eMKF v2.4 allows for group-specific AR coefficients */
	%if %upcase(&ARvalue) = COMMON_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu, vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = COMMON_ARH %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = INDEP_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_[_group_])) subject=_group_;
	%end;

	model _y ~ &tline;;

	/* eMKF v2.4 streamlining: added output for convergence status */
	ods output parameterestimates=_ests fitstatistics=_fitstat convergencestatus=_convstat;
	%if %upcase(&nlmixedDetails) = YES %then ods output CovMatParmEst=&out._covmat;;
run;

/* eMKF v2.4: Error check to make sure proc nlmixed converged */
%let nlmerr = 0;
data _null_;
  set _convstat;
  if Status = 1 then call symput("nlmerr" , 1);
run;
%let nlmerr = %eval(0 + &nlmerr);
%if &nlmerr %then %do;
	%put ERROR: proc nlmixed returned an error. Try specifying an optimization algorithm other than &nlmixedTech.;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
%if %upcase(&nlmixedDetails) ^= YES %then %do;
	data _ests;
	  set _ests;
	  drop StandardError DF tValue Probt Alpha Lower Upper Gradient;
	run;
%end;

/* eMKF: Replace missing values in CovMatParmEst with 0s for later use */
%if %upcase(&nlmixedDetails) = YES and %upcase(&orpoly) = YES %then %do;
	data &out._covmat;
	  set &out._covmat;
	  array NAs _numeric_;
	  do over NAs;
	      if NAs = . then NAs = 0;
	  end;
	run;
%end;

/* eMKF: Reset ODS destinations if they were turned off */
%if %upcase(&print) ^= YES %then ods exclude none;;

/* eMKF: Added put statements for log */
%put ;
%put End model fitting using PROC NLMIXED;
%if %upcase(&print) ^= YES %then %put Model printout was turned off by user.;;

/* eMKF: Model estimates */
data _fitstat;
   set _fitstat;
   if descr = "-2 Log Likelihood";
   _2loglike=value;
   keep _2loglike _rep;
run;
data &out._fitstat;
  merge _ests _fitstat;
  by _rep;
run;
data _llike_;
run;
data _llike_;
  set &out._fitstat;
  by _rep;
  if first._rep then output;
  keep _rep _2loglike;
run;
data &out._ests;
run;
proc transpose data=&out._fitstat out=&out._ests;
   by _rep;
   var estimate;
   id parameter;
run;

/* eMKF v2.4 streamlining: _emkfmu_ tracks the mean; _emkfkeep_ is now defunct; p will be used to track which coefficients to keep */
%let _emkfmu_ = ;
%if &p = 5 %then %let _emkfmu_ = mu=s1a*&s1rtm.0+s2a*&s2rtm.0+b1*&rtm.1+b2*&rtm.2+b3*&rtm.3;;
%if &p = 4 %then %let _emkfmu_ = mu=s1a*&s1rtm.0+s2a*&s2rtm.0+b1*&rtm.1+b2*&rtm.2;;
%if &p = 3 %then %let _emkfmu_ = mu=s1a*&s1rtm.0+s2a*&s2rtm.0+b1*&rtm.1;;
%if &p = 2 %then %let _emkfmu_ = mu=s1a*&s1rtm.0+s2a*&s2rtm.0;;

/* eMKF v2.4: Re-structure estimates by _rep and _group_ */
data &out._ests;
   merge &out._ests _llike_;
   by _rep;
   array s1as s1ag1-s1ag&g;
   array s2as s2ag1-s2ag&g;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then array b1s b1g1-b1g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b1 = 0 ;;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then array b2s b2g1-b2g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b2 = 0 ;;
   %if %upcase(&bvalue) = INDEP_CUBIC %then array b3s b3g1-b3g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b3 = 0 ;;
   /* eMKF v2.4 allows for group-specific AR coefficients */
   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2s logtau2g1-logtau2g&g ;;
   %if %upcase(&ARvalue) = COMMON_AR %then _tausq_ = exp(logtau2) ;; 
   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhos logitrhog1-logitrhog&g ;;
   %if %upcase(&ARvalue) ^= INDEP_AR %then _rho_ = 2/(1+exp(-logitrho))-1 ;;
   do _group_ = 1 to &g;
      s1a = s1as{_group_};
      s2a = s2as{_group_};
      %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then b1 = b1s{_group_} ;;
	  %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then b2 = b2s{_group_} ;;
      %if %upcase(&bvalue) = INDEP_CUBIC %then b3 = b3s{_group_} ;;
	  %if %upcase(&ARvalue) ^= COMMON_AR %then _tausq_ = exp(logtau2s{_group_}) ;;
	  %if %upcase(&ARvalue) = INDEP_AR %then _rho_ = 2/(1+exp(-logitrhos{_group_}))-1 ;;
      output;
   end;
   keep _rep _group_ s1a s2a %if &p > 2 %then b1-b&k ; _tausq_ _rho_ _2loglike;
run;

/* eMKF v2.4 streamlining: reordered columns here and used &p (and &k = &p-1) instead of &_emkfkeep_ to track which coefficients to keep */
data &out._ests; 
  merge &out._ests(keep= _rep _group_ s1a s2a) %if &p > 2 %then &out._ests(keep= b1-b&k); 
		&out._ests(keep= _tausq_) &out._ests(keep= _rho_) &out._ests(keep= _2loglike);
run;

/* eMKF: Merge with group labels */
proc sort data= &out._ests;
  by _group_ ;
run;
proc sort data=_freqg_;
  by _group_;
run;
data &out._ests;
  merge &out._ests _freqg_;
  by _group_;
run;

/***************************************************************************/
/* Now let's use the Kalman technique to estimate the outcome observations */
/***************************************************************************/

data &out._pred;
run;
proc sort data=_sdata_ out=&out._pred;
  by _rep _group_ _time; 
run;

proc sort data=&out._ests;
  by _rep _group_;
run;

data &out._pred; 
  merge &out._pred &out._ests;
  by _rep _group_ ;
  &_emkfmu_;; 					/* eMKF: invoke symbolic calculation for mu */
  err=_y - mu;
run;

data _empty_;
  set &out._pred;
  if _time= 1;
  w0 = _tausq_/(1-(_rho_**2));
  gamma0 = 0 ;
  _time= 0;
  &rtm= 0;
  &rlag = .;
  keep _time &rtm  /* eMKF v2.4: modified to keep segment-specific intercepts */
		&s1rtm.0 &s2rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3;
		&rlag &by _rep &group _group_ w0 gamma0; 
run;

data &out._pred;
 set &out._pred _empty_;
 if _time = 1 then &rlag = 1;	/* eMKF: set to lag 1 instead of missing relative to time 0 */
run;

proc sort data=&out._pred;
 by _rep _group_ _time;
run;

/* eMKF: recursion formulas modified to allow lag s > 0 between time points */
data &out._pred;
  set &out._pred;
  retain wold gamold;
  delta = ((_rho_**(2*&rlag)) * wold) + _tausq_*(1 - (_rho_**(2*&rlag)))/(1 - (_rho_**2));
  if &rlag > 0 or &rlag = . then lambda = delta/(delta + (_se**2));
  else lambda = 0; 				/* eMKF: in the limiting case, recursion breaks down: set lambda = 0 instead */
  w = delta * (1-lambda);
  gamma = (lambda* err) + (1-lambda)*(_rho_**&rlag)*gamold ; /* eMKF: &rlag=1 reduces to unit-increment case */
  prediction = mu + gamma ;
  output;
  if _time = 0 then do;
	wold=w0;
	gamold=gamma0;
  end;  
  if _time ^= 0 then do; 
	wold=w;
    gamold=gamma;
  end;
run;

/* eMKF v2.4 correction: added hyphen separator between _rep and _group_ to cover cases with more than 10 reps or groups (e.g., 1-11 vs 11-1) */
%let group_rep = compress(_rep ||"-"|| _group_);

data &out._pred;
  set &out._pred;
  group_rep= &group_rep;
  if _time ne 0;
  drop w0 gamma0 wold gamold;
run;

/* eMKF: reset lag for time 1 to missing */
data &out._pred;
  set &out._pred;
  if _time = 1 then &rlag = .; 
run;

/******************/
/* Compute the MSE*/
/******************/

data _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_  _Xmat_ _junk_ _junk0_ _junk01_;
run;

proc sort data=&out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4: modified to keep segment-specific intercepts */
								&s1rtm.0 &s2rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3;
								&rlag _y _se _rho_ _tausq_ err lambda prediction group_rep)
  out=_Amat_ ;
  by group_rep;
run;

data _Amat_;
  set _Amat_; 
  by group_rep;
  array hs ah1-ah&n (%zeross(&n));
  if first.group_rep then do _k=1 to &n; hs{_k}=0; end;
  if _time = 1 then ah1=lambda;
  else do;
  	 /* eMKF: updated to account for &rlag if not 1 */
     do _j=1 to _time - 1;
	    hs{_j} = hs{_j}*(1-lambda)*(_rho_**&rlag) ; 
	 end;
	 hs{_time}=lambda;
  end;
  
  drop group_rep _k _j;
  keep _rep &by _group_ &group _time &rtm &rlag ah:;
run;

proc sort data=_Amat_;
  by _rep _group_ _time  ;
run;

/* Attach row number _id to each of the A Matrix so that when computing group by group the appropriate Ag could be called*/
data _Amat_;
  set _Amat_;
  _id+1;
run;

data _Dmat_;
  set &out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4: modified to keep segment-specific intercepts */
						&s1rtm.0 &s2rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
						&rlag _y _rho_ _tausq_ _se);
  w0 = _tausq_/(1- (_rho_**2));
run;

/* The Matrix _Dmat_ is actually the same within group and within replication*/
proc sort data= _Dmat_ nodupkey;
  by _rep _group_ _time;
run;

/* Here the standard error is the same from one replication to another by different from group to group. 
   So these matrices should just be estimated differently for each group as well as replication if possible */
data _Vmat_; 
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 			 /* eMKF: modification to deal with irregular time points */
  do i=1 to &n; 
  	 if i = _time  then ad{i} = w0 + _se**2; /* Add the variances of Y to the diagonal elements */
   	 else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* Recreate the variance where only the Variance of gamma is estimated
 This is mostly needed for check of what the estimates are giving us. */
data _Vgmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is the diagonal Variance matrix of the errors */
data _Vemat_;
  set _Dmat_;
  array ad ad1-ad&n;
  do i=1 to &n;
    if i = _time then ad{i}= _se**2;
    else ad{i} = 0;
  end;
  drop i;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is just like the _Vgmat_ but with extra variables kept to be used later for the creation of the X matrix for example*/
data _Dmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
run;

/* This is the X matrix */
data _Xmat_;
  set _Dmat_;
  /* eMKF v2.4: modification to include two sets of intercepts */
  s1x0 = &s1rtm.0; 
  s2x0 = &s2rtm.0; 
  %if &d > 1 %then x1 = &rtm.1;;
  %if &d > 2 %then x2 = &rtm.2;;
  %if &d > 3 %then x3 = &rtm.3;;
  keep _rep &by _group_ &group 
	   s1x0 s2x0 %if &d > 1 %then x1; %if &d > 2 %then x2; %if &d > 3 %then x3;
  ;
run;

data &out._H &out._PredVar &out._CovY;
run;

/*******************************************************************************************************************************/
/* eMKF v2.4 streamlining: Removed portion of code that pertained to symbolic matrix operations redundant with use of proc iml */
/*                         Those symbolic operations were stored in unused macro variables iis, vmatinv, vmat, xmat, and blmat  */
/*******************************************************************************************************************************/

/* Now let's capture the A Matrix and turn it into a diagonal block matrix  */

data _junk_;
  set _Amat_;
  by _rep;
  if first._rep then sid=0;
  sid+1;
  repgrp=&group_rep; /* eMKF v2.4 streamlining: repgrp assigned value of macro variable &group_rep */
run;

proc sort data=_junk_;
  by repgrp sid;
run;

data _junk_;
  set _junk_;
  by repgrp;
  if first.repgrp then kp=1;
  if last.repgrp then kp=2;
  if kp=1 or kp=2;
  keep _rep &by _group_ &group _time &rtm &rlag sid kp repgrp; 	/* eMKF: also keeping &rtm and &rlag */
run;

data _junk_;
  set _junk_;
  by repgrp;
  retain minid maxid;
  array Aid(1:2) minid maxid;
  if first.repgrp then do;
    do i = 1 to 2;
      Aid[i] = .; /*initializing to missing*/
    end;
  end;
  Aid(kp) = sid; 
  if last.repgrp then output; 
  drop kp sid i;
run;

proc sort data=_junk_;
 by _rep _group_ _time;
run;

%let jj = 0; %let lj = 0;
data _junk_;
  set _junk_;
  by _rep;
  mm=0;
  if last._rep then mm=1;
  amat=compress("Z["||minid||":"||maxid||",]"); 			/* Here Z will be the standard matrix definition that can be used */
  if mm=0 then amat=compress(amat||",");
  if first._rep or mm=0 then amat=compress("block("||amat); /* eMKF: modified to allow for arbitrary number of groups */
  call symput("jj", _n_);
  if last._rep then call symput("lj", length(amat));		/* eMKF: added to capture maximal length of character variable needed */
run;

/* eMKF: modification to allow for arbitrary number of groups (function block restricted to 15) */
data _junk_;
  set _junk_;
  if _n_=&jj then mm=2;
  length amat2 $ %eval(&g+&lj+10);							/* eMKF: set large enough character length to cover block( + lj + g times ) */
  amat2 = amat;
  %if &g = 1 %then %do;
  	  if mm=1 then amat2=compress(amat||") ");
  	  if mm=2 then amat2=compress(amat||") ");
  %end;
  %if &g > 1 %then %do;
      if mm=1 then amat2=compress(amat||repeat(") ", &g-2));
      if mm=2 then amat2=compress(amat||repeat(") ", &g-2));
  %end;
  drop amat;
  rename amat2 = amat;
run;

proc sort data=_junk_;
  by _rep _group_;
run;

data _junk_;
  set _junk_;
  name=compress("&group"||_group_);
run;

data _junk0_ _junk01_;
run;

proc transpose data=_junk_(keep=name _rep &by amat) out=_junk0_;
  var amat;
  by _rep;
  id name;
run;

proc sort data=_junk_ out=_junk01_ nodupkey;
  by _group_;
run;

%let amat=;
proc sql noprint;
  select name into :amat separated by ' || ' from _junk01_;
quit;

data _junk0_;
  set _junk0_;
  i+1;
  code=compress("Z"||i);
  mcode=compress("_Z"||i);
  amat=compress(code||"="||&amat);
  keep amat _rep code mcode;
run;

%let jj=0;
%do jj=1 %to &nrep;
  %local _Z&jj ;
%end;

data _null_;
  set _junk0_;
  call symput(mcode, amat);
run;

%let jj=0;

proc iml;

	 %do jj=1 %to &nrep;

		/* Next for the Xmatrix */
		/* eMKF v2.4: modified to allow for quadratic and cubic trend models + segment-specific intercepts */
		use _Xmat_(where=(_rep=&jj) keep= _rep s1x0 s2x0 x:);
		read all into XX; close _Xmat_; /* eMKF: also added close statements for cleanliness */
		Z =XX[,2:(1+&p)];
		&&_Z&jj ;;
	 	Xs = Z&jj;

		/* Next for the V matrix */
		use _Vmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VV; close _Vmat_; 
		Z =VV[,2:(1+&n)];
		&&_Z&jj ;;
		Vs = Z&jj;
		invVs=inv(Vs); 

		/* Next for the Ve matrix */
		use _Vemat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVe; close _Vemat_;
		Z =VVe[,2:(1+&n)];
		&&_Z&jj ;;
		Ves = Z&jj; 

		/* Next for the Vg matrix */
		use _Vgmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVg; close _Vgmat_;
		Z =VVg[,2:(1+&n)];
		&&_Z&jj ;;
		Vgs = Z&jj; 

		/* Next for the A matrix */
		use _Amat_(where=(_rep=&jj)  keep= _rep ah:);
	    read all into AA; close _Amat_;
		Z =AA[,2:(1+&n)];
		&&_Z&jj ;;
		As = Z&jj; 

		/* Next for the data label matrix */
		use _Dmat_(where=(_rep=&jj) keep=_rep &by &group &rtm _time _y _se);  /* eMKF: also keeping &rtm */
		read all var{_y} into Y;
		read all var{_rep &by &group &rtm _time} into NM;
		close _Dmat_;

		/* Now do the estimations */
		i_&n = i(&n*&g);
		H = Xs * inv(t(Xs)*invVs*Xs)*t(Xs)*invVs;
		fH = H + As*(i_&n - H);
		fY = fH * Y;
		Vy = vecdiag(fH * Vs * t(fH));
		MSEy = vecdiag(  (fH - i_&n) * Vgs * t(fH - i_&n)   ) + vecdiag(fH * Ves * t(fH));
		ff= NM || fH;
		fV= NM || Vs;
		fVy=NM || fY || Vy || MSEy;

		%if &jj = 1 %then ffs= ff;;
		%if &jj = 1 %then fVs= fV;;
		%if &jj = 1 %then fVys= fVy;;
		%if &jj > 1 %then ffs= ffs // ff;;
		%if &jj > 1 %then fVs= fVs // fV;;
		%if &jj > 1 %then fVys= fVys // fVy;; 
	 %end;

	 /* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	 %if %upcase(&nlmixedDetails) = YES %then %do;
		 create &out._H from ffs ;
		 append from ffs; close &out._H;
		 create &out._CovY from fVs ;
		 append from fVs; close &out._CovY;
	 %end;

	 %if &by ^=%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&by" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 %if &by  =%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 append from fVys; close &out._PredVar;

quit; /* eMKF: ends call to proc iml with matrix calculations*/

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;		/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;
	  %if &by  =%str() %then rename col1=_rep 	       col2= &group col3=&rtm col4=_time;;
	run;
	data &out._CovY;
	  set &out._CovY; 	/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;
	  %if &by  =%str() %then rename col1=_rep          col2= &group col3=&rtm col4=_time;;
	run;
%end;

/* eMKF: merge with predictions dataset */
data &out._pred;
  merge &out._pred &out._PredVar;
  by _rep &group _time;
  /* eMKF v2.4: remove polynomial time terms from &out._pred */
  drop &s1rtm.0 &s2rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3;
  ;
run;

/************************/
/* End of MSE estimation*/
/************************/

/*************************************************************************/
/* eMKF: Reverse-transform regression coefficients and covariance matrix */
/*************************************************************************/

data _tests _lests _tfits _tcmat _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt ;
run;

%if %upcase(&orpoly) = YES %then %do;

	/* eMKF v2.4: reverse-transform regression coefficients modified to allow for two intercepts */
	%let jj = 0; 
	proc iml;
		use _oPmat_;
		read all into oPP; close _oPmat_;
		oPP = oPP[1:&p, 1:&p];
		varNames = {"_rep" "_group_" "s1a" "s2a"};
		%if &p > 2 %then %do;
			bNames = "b1":"b&k";	
			varNames = varNames || bNames;
		%end;
		create _tests var varNames;
		%do jj=1 %to &nrep;
			use &out._ests(where=(_rep = &jj) keep= _rep _group_ s1a s2a %if &p > 2 %then b1-b&k ; ) ;
			read all into oB; close &out._ests;
			oB1 = oB[,1:2];
            oB = T(oB[,3:(2+&p)]);
            oBB = oPP * oB;
			oBB = T(oBB);
			oBB = oB1 || oBB;
			append from oBB;
		%end;
		close _tests;
	quit;

	/* eMKF: sort by _rep and _group_ */
	proc sort data=_tests;
  	  by _rep _group_ ;
	run;

	/* eMKF v2.4: update estimates dataset modified to account for 2 intercepts */
	data &out._ests;
  	  merge _tests &out._ests(drop=s1a s2a %if &p > 2 %then b1-b&k ;) ;
	  by _rep _group_;
	run;

	/* eMKF v2.4: update of predictions dataset modified to account for 2 intercepts */
	data &out._pred;
  	  merge &out._pred(drop=s1a s2a %if &p > 2 %then b1-b&k ; _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) 
			_tests &out._pred(keep=_rep _group_ _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) ;
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;

		/* eMKF v2.4: symbolic set up for reverse-transformation of covariance matrix modified to account for 2 segments */
		%let oPPmat = ; %let i = 0;
		%do i=1 %to &g;  /* eMKF: block diagonal by group */
			%if &i = 1 %then %let oPPmat = block( oP ;
			%if &i > 1 and &i < &g %then %let oPPmat = &oPPmat , block ( oP ;
			%if &i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
			%if &i = &g and &g = 1  %then %let oPPmat = &oPPmat );
		%end;
		/* eMKF v2.4: column labels sorted by group */
		%let colList = ; %let i = 0; 
		%do i=1 %to &g;
			%let colList = &colList s1ag&i s2ag&i;
			%if %upcase(&bvalue) in INDEP_LINEAR INDEP_QUAD INDEP_CUBIC %then %let colList = &colList b1g&i;;
			%if %upcase(&bvalue) in INDEP_QUAD INDEP_CUBIC %then %let colList = &colList b2g&i;;
			%if %upcase(&bvalue) = INDEP_CUBIC %then %let colList = &colList b3g&i;;
		%end;
		%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %let colList = &colList b1;;
		%if %upcase(&bvalue) in COMMON_QUAD COMMON_CUBIC %then %let colList = &colList b2;;
		%if %upcase(&bvalue) = COMMON_CUBIC %then %let colList = &colList b3;;

		/* eMKF v2.4: square block matrix of covariances for regression coefficients by group */
		data _covmat;
		  retain _rep Row Parameter &colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 1) in ('s','b')) keep = _rep Row Parameter &colList);;
		run;

		/* eMKF: obtain new row numbers associated with modified column order */
		data _tcmat;
		  set _covmat;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat out=_tcmat;
	      by _rep;
	    run;
		data _tcmat;
		  set _tcmat;
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col: ;
		run;

		/* eMKF: sort, merge, and re-sort using the new row numbers */
		proc sort data=_covmat;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat;
		  by _rep Parameter;
		run;
		data _covmat;
		  merge _covmat _tcmat;
		  by _rep Parameter;
		run;
		proc sort data=_covmat;
		  by _rep nRow;
		run;

		/* eMKF: rectangular block matrix of covariances between regression coefficients and remaining parameters */
		data _covmatt;
		  retain _rep Row Parameter &colList;;
		  set &out._covmat(where=(not(substr(Parameter, 1, 1) in ('s','b'))) keep = _rep Row Parameter &colList);;
		run;

		/* eMKF: apply reverse-transformation to both square and rectangular block matrices */
		%let i = 0; %let jj = 0;
		proc iml;
			use _oPmat_;
			read all into oP; close _oPmat_;
			oP = oP[1:&p, 1:&p];
			oPP = &oPPmat;;
			/* eMKF: re-structure block matrix in the common trend cases (where &p > 2) */
			/* eMKF v2.4: over-hauled restructuring due to two columns of intercepts */
			%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
				/* sorted index vector */
				undP = do(1, &g*&p, &p) || do(2, &g*&p, &p);
				sndP = undP;									
				sndP[,rank(sndP)] = undP; 
				/* square matrix involving intercepts only */
				oPP1 = oPP[sndP, sndP];
				/* last row to append */
				oPP2 = oPP[sndP, do(3, &g*&p, &p)];
				vPP2 = oPP2[1:2, 1];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						vPP2 = vPP2 // oPP2[(1+2*&i):(2*(1+&i)), 1+&i];
					%end;
				%end;
				oPP1 = oPP1 // T(vPP2);
				/* last column to append */
				oPP2 = oPP[do(3, &g*&p, &p), sndP];
				TvPP2 = oPP2[1, 1:2];
				%if &g > 1 %then %do;
					%do i = 1 %to &g-1;
						TvPP2 = TvPP2 || oPP2[1+&i, (1+2*&i):(2*(1+&i))];
					%end;
				%end;
				oPP0 = T(TvPP2);
				/* quadratic terms if applicable */
				%if &p > 3 %then %do;
					oPP3 = oPP[sndP, do(4, &g*&p, &p)];
					vPP3 = oPP3[1:2, 1];
					%if &g > 1 %then %do;
						%do i = 1 %to &g-1;
							vPP3 = vPP3 // oPP3[(1+2*&i):(2*(1+&i)), 1+&i];
						%end;
					%end;
					oPP1 = oPP1 // T(vPP3);
					oPP3 = oPP[do(4, &g*&p, &p), sndP];
					TvPP3 = oPP3[1, 1:2];
					%if &g > 1 %then %do;
						%do i = 1 %to &g-1;
							TvPP3 = TvPP3 || oPP3[1+&i, (1+2*&i):(2*(1+&i))];
						%end;
					%end;
					oPP0 = oPP0 || T(TvPP3);
				%end;
				/* cubic terms if applicable */
				%if &p > 4 %then %do;
					oPP4 = oPP[sndP, do(5, &g*&p, &p)];
					vPP4 = oPP4[1:2, 1];
					%if &g > 1 %then %do;
						%do i = 1 %to &g-1;
							vPP4 = vPP4 // oPP4[(1+2*&i):(2*(1+&i)), 1+&i];
						%end;
					%end;
					oPP1 = oPP1 // T(vPP4);
					oPP4 = oPP[do(5, &g*&p, &p), sndP];
					TvPP4 = oPP4[1, 1:2];
					%if &g > 1 %then %do;
						%do i = 1 %to &g-1;
							TvPP4 = TvPP4 || oPP4[1+&i, (1+2*&i):(2*(1+&i))];
						%end;
					%end;
					oPP0 = oPP0 || T(TvPP4);
				%end;
				/* combine all into single restructured matrix */
				oPP0 = oPP0 // oPP[3:&p, 3:&p];
				oPP = oPP1 || oPP0;
			%end;
			
			varNames = {"_rep" "Row"};
			%do i=1 %to &g;
				varNames = varNames || {"s1ag&i"} || {"s2ag&i"};
				%if %upcase(&bvalue) = INDEP_LINEAR %then varNames = varNames || {"b1g&i"};;
				%if %upcase(&bvalue) = INDEP_QUAD   %then varNames = varNames || {"b1g&i"} || {"b2g&i"};;
				%if %upcase(&bvalue) = INDEP_CUBIC  %then varNames = varNames || {"b1g&i"} || {"b2g&i"} || {"b3g&i"};;
			%end;
			%if %upcase(&bvalue) = COMMON_LINEAR %then varNames = varNames || {"b1"};;
			%if %upcase(&bvalue) = COMMON_QUAD   %then varNames = varNames || {"b1" "b2"};;
			%if %upcase(&bvalue) = COMMON_CUBIC  %then varNames = varNames || {"b1" "b2" "b3"};;
			create _tcovmat var varNames;
			%do jj=1 %to &nrep;
				use _covmat(where=(_rep = &jj) drop= Parameter nRow);
				read all into oB; close _covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
	            oBB = oPP * oB * T(oPP);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _tcovmat;
			create _tcovmatt var varNames;
			%do jj=1 %to &nrep;
				use _covmatt(where=(_rep = &jj) drop= Parameter);
				read all into oB; close _covmatt;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = oPP * T(oB);
				oBB = oB1 || T(oBB);
				append from oBB;
			%end;
			close _tcovmatt;
			
		quit;

		/* eMKF: combine both square and rectangular block matrices */
	    data _tcovmat;
		  set _tcovmat _tcovmatt;
		run;

		/* eMKF: re-sort rows */
		proc sort data=_tcovmat;
	  		by _rep Row ;
		run;

		/* eMKF v2.4: re-order columns as they were initially segmented from NLMIXED */
		data _tcovmat2;
	  	  retain  _rep Row s1ag1-s1ag&g s2ag1-s2ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then b1g1-b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then b1g1-b1g&g b2g1-b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then b1 b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then b1 b2 b3; ;
		  set _tcovmat; 
		run;
		data _tcovmatt2;
	  	  retain  _rep Row s1ag1-s1ag&g s2ag1-s2ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then b1g1-b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then b1g1-b1g&g b2g1-b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then b1 b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then b1 b2 b3; ;
		  set _tcovmatt; 
		run;
		
		/* eMKF: merge */
		data _tcovmatt2;
		  merge &out._covmat(where=(not(substr(Parameter, 1, 1) in ('s','b'))) keep = _rep Row Parameter) _tcovmatt2;
		  by _rep Row;
		run;

		/* eMKF: transpose _tcovmatt2 to add into larger matrix */
		proc transpose data=_tcovmatt2(drop=Row) out=_tcovmatt2 name = Parameter;
	      by _rep;
		  id Parameter;
	    run;

		/* eMKF: insert Row numbers */
		data _tcovmatt2;
		  set _tcovmatt2;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;

		/* eMKF: update covariance matrix dataset */
		data &out._covmat;
	  	  merge &out._covmat(keep = _rep Row Parameter) _tcovmat2 _tcovmatt2 
				&out._covmat(where=(not(substr(Parameter, 1, 1) in ('s','b'))) drop= s1a: s2a: %if &p > 2 %then b: ;) ;
		  by _rep Row;
		run;

		/* eMKF: extract variances of model parameters */
		%let jj = 0; 		
		proc iml;
			create _dcovmatt var{"_rep" "Row" "Var"};
			%do jj=1 %to &nrep;
				use &out._covmat(where=(_rep = &jj) drop= Parameter);
				read all into oB; close &out._covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = vecdiag(oB);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _dcovmatt;
		quit;
		data _dcovmatt;
		  merge _dcovmatt &out._covmat(keep = _rep Row Parameter);
		  by _rep Row;
		run;

	%end;

	/* eMKF: reverse-transformed regression estimates in long form */
	%if not(%upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
		data _lests;
		  set _tests(keep = _rep s1a rename=(s1a=Est))
		  	  _tests(keep = _rep s2a rename=(s2a=Est))
			  %if &p > 2 %then _tests(keep = _rep b1 rename=(b1=Est));
			  %if &p > 3 %then _tests(keep = _rep b2 rename=(b2=Est));
			  %if &p > 4 %then _tests(keep = _rep b3 rename=(b3=Est));
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;
	%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
		%let jj = 0; 		
		data _lests;
		  set _tests(keep = _rep s1a rename=(s1a=Est))
		  	  _tests(keep = _rep s2a rename=(s2a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &p > 2 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b1 rename=(b1=Est));
			   	  %if &p > 3 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b2 rename=(b2=Est));
			  	  %if &p > 4 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b3 rename=(b3=Est));
			  %end;
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;
		/* eMKF: merge reverse-transformed estimates and variances into fitstat dataset and update */
		data _tfits;
		  merge &out._fitstat _dcovmatt;
		  by _rep ;
		run;
	%end;
	%if %upcase(&nlmixedDetails) ^= YES %then %do;
		data _tfits;
		  set &out._fitstat;
		  by _rep;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

    data _tfits;
	  merge _tfits _lests;
	  by _rep Row;
	run;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	data _tfits;
	  set _tfits;
	  if Est ne . then Estimate = Est;
	  %if %upcase(&nlmixedDetails) = YES %then %do;
		  if Var > 0 then StandardError = sqrt(Var);
		  else StandardError = .;
		  tValue = Estimate/StandardError;
		  Probt = (1-probt(abs(tValue), DF))*2;
		  Lower = Estimate + tinv(Alpha/2, DF)*StandardError;
		  Upper = Estimate + tinv(1-Alpha/2, DF)*StandardError;
	  %end;
	  drop Row Est %if %upcase(&nlmixedDetails) = YES %then Var;;
	run;
	data &out._fitstat;
	  set _tfits;
	run;

%end;

/* eMKF: Add labels for stratification variable */
%if &by ^=%str() %then %do;
	data &out._ests;
 	  merge &out._ests _freq_;
 	  by _rep;
	run;
%end;

data &out._ests; /* eMKF: Added parameter estimates for quadratic and cubic terms */
   set &out._ests;
   label _2loglike =" -2 log-likelihood estimate"
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 /* eMKF: Added labels for by variable */
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
	     /* eMKF v2.4: segmented labels for regression coefficients */
	     s1a="Parameter estimate for segment 1: intercept (s1a)"
	     s2a="Parameter estimate for segment 2: intercept (s2a)"
		 %if &p > 2 %then b1="Parameter estimate for both segments: linear term (b1)" ;
   		 %if &p > 3 %then b2="Parameter estimate for both segments: quadratic term (b2)" ;
   		 %if &p > 4 %then b3="Parameter estimate for both segments: cubic term (b3)" ; 
	;
	drop &group %if &by ^= %str() %then &by; 
    ;
run;

data &out._pred; /* eMKF: added a few useful labels */
   set &out._pred(rename=(Predvar=PredOnlyVar HatMSE=PredMSE));
   PredSE= sqrt(PredMSE);
   label _2loglike =" -2 log-likelihood estimate"
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
		 &rlag = "Elapsed real time from previous time point"
		 &rtm ="Real time used in calculations "
	     _time ="Time index variable"
	     _y  ="Original outcome"
	     _se ="Original Standard Error"
		 _avgse = "Average Standard Error across timepoints used for imputation"
		 %if &by ^= %str() %then  _avgseb = "Average Standard Error across strata used for imputation";
         impute = "Whether original Standard Error was imputed using average across timepoints"
		 %if &by ^= %str() %then imputeb = "Whether original Standard Error was imputed using average across strata";
		 inputorder = "Original ordering of the groups if it was not alphabetical"
	     prediction="Kalman estimator prediction of the outcome assuming &bvalue trend model and a level shift at the breakpoint"
	     PredMSE="Prediction variability: Mean Squared Error (MSE) assuming &bvalue trend model and a level shift at the breakpoint"
	     PredSE="Prediction standard error: Square root of MSE assuming &bvalue trend model and a level shift at the breakpoint"
	     /* eMKF v2.4: segmented labels for regression coefficients */
		 s1a="Parameter estimate for segment 1: intercept (s1a)"
		 s2a="Parameter estimate for segment 2: intercept (s2a)"
   		 %if &p > 2 %then b1="Parameter estimate for both segments: linear term (b1) assuming &bvalue trend model " ;
   		 %if &p > 3 %then b2="Parameter estimate for both segments: quadratic term (b2) assuming &bvalue trend model " ;
   		 %if &p > 4 %then b3="Parameter estimate for both segments: cubic term (b3) assuming &bvalue trend model " ;
	;
	/* These will be deleted for now. If needed they can be useful. */
   drop mu err delta lambda w gamma Hat_y PredOnlyVar &group group_rep &rlag %if &by ^= %str() %then &by; ; 
run;

/* eMKF: Rename any remaining instances of numeric &group variable to _group_ + remove numeric &by variable */
data &out._predVar;
  set &out._predVar;
  rename &group = _group_;
  %if &by ^= %str() %then drop &by;;
run;
/* eMKF v2.4 streamlining: added option to omit covariance matrices and model diagnostics */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._covY;
	  set &out._covY;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
%end;

proc datasets nolist;
 delete _freqn_ _freqs1n_ _freqs2n_ _freqg_ _freq_ _sdata_ _beta_ _inits_ _initsr_ _ests _fitstat _convstat _llike_ _empty_ _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_ _Xmat_ 
        _junk_ _junk0_ _junk01_ _oXmat_ _oPmat_ _tests _lests _tfits _tcmat _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt
		%if %upcase(&nlmixedDetails) ^= YES %then &out._H &out._covY &out._covmat &out._fitstat ;
		&out._predVar
        ;
run ;
quit;

%mend htrpxptl;

data _null_;
run;



/*HTRP macro
Macro defined 03-02-2007
It allows for the estimation of parameters from the non-linear mixed effect model

Modified for eMKF in 2023 Q1-Q2 by Makram Talih. 
Revised for eMKF v2.4 in 2025 Q1 (Makram Talih) to disable user supply of _rho_ and _tausq_ and add heteroskedastic AR options.
In eMKF, this assumes data has been pre-formatted using macro reformat.

data 	: name of the dataset.
outcome : outcome of interest. 
se      : standard error of the outcome. 
time    : time variable.
by      : allows models to run for multiple strata at the same time and can be used for simulations
xtrakeep: Any variable one wants to keep in the data while runing models: weights, ... (eMKF: could be used to retain labels for multiyear data)
orpoly  : (eMKF) YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          If YES, regression coefficients and their SEs will be reverse-transformed prior to macro end.
bvalue  : Assumption about the trend model: eMKF options are the following:
             indep_cubic	: The values of the parameters b1, b2, and b3 are computed for each group
             indep_quad		: b3=0. The values of the parameters b1 and b2 are computed for each group
             indep_linear   : (DEFAULT) b3=0 and b2=0. The value of the slope b1 is computed for each group
             common_cubic	: The values of each of the parameters b1, b2, and b3 are assumed to be the same across groups
             common_quad	: b3=0. The values of each of the parameters b1 and b2 are assumed to be the same across groups
             common_linear  : b3=0 and b2=0. The value of the slope b1 is assumed to be the same across groups
             dropped    	: A model without time trend is computed
ARvalue	: [New in eMKF v2.4] Assumption about the AR(1) model. Options are:
			 common_ar (default): AR parameters are common across groups; 
		     common_arh			: AR correlation is common but innovation variance parameters are group-specific.
			 indep_ar			: Both AR(1) parameters are group-specific. 
group   : the different groups (e.g., race/ethnicity groups) variable
nlmixedDF: Non-linear model degrees of freedom for proc nlmixed. The default is set pretty high at 10000
nlmixedDetails: (eMKF v2.4 streamlining)(default = NO) option to omit covariance matrix of parameters and other model information.
nlmixedTech:	(eMFK v2.4 streamlining) (default = NEWRAP) added to give user more control over choice of optimization algorithm
print   : Yes will print the nlmixed results and No will not. Default is No
out     : The name of the output baseline. All the following outputs (baseline + suffix) are saved. 
          Here are the suffixes:
          	_fitstat : model fit estimates from the proc nlmixed
          	_ests    : model fit estimates formated for use in the estimation of the Kalman prediction
          	_covmat  : model fit covariance matrix
          	_pred    : Kalman prediction of the outcome of interest includes original values as well as parameters
         (e.g., for OUT=result then RESULT_PRED will be the Kalman prediction data of the outcome of interest. )
*/
%macro htrp(data=, 
            outcome=, 
            se=,
            group=,
            time=, 
            by=, 
            xtrakeep= ,
			orpoly=YES,
            bvalue= indep_linear, 
			ARvalue = common_ar,
            nlmixedDF=10000, 
			nlmixedDetails=NO,
			nlmixedTech=NEWRAP,
            out=param,
            print=NO
            ) / minoperator; /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local formatted dsop dscl g n _rtimess rtm rlag nrep p k d tline jj tauline rholine b1line b2line b3line i j nlmerr _emkfmu_ group_rep lj amat oPPmat colList ;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&data));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &time)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _sdata_;
run;

%if &formatted = 1 %then %do;
	/* eMKF v2.4 note: recall that _groupnum and _reps are created before HTRP is called from parent MKF macro */
	data _sdata_;
	  set &data;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to MLE-based estimation;
	%reformat(data=&data, outcome=&outcome, se=&se, group=&group, time=&time, by=&by, outformat= _sdata_);
	/* eMKF: Create copies of _group_ and _rep variables for use in proc iml matrix calculations */
	data _sdata_; 
	  set _sdata_;
	  _groupnum = _group_; 					 
	  %if &by ^= %str() %then _reps = _rep;;
	run;
	/* eMKF: Replace &group and &by macro variables by their numeric versions */
	%let group = _groupnum; 				
	%if &by ^= %str() %then %let by = _reps;;
%end;

/* eMKF: Sort by replications (if any), group, and time */
/* eMKF: Use _time as &time could be empty if data was still in format 1 when htrp was called */
proc sort data= _sdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _freqg_;
run;
proc freq data=_sdata_ noprint;
  tables &group /list out=_freqg_;
run;
data _freqg_;
  set _freqg_;
  _group_ +1;
  call symput('g',_group_);
  keep _group_ &group;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _freqn_;
run;
proc freq data=_sdata_ noprint;
  tables _rtime /list out=_freqn_;
run;
data _freqn_;
  set _freqn_;
  _time +1;
  call symput('n',_time);
  keep _time _rtime;
run;
%let n=%eval(0+&n);

/* eMKF: Macro variable for the real times to use in calculations */
%let _rtimess = ;
data _freqn_;
  set _freqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_rtimess', _rts);
  drop _rts;
run;

/* eMKF allows for irregular and fractional times points */
/* This is the variable that will be used for real time in case it is not just 1,2,3,... */
%let rtm=_rtime;

/* eMKF: macro reformat now also tracks lags between successive real time points */		
%let rlag=_rlag;

/* eMKF: Macro variable for the number of replications */
%let nrep=1;
%if &by ^=%str() %then %do;
	data _freq_;
	run;
	proc freq data=_sdata_ noprint;
	  tables &by /list out=_freq_;
	  format &by ;
	run;
	data _freq_;
	  set _freq_;
	  _rep +1;
	  call symput('nrep',_rep);
	  keep _rep &by;
	run;
%end;
%let nrep=%eval(0+&nrep);

/* eMKF v2.4 streamlining: Error check to make sure there are at least 2 timepoints */
%if (&n < 2) %then %do;
	%put ERROR: htrp macro requires at least 2 timepoints. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p=0;
%if %upcase(&bvalue) in INDEP_CUBIC COMMON_CUBIC %then %let p = 4;
%if %upcase(&bvalue) in INDEP_QUAD COMMON_QUAD %then %let p = 3;
%if %upcase(&bvalue) in INDEP_LINEAR COMMON_LINEAR %then %let p = 2;
%if %upcase(&bvalue) = DROPPED %then %let p = 1;
%let k = %eval(&p - 1);

/* eMKF v2.4 streamlining: max polynomial rank d-1 to use in orpoly */
%let d = 0;
%if &n > 4 %then %let d = 4;	/* cubic allowed */
%else %do;
	%if &n > 3 %then %let d = 3;	/* quad allowed */
	%else %do;
		%if &n > 2 %then %let d = 2;	/* linear allowed */
		%else %let d = 1;						/* intercepts-only model allowed */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4 streamlining: Error check to make sure requested trend models can be fit */
%if &p > &d %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%put ERROR- &bvalue was requested, yet there are only enough data for a degree %eval(&d-1) polynomial.; 
  	%return;
%end;

/* eMKF: Modification to set up orthogonal cubic polynomial design matrix */

data _oXmat_ _oPmat_ ;
run;

/* eMKF v2.4 streamlining: accounted for max polynomial degree in case of fewer timepoints than 5 */
%if %upcase(&orpoly) = YES %then %do;
	proc iml;
	  x = { &_rtimess };	
	  x = T(x);											/* eMKF: column vector with real times */
	  %if &d = 1 %then oP = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP = orpol(x, &d - 1);;			/* eMKF v2.4: orthonormal design matrix oP */
	  x0 = { %cnstss(1, &n) };
	  x0 = T(x0);
	  %if &n > 2 %then x1 = x;;
	  %if &n > 3 %then x2 = x#x1;;
	  %if &n > 4 %then x3 = x#x2;;
	  uP = x0;										
	  %if &n > 2 %then uP = uP || x1;;	
	  %if &n > 3 %then uP = uP || x2;;	
	  %if &n > 4 %then uP = uP || x3;;					/* eMKF v2.4: raw/unstandardized design matrix s1uP */
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
      %if &n > 2 %then oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];;
      %if &n > 3 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &n > 4 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
	  oPP = oP1;									
	  %if &n > 2 %then oPP = oPP || oP2;;
	  %if &n > 3 %then oPP = oPP || oP3;;
	  %if &n > 4 %then oPP = oPP || oP4;;				/* eMKF: right multiplication of s1uP with s1oPP produces s1oP */
	  y = T(do(1, &n, 1));								/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1" "&rtm.2" "&rtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1" "&rtm.2"} ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1"} ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_sdata_;
	  by _time;
	run;
	data _sdata_;
	   merge _sdata_ _oXmat_;
	   by _time;
	run;
	proc sort data= _sdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _sdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _sdata_ */
	   set _sdata_;
	   &rtm.0 = 1;
	   %if &d > 1 %then &rtm.1 = &rtm;;
	   %if &d > 2 %then &rtm.2 = &rtm**2;;				
	   %if &d > 3 %then &rtm.3 = &rtm**3;;
	run;
%end;

/* eMKF: Set up model statement symbolically for use in proc reg
 * Initial regression when no time trend is desired differs from the original MKF, here.  
 * In MKF, initial values for intercepts were based on those from linear trend model instead of dropped model.
 */
%let tline=;
%if &p = 4 %then %let tline = &rtm.0 &rtm.1 &rtm.2 &rtm.3;
%if &p = 3 %then %let tline = &rtm.0 &rtm.1 &rtm.2;
%if &p = 2 %then %let tline = &rtm.0 &rtm.1;
%if &p = 1 %then %let tline = &rtm.0;

/* eMKF: Modified call to proc reg to include quad and cubic terms
 * Implemented regression by _rep instead of relying only on _rep = 1 for initial values to pass to proc nlmixed
 */
proc reg data=_sdata_ outest=_beta_ noprint;
   by _rep _group_;
   model _y = &tline /noint;;
run;

/* Setup initial values (modified for eMKF to hold quad and cubic coefficients)
   Use the beta estimates from the model above. For &g groups, then:
     ag1-ag&g are the intercept from each of the &g groups models
     b1g1-b1g&g are the linear coefficients from each of the &g groups models
     b2g1-b2g&g are the quadratic coefficients from each of the &g groups models
     b3g1-b3g&g are the cubic coefficients from each of the &g groups models
   eMKF v2.4 also allows for group-specific AR parameters
*/

/* eMKF: Sort regression coefficients by _rep and _group_ */
proc sort data=_beta_;
  by _rep _group_;
run;

/* eMKF: Initial parameter values for the first replication */
%let jj = 1;
data _inits_;
	set _beta_(where=(_rep = &jj)) end=end;
	_rep = &jj;
   	array ag ag1-ag&g;
   	array b1g b1g1-b1g&g;
   	array b2g b2g1-b2g&g;
   	array b3g b3g1-b3g&g;
	%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
	%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
   	retain ag1-ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g 
		  %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
		  %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
    ;
	ag{_group_} = &rtm.0;
    %if &p > 1 %then b1g{_group_} = &rtm.1 ;; 
   	%if &p > 2 %then b2g{_group_} = &rtm.2 ;;
   	%if &p > 3 %then b3g{_group_} = &rtm.3 ;;
	%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
	%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
   	if end then do; 
		/* eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied: they will be estimated using these initial values instead */
		/* eMKF v2.4 also allows for group-specific AR parameters */
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
      	output;
   	end;
   	keep _rep ag1-ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g 
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
		%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
		%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
	;
run;

/* eMKF: Initial estimates from each subsequent replication */
data _initsr_;
run;
%if &nrep > 1 %then %do; 	
	%do jj = 2 %to &nrep;
		data _initsr_;
			set _beta_(where=(_rep = &jj)) end=end;
			_rep = &jj;
		   	array ag ag1-ag&g;
		   	array b1g b1g1-b1g&g;
		   	array b2g b2g1-b2g&g;
		   	array b3g b3g1-b3g&g;
			%if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
			%if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
   			retain ag1-ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g 
		  		   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
				   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
 			;
			ag{_group_} = &rtm.0;
		    %if &p > 1 %then b1g{_group_} = &rtm.1 ;; 
		   	%if &p > 2 %then b2g{_group_} = &rtm.2 ;;
		   	%if &p > 3 %then b3g{_group_} = &rtm.3 ;;
			%if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
			%if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
		   	if end then do; 
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
		   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
		      	output;
		   	end;
		   	keep _rep ag1-ag&g b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g 
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
				%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
				%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
			;
		run;
		data _inits_;
		  set _inits_ _initsr_;
		run;
		data _initsr_;
		run;
	%end;
%end;
  
/* eMKF: calculate initial estimates for common_ scenarios and remove extraneous variables */
data _inits_; 
	set _inits_;
	b1=.;
	b2=.;
	b3=.;
    %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then b1 = mean(of b1g1-b1g&g) ;;
    %if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR) %then drop b1g1-b1g&g ;;
    %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD %then b2 = mean(of b2g1-b2g&g) ;;
	%if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD) %then drop b2g1-b2g&g ;;
 	%if %upcase(&bvalue) = COMMON_CUBIC %then b3 = mean(of b3g1-b3g&g) ;;
 	%if %upcase(&bvalue) ^= INDEP_CUBIC %then drop b3g1-b3g&g ;;
	%if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR) %then drop b1;;
    %if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD) %then drop b2;;
	%if %upcase(&bvalue) ^= COMMON_CUBIC %then drop b3;; 
run;

/* eMKF v2.4: re-order columns in common trend cases so the logitrho and logtau2 remain last */
%if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
	data _inits_;
	  merge _inits_(drop = logtau2: logitrho:) _inits_(keep = _rep logtau2: logitrho:);
	  by _rep;
	run;
%end;

/* eMKF v2.4: Set up array declarations for tau and rho parameters symbolically for use in proc nlmixed */
%let tauline=; %let rholine=;
%if %upcase(&ARvalue) ^= COMMON_AR %then %let tauline = array logtau2g(&g) logtau2g1-logtau2g&g%str(;) array _tausq_(&g) _tausq_1-_tausq_&g%str(;) ;
%if %upcase(&ARvalue) = INDEP_AR %then %let rholine= array logitrhog(&g) logitrhog1-logitrhog&g%str(;) array _rho_(&g) _rho_1-_rho_&g%str(;) ; 

/* eMKF: Set up array declarations symbolically for use in proc nlmixed */
%let b1line=; %let b2line=; %let b3line=;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %let b1line= array b1g(&g) b1g1-b1g&g ;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then %let b2line= array b2g(&g) b2g1-b2g&g ;
%if %upcase(&bvalue) = INDEP_CUBIC %then %let b3line= array b3g(&g) b3g1-b3g&g ;

/* eMKF: Set up model statement symbolically for use in proc nlmixed */
%let tline=;
%if %upcase(&bvalue) = INDEP_CUBIC   %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1g[_group_]+&rtm.2*b2g[_group_]+&rtm.3*b3g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue) = INDEP_QUAD    %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1g[_group_]+&rtm.2*b2g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue) = INDEP_LINEAR  %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1g[_group_]+gamma[_time],_se**2);
%if %upcase(&bvalue) = COMMON_CUBIC  %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1+&rtm.2*b2+&rtm.3*b3+gamma[_time],_se**2);
%if %upcase(&bvalue) = COMMON_QUAD   %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1+&rtm.2*b2+gamma[_time],_se**2);
%if %upcase(&bvalue) = COMMON_LINEAR %then %let tline= normal(&rtm.0*ag[_group_]+&rtm.1*b1+gamma[_time],_se**2);
%if %upcase(&bvalue) = DROPPED       %then %let tline= normal(&rtm.0*ag[_group_]+gamma[_time],_se**2);

/* Fit a Non-linear mixed model. Capture covariance matrix COV and covariance matrix from additional estimate ECOV */

data _ests _fitstat _convstat &out._fitstat &out._covmat; 	/* eMKF v2.4 streamlining: no longer creating copy of _sdata_ to store in &out._data*/
run;

%put ;
%put Start model fitting using PROC NLMIXED; 				/* eMKF: substituted put statement */

/* eMKF: model print handling */
%if %upcase(&print) ^= YES %then ods exclude all;; 

/* eMKF v2.4: initialized counters for use in proc nlmixed */
%let i=0; %let j=0;

/* eMKF v2.4: Error check to make sure specified optimization method is valid */
%if not(%upcase(&nlmixedTech) in CONGRA DBLDOG NEWRAP NMSIMP NONE NRRIDG QUANEW TRUREG) %then %do;
	%put ERROR: proc nlmixed syntax error. Specified optimization algorithm &nlmixedTech not recognized. Please check!;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */
/* eMKF v2.4 streamlining: omitted calculation of reverse-transformed rho and tausq (estimate statements) and ecov */ 
/* eMKF v2.4 now also allows for group-specific AR parameters (_rho_ and _tausq_ can no longer be user-supplied) */
proc nlmixed data=_sdata_ DF=&nlmixedDF %if %upcase(&nlmixedDetails) = YES %then cov; 
	tech=&nlmixedTech				 		/* eMKF v2.4: can replace default (QUANEW) optimization with other available methods */
	method=firo maxiter=500; 		 		/* eMKF: updated method and maxiter to match those in htrp2d */
	by _rep; 						 		/* eMKF: stratified by _rep (trivial if _rep is constant = 1 (i.e., no stratification) */
	array gamma(&n) gamma1-gamma&n ; 		/* Give the gamma values a generic name */
	array ag(&g) ag1-ag&g; 			 		/* Give the a values a generic name */
	&b1line;; 						 		/* Give the bl values a generic name */
	&b2line;; 						 		/* eMKF: Give the b2 values a generic name */
	&b3line;; 								/* eMKF: Give the b3 values a generic name */ 
	&tauline;;						 		/* eMKF v2.4: group-specific innovation variances (if any) */
	&rholine;;						 		/* eMKF v2.4: group-specific autocorrelation coefficients (if any) */
	%if %upcase(&ARvalue)^=COMMON_AR 
	  %then array nu(&g) nu1-nu&g;;  		/* eMKF v2.4: group-specific stationary variances (if any) */
	parms / bydata data=_inits_; 	 		/* eMKF: Setup parameters and their initial values stratified by _rep */

	%if %upcase(&ARvalue)=COMMON_AR %then %do;
		bounds logitrho >= 0;				/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		_tausq_ = exp(logtau2);
		nu = _tausq_/(1-(_rho_**2));
	%end;
	%if %upcase(&ARvalue)=COMMON_ARH %then %do;
		bounds logitrho >= 0;				/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		%do j = 1 %to &g;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_**2));
		%end;
	%end;
	%if %upcase(&ARvalue)=INDEP_AR %then %do;
		bounds logitrhog1-logitrhog&g >= 0;	/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		%do j = 1 %to &g;
			_rho_&j = 2/(1+exp(-logitrhog&j)) - 1;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_&j**2));
		%end;
	%end;

	/* Random effects gamma1 gamma2 ... gamma&n ~ normal([0,0,..,0],[nu, half triangular matrix]) */
	/* eMFK: Replaced do loop for variances with call to macro thevarcompr to allow for noninteger/unequally-spaced time points */
	/* eMKF v2.4 allows for group-specific AR coefficients */
	%if %upcase(&ARvalue) = COMMON_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu, vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = COMMON_ARH %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_)) subject=_group_;
	%end;
	%if %upcase(&ARvalue) = INDEP_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_[_group_])) subject=_group_;
	%end;

	model _y ~ &tline;;

	/* eMKF v2.4 streamlining: added output for convergence status */
    ods output parameterestimates=_ests fitstatistics=_fitstat convergencestatus=_convstat;
	%if %upcase(&nlmixedDetails) = YES %then ods output CovMatParmEst=&out._covmat;;
run;

/* eMKF v2.4: Error check to make sure proc nlmixed converged */
%let nlmerr = 0;
data _null_;
  set _convstat;
  if Status = 1 then call symput("nlmerr" , 1);
run;
%let nlmerr = %eval(0 + &nlmerr);
%if &nlmerr %then %do;
	%put ERROR: proc nlmixed returned an error. Try specifying an optimization algorithm other than &nlmixedTech.;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
%if %upcase(&nlmixedDetails) ^= YES %then %do;
	data _ests;
	  set _ests;
	  drop StandardError DF tValue Probt Alpha Lower Upper Gradient;
	run;
%end;

/* eMKF: Replace missing values in CovMatParmEst with 0s for later use */
%if %upcase(&nlmixedDetails) = YES and %upcase(&orpoly) = YES %then %do;
	data &out._covmat;
	  set &out._covmat;
	  array NAs _numeric_;
	  do over NAs;
	      if NAs = . then NAs = 0;
	  end;
	run;
%end;

/* eMKF: Reset ODS destinations if they were turned off */
%if %upcase(&print) ^= YES %then ods exclude none;;

/* eMKF: Added put statements for log */
%put ;
%put End model fitting using PROC NLMIXED;
%if %upcase(&print) ^= YES %then %put Model printout was turned off by user.;;

/* eMKF: Model estimates */
data _fitstat;
   set _fitstat;
   if descr = "-2 Log Likelihood";
   _2loglike=value;
   keep _2loglike _rep;
run;
data &out._fitstat;
  merge _ests _fitstat;
  by _rep;
run;
data _llike_;
run;
data _llike_;
  set &out._fitstat;
  by _rep;
  if first._rep then output;
  keep _rep _2loglike;
run;
data &out._ests;
run;
proc transpose data=&out._fitstat out=&out._ests;
   by _rep;
   var estimate;
   id parameter;
run;

/* eMKF v2.4 streamlining: _emkfmu_ tracks the mean; _emkfkeep_ is now defunct; p will be used to track which coefficients to keep */
%let _emkfmu_ = ;
%if &p = 4 %then %let _emkfmu_ = mu=a*&rtm.0+b1*&rtm.1+b2*&rtm.2+b3*&rtm.3;;
%if &p = 3 %then %let _emkfmu_ = mu=a*&rtm.0+b1*&rtm.1+b2*&rtm.2;;
%if &p = 2 %then %let _emkfmu_ = mu=a*&rtm.0+b1*&rtm.1;;
%if &p = 1 %then %let _emkfmu_ = mu=a*&rtm.0;;

/* eMKF: Re-structure estimates by _rep and _group_ */
data &out._ests;
   merge &out._ests _llike_;
   by _rep;
   array as ag1-ag&g;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then array b1s b1g1-b1g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b1 = 0 ;;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then array b2s b2g1-b2g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b2 = 0 ;;
   %if %upcase(&bvalue) = INDEP_CUBIC %then array b3s b3g1-b3g&g ;;
   %if %upcase(&bvalue) = DROPPED %then b3 = 0 ;;
   /* eMKF v2.4 allows for group-specific AR coefficients */
   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2s logtau2g1-logtau2g&g ;;
   %if %upcase(&ARvalue) = COMMON_AR %then _tausq_ = exp(logtau2) ;; 
   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhos logitrhog1-logitrhog&g ;;
   %if %upcase(&ARvalue) ^= INDEP_AR %then _rho_ = 2/(1+exp(-logitrho))-1 ;;
   do _group_ = 1 to &g;
      a = as{_group_};
      %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then b1 = b1s{_group_} ;;
	  %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then b2 = b2s{_group_} ;;
      %if %upcase(&bvalue) = INDEP_CUBIC %then b3 = b3s{_group_} ;;
	  %if %upcase(&ARvalue) ^= COMMON_AR %then _tausq_ = exp(logtau2s{_group_}) ;;
	  %if %upcase(&ARvalue) = INDEP_AR %then _rho_ = 2/(1+exp(-logitrhos{_group_}))-1 ;;
      output;
   end;
   /* eMKF v2.4 streamlining: used &p (and &k = &p-1) instead of &_emkfkeep_ to track which coefficients to keep */
   keep _rep _group_ a %if &p > 1 %then b1-b&k ; _tausq_ _rho_ _2loglike;
run;

/* eMKF v2.4 streamlining: reordered columns here and used &p (and &k = &p-1) instead of &_emkfkeep_ to track which coefficients to keep */
data &out._ests;
  merge &out._ests(keep= _rep _group_ a) %if &p > 1 %then &out._ests(keep= b1-b&k); &out._ests(keep= _tausq_) &out._ests(keep= _rho_) &out._ests(keep= _2loglike); 
run;

/* eMKF: Merge with group labels */
proc sort data= &out._ests;
  by _group_;
run;
proc sort data=_freqg_;
  by _group_;
run;
data &out._ests;
  merge &out._ests _freqg_;
  by _group_;
run;

/***************************************************************************/
/* Now let's use the Kalman technique to estimate the outcome observations */
/***************************************************************************/

data &out._pred;
run;
proc sort data=_sdata_ out=&out._pred;
  by _rep _group_ _time; 
run;

proc sort data=&out._ests;
  by _rep _group_;
run;

data &out._pred; 
  merge &out._pred &out._ests;
  by _rep _group_ ;
  &_emkfmu_;; 					/* eMKF: invoke symbolic calculation for mu */
  err=_y - mu;
run;

data _empty_;
  set &out._pred;
  if _time= 1;
  w0 = _tausq_/(1-(_rho_**2));
  gamma0 = 0 ;
  _time= 0;
  &rtm= 0;
  &rlag = .;
  keep _time &rtm 				/* eMKF v2.4 streamlining: modified to condition on polynomial rank */
		&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
		&rlag &by _rep &group _group_ w0 gamma0;
run;

data &out._pred;
 set &out._pred _empty_;
 if _time = 1 then &rlag = 1;	/* eMKF: set to lag 1 instead of missing relative to time 0 */
run;

proc sort data=&out._pred;
 by _rep _group_ _time;
run;

/* eMKF: recursion formulas modified to allow lag s > 0 between time points */
data &out._pred;
  set &out._pred;
  retain wold gamold;
  delta = ((_rho_**(2*&rlag)) * wold) + _tausq_*(1 - (_rho_**(2*&rlag)))/(1 - (_rho_**2));
  if &rlag > 0 or &rlag = . then lambda = delta/(delta + (_se**2));
  else lambda = 0; 				/* eMKF: in the limiting case, recursion breaks down: set lambda = 0 instead */
  w = delta * (1-lambda);
  gamma = (lambda* err) + (1-lambda)*(_rho_**&rlag)*gamold ; /* eMKF: &rlag=1 reduces to unit-increment case */
  prediction = mu + gamma ;
  output;
  if _time = 0 then do;
	wold=w0;
	gamold=gamma0;
  end;  
  if _time ^= 0 then do; 
	wold=w;
    gamold=gamma;
  end;
run;

/* eMKF v2.4 correction: added hyphen separator between _rep and _group_ to cover cases with more than 10 reps or groups (e.g., 1-11 vs 11-1) */
%let group_rep = compress(_rep || "-" || _group_);

data &out._pred;
  set &out._pred;
  group_rep= &group_rep;
  if _time ne 0;
  drop w0 gamma0 wold gamold;
run;

/* eMKF: reset lag for time 1 to missing */
data &out._pred;
  set &out._pred;
  if _time = 1 then &rlag = .; 
run;

/******************/
/* Compute the MSE*/
/******************/

data _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_  _Xmat_ _junk_ _junk0_ _junk01_;
run;

proc sort data=&out._pred(keep= _rep &by _group_ &group _time &rtm  /* eMKF v2.4 streamlining: modified to condition on polynomial rank */
								&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
								&rlag _y _se _rho_ _tausq_ err lambda prediction group_rep)
  out=_Amat_ ;
  by group_rep;
run;

data _Amat_;
  set _Amat_; 
  by group_rep;
  array hs ah1-ah&n (%zeross(&n));
  if first.group_rep then do _k=1 to &n; hs{_k}=0; end;
  if _time = 1 then ah1=lambda;
  else do; 					
     do _j=1 to _time - 1; 		/* eMKF: updated to account for &rlag if not 1 */
	    hs{_j} = hs{_j}*(1-lambda)*(_rho_**&rlag) ; 
	 end;
	 hs{_time}=lambda;
  end;
  drop group_rep _k _j;
  keep _rep &by _group_ &group _time &rtm &rlag ah:;
run;

proc sort data=_Amat_;
  by _rep _group_ _time  ;
run;

/* Attach row number _id to each of the A Matrix so that when computing group by group the appropriate Ag could be called*/
data _Amat_;
  set _Amat_;
  _id+1;
run;

data _Dmat_;
  set &out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4 streamlining: modified to condition on polynomial rank */
						&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
						&rlag _y _rho_ _tausq_ _se);
  w0 = _tausq_/(1- (_rho_**2));
run;

/* The Matrix _Dmat_ is actually the same within group and within replication*/
proc sort data= _Dmat_ nodupkey;
  by _rep _group_ _time;
run;

/* Here the standard error is the same from one replication to another by different from group to group. 
   So these matrices should just be estimated differently for each group as well as replication if possible */
data _Vmat_; 
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 				/* eMKF: modification to deal with irregular time points */
  do i=1 to &n; 
  	 if i = _time  then ad{i} = w0 + _se**2; 	/* Add the variances of Y to the diagonal elements */
   	 else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* Recreate the variance where only the Variance of gamma is estimated.
   This is mostly needed for check of what the estimates are giving us. */
data _Vgmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is the diagonal Variance matrix of the errors */
data _Vemat_;
  set _Dmat_;
  array ad ad1-ad&n;
  do i=1 to &n;
    if i = _time then ad{i}= _se**2;
    else ad{i} = 0;
  end;
  drop i;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n;
run;

/* This is just like the _Vgmat_ but with extra variables kept to be used later for the creation of the X matrix for example */
data _Dmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
    if i = _time then ad{i} = w0;
    else ad{i} = w0*(_rho_**abs(rt{i} - &rtm));
  end;
  drop i rt1-rt&n;
run;

/* This is the X matrix */
data _Xmat_;
  set _Dmat_; 			
  /* eMKF v2.4 streamlining: modification to deal with orthogonal polynomials now also accounts for polynomial degree */
  x0 = &rtm.0; 
  %if &d > 1 %then x1 = &rtm.1;;
  %if &d > 2 %then x2 = &rtm.2;;
  %if &d > 3 %then x3 = &rtm.3;;
  keep _rep &by _group_ &group 
		x0 %if &d > 1 %then x1; %if &d > 2 %then x2; %if &d > 3 %then x3;
  ;
run;

data &out._H &out._PredVar &out._CovY;
run;

/********************************************************************************************************************************/
/* eMKF v2.4 streamlining: Removed portion of code that pertained to symbolic matrix operations redundant with use of proc iml  */
/*                         Those symbolic operations were stored in defunct macro variables iis, vmatinv, vmat, xmat, and blmat */
/********************************************************************************************************************************/

/* Now let's capture the A Matrix and turn it into a diagonal block matrix  */

data _junk_;
  set _Amat_;
  by _rep;
  if first._rep then sid=0;
  sid+1;
  repgrp=&group_rep; 	/* eMKF v2.4 streamlining: repgrp assigned value of macro variable &group_rep */
run;

proc sort data=_junk_;
  by repgrp sid;
run;

data _junk_;
  set _junk_;
  by repgrp;
  if first.repgrp then kp=1;
  if last.repgrp then kp=2;
  if kp=1 or kp=2;
  keep _rep &by _group_ &group _time &rtm &rlag sid kp repgrp; 	/* eMKF: also keeping &rtm and &rlag */
run;

data _junk_;
  set _junk_;
  by repgrp;
  retain minid maxid;
  array Aid(1:2) minid maxid;
  if first.repgrp then do;
    do i = 1 to 2;
      Aid[i] = .; 	/* initializing to missing */
    end;
  end;
  Aid(kp) = sid; 
  if last.repgrp then output; 
  drop kp sid i;
run;

proc sort data=_junk_;
 by _rep _group_ _time;
run;

%let jj = 0; %let lj = 0;
data _junk_;
  set _junk_;
  by _rep;
  mm=0;
  if last._rep then mm=1;
  amat=compress("Z["||minid||":"||maxid||",]"); 			/* Here Z will be the standard matrix definition that can be used */
  if mm=0 then amat=compress(amat||",");
  if first._rep or mm=0 then amat=compress("block("||amat); /* eMKF: modified to allow for arbitrary number of groups */
  call symput("jj", _n_);
  if last._rep then call symput("lj", length(amat));		/* eMKF: added to capture maximal length of character variable needed */
run;

/* eMKF: modification to allow for arbitrary number of groups (function block restricted to 15) */
data _junk_;
  set _junk_;
  if _n_=&jj then mm=2;
  length amat2 $ %eval(&g+&lj+10);							/* eMKF: set large enough character length to cover block( + lj + g times ) */
  amat2 = amat;
  %if &g = 1 %then %do;
  	  if mm=1 then amat2=compress(amat||") ");
  	  if mm=2 then amat2=compress(amat||") ");
  %end;
  %if &g > 1 %then %do;
      if mm=1 then amat2=compress(amat||repeat(") ", &g-2));
      if mm=2 then amat2=compress(amat||repeat(") ", &g-2));
  %end;
  drop amat;
  rename amat2 = amat;
run;

proc sort data=_junk_;
  by _rep _group_;
run;

data _junk_;
  set _junk_;
  name=compress("&group"||_group_);
run;

data _junk0_ _junk01_;
run;

proc transpose data=_junk_(keep=name _rep &by amat) out=_junk0_;
  var amat;
  by _rep;
  id name;
run;

proc sort data=_junk_ out=_junk01_ nodupkey;
  by _group_;
run;

%let amat=;
proc sql noprint;
  select name into :amat separated by ' || ' from _junk01_;
quit;

data _junk0_;
  set _junk0_;
  i+1;
  code=compress("Z"||i);
  mcode=compress("_Z"||i);
  amat=compress(code||"="||&amat);
  keep amat _rep code mcode;
run;

%let jj=0;
%do jj=1 %to &nrep;
  %local _Z&jj ;
%end;

data _null_;
  set _junk0_;
  call symput(mcode, amat);
run;

%let jj=0;

proc iml;

	 %do jj=1 %to &nrep;

		/* Next for the Xmatrix */
		/* eMKF: modified to allow for quadratic and cubic trend models */
		use _Xmat_(where=(_rep=&jj) keep= _rep x:);
		read all into XX; close _Xmat_; /* eMKF: also added close statements for cleanliness */
		Z =XX[,2:(1+&p)];
		&&_Z&jj ;;
	 	Xs = Z&jj;

		/* Next for the V matrix */
		use _Vmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VV; close _Vmat_; 
		Z =VV[,2:(1+&n)];				/* eMKF v2.4 streamlining: replaced previously used macro variables &n1=2 and &n2=1+&n with their values */
		&&_Z&jj ;;
		Vs = Z&jj;
		invVs=inv(Vs); 

		/* Next for the Ve matrix */
		use _Vemat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVe; close _Vemat_;
		Z =VVe[,2:(1+&n)];
		&&_Z&jj ;;
		Ves = Z&jj; 

		/* Next for the Vg matrix */
		use _Vgmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVg; close _Vgmat_;
		Z =VVg[,2:(1+&n)];
		&&_Z&jj ;;
		Vgs = Z&jj; 

		/* Next for the A matrix */
		use _Amat_(where=(_rep=&jj)  keep= _rep ah:);
	    read all into AA; close _Amat_;
		Z =AA[,2:(1+&n)];
		&&_Z&jj ;;
		As = Z&jj; 

		/* Next for the data label matrix */
		use _Dmat_(where=(_rep=&jj) keep=_rep &by &group &rtm _time _y _se);  /* eMKF: also keeping &rtm */
		read all var{_y} into Y;
		read all var{_rep &by &group &rtm _time} into NM;
		close _Dmat_;

		/* Now do the estimations */
		i_&n = i(&n*&g);
		H = Xs * inv(t(Xs)*invVs*Xs)*t(Xs)*invVs;
		fH = H + As*(i_&n - H);
		fY = fH * Y;
		Vy = vecdiag(fH * Vs * t(fH));
		MSEy = vecdiag(  (fH - i_&n) * Vgs * t(fH - i_&n)   ) + vecdiag(fH * Ves * t(fH));
		ff= NM || fH;
		fV= NM || Vs;
		fVy=NM || fY || Vy || MSEy;

		%if &jj = 1 %then ffs= ff;;
		%if &jj = 1 %then fVs= fV;;
		%if &jj = 1 %then fVys= fVy;;
		%if &jj > 1 %then ffs= ffs // ff;;
		%if &jj > 1 %then fVs= fVs // fV;;
		%if &jj > 1 %then fVys= fVys // fVy;; 

	 %end;

	 /* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	 %if %upcase(&nlmixedDetails) = YES %then %do;
	 	create &out._H from ffs ;
	 	append from ffs; close &out._H;
	 	create &out._CovY from fVs ;
	 	append from fVs; close &out._CovY;
	 %end;
	 
	 %if &by ^=%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&by" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 %if &by  =%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE"} ];;
	 append from fVys; close &out._PredVar;
	 
quit; /* eMKF: ends call to proc iml with matrix calculations*/

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H; 		/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep 	       col2= &group col3=&rtm col4=_time;;;
	run;
	data &out._CovY;
	  set &out._CovY; 	/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4=&rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep          col2= &group col3=&rtm col4=_time;;;
	run;
%end;

/* eMKF: merge with predictions dataset */
data &out._pred;
  merge &out._pred &out._PredVar;
  by _rep &group _time;
  /* eMKF v2.4 streamlining: remove polynomial time terms from &out._pre, modified to condition on polynomial rank */ 
  drop &rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
  ;
run;

/************************/
/* End of MSE estimation*/
/************************/

/*************************************************************************/
/* eMKF: Reverse-transform regression coefficients and covariance matrix */
/*************************************************************************/

data _tests _lests _tfits _tcmat _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt ;
run;

%if %upcase(&orpoly) = YES %then %do;

	/* eMKF: reverse-transform regression coefficients */
	%let jj = 0; 
	proc iml;
		use _oPmat_;
		read all into oPP; close _oPmat_;
		oPP = oPP[1:&p, 1:&p];
		varNames = {"_rep" "_group_" "a"};
		%if &p > 1 %then %do;
			bNames = "b1":"b&k";	
			varNames = varNames || bNames;
		%end;
		create _tests var varNames;
		%do jj=1 %to &nrep;
			use &out._ests(where=(_rep = &jj) keep= _rep _group_ a %if &p > 1 %then b1-b&k ; ) ;
			read all into oB; close &out._ests;
			oB1 = oB[,1:2];
            oB = T(oB[,3:(2+&p)]);
            oBB = oPP * oB;
			oBB = T(oBB);
			oBB = oB1 || oBB;
			append from oBB;
		%end;
		close _tests;
	quit;

	/* eMKF: sort by _rep and _group_ */
	proc sort data=_tests;
  	  by _rep _group_ ;
	run;

	/* eMKF: update estimates dataset */
	data &out._ests;
  	  merge _tests &out._ests(drop=a %if &p > 1 %then b1-b&k ;) ;
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: update predictions dataset with columns re-ordered for consistency */
	data &out._pred;
  	  merge &out._pred(drop=a %if &p > 1 %then b1-b&k ; _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) 
			_tests &out._pred(keep=_rep _group_ _rho_ _tausq_ _2loglike mu err delta lambda w gamma prediction group_rep Hat_y PredVar HatMSE) ;
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;

		/* eMKF: symbolic set up for reverse-transformation of covariance matrix */
		%let oPPmat = ; %let i = 0;
		%do i=1 %to &g;  /* eMKF: block diagonal by group */
			%if &i = 1 %then %let oPPmat = block( oP ;
			%if &i > 1 and &i < &g %then %let oPPmat = &oPPmat , block ( oP ;
			%if &i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
			%if &i = &g and &g = 1  %then %let oPPmat = &oPPmat );
		%end;
		/* eMKF v2.4 streamlining: removed code that refered to row names symbolically (via parList) and used substring matching instead when possible */
		%let colList = ; %let i = 0; 
		%do i=1 %to &g; /* eMKF: column labels sorted by group */
			%let colList = &colList ag&i;
			%if %upcase(&bvalue) in INDEP_LINEAR INDEP_QUAD INDEP_CUBIC %then %let colList = &colList b1g&i;;
			%if %upcase(&bvalue) in INDEP_QUAD INDEP_CUBIC %then %let colList = &colList b2g&i;;
			%if %upcase(&bvalue) = INDEP_CUBIC %then %let colList = &colList b3g&i;;
		%end;
		%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %let colList = &colList b1;;
		%if %upcase(&bvalue) in COMMON_QUAD COMMON_CUBIC %then %let colList = &colList b2;;
		%if %upcase(&bvalue) = COMMON_CUBIC %then %let colList = &colList b3;;

		/* eMKF: square block matrix of covariances for regression coefficients by group */
		data _covmat;
		  retain _rep Row Parameter &colList;;
		  set &out._covmat(where=(substr(Parameter, 1, 1) in ('a','b')) keep = _rep Row Parameter &colList);;
		run;

		/* eMKF: obtain new row numbers associated with modified column order */
		data _tcmat;
		  set _covmat;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat out=_tcmat;
	      by _rep;
	    run;
		data _tcmat;
		  set _tcmat;
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col: ;
		run;

		/* eMKF: sort, merge, and re-sort using the new row numbers */
		proc sort data=_covmat;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat;
		  by _rep Parameter;
		run;
		data _covmat;
		  merge _covmat _tcmat;
		  by _rep Parameter;
		run;
		proc sort data=_covmat;
		  by _rep nRow;
		run;

		/* eMKF: rectangular block matrix of covariances between regression coefficients and remaining parameters */
		data _covmatt;
		  retain _rep Row Parameter &colList;;
		  set &out._covmat(where=(not(substr(Parameter, 1, 1) in ('a','b'))) keep = _rep Row Parameter &colList);;
		run;

		/* eMKF: apply reverse-transformation to both square and rectangular block matrices */
		%let i = 0; %let jj = 0;
		proc iml;
			use _oPmat_;
			read all into oP; close _oPmat_;
			oP = oP[1:&p, 1:&p];
			oPP = &oPPmat;;
			/* eMKF: re-structure block matrix in the common trend cases (where &p > 1) */
			%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
				oPP1 = oPP[do(1, &g*&p, &p), do(1, &g*&p, &p)];
				oPP2 = vecdiag(oPP[do(1, &g*&p, &p), do(2, &g*&p, &p)]);
				ToPP2 = vecdiag(oPP[do(2, &g*&p, &p), do(1, &g*&p, &p)]);
				oPP1 = oPP1 // T(ToPP2);
				oPP0 = oPP2;
				%if &p > 2 %then %do;
					oPP3 = vecdiag(oPP[do(1, &g*&p, &p), do(3, &g*&p, &p)]);
					ToPP3 = vecdiag(oPP[do(3, &g*&p, &p), do(1, &g*&p, &p)]);
					oPP1 = oPP1 // T(ToPP3);
					oPP0 = oPP0 || oPP3;
				%end;
				%if &p > 3 %then %do;
					oPP4 = vecdiag(oPP[do(1, &g*&p, &p), do(4, &g*&p, &p)]);
					ToPP4 = vecdiag(oPP[do(4, &g*&p, &p), do(1, &g*&p, &p)]);
					oPP1 = oPP1 // T(ToPP4);
					oPP0 = oPP0 || oPP4;
				%end;
				oPP0 = oPP0 // oPP[2:&p, 2:&p];
				oPP = oPP1 || oPP0;
			%end;
			varNames = {"_rep" "Row"};
			%do i=1 %to &g;
				varNames = varNames || {"ag&i"};
				%if %upcase(&bvalue) = INDEP_LINEAR %then varNames = varNames || {"b1g&i"};;
				%if %upcase(&bvalue) = INDEP_QUAD   %then varNames = varNames || {"b1g&i"} || {"b2g&i"};;
				%if %upcase(&bvalue) = INDEP_CUBIC  %then varNames = varNames || {"b1g&i"} || {"b2g&i"} || {"b3g&i"};;
			%end;
			%if %upcase(&bvalue) = COMMON_LINEAR %then varNames = varNames || {"b1"};;
			%if %upcase(&bvalue) = COMMON_QUAD   %then varNames = varNames || {"b1" "b2"};;
			%if %upcase(&bvalue) = COMMON_CUBIC  %then varNames = varNames || {"b1" "b2" "b3"};;
			create _tcovmat var varNames;
			%do jj=1 %to &nrep;
				use _covmat(where=(_rep = &jj) drop= Parameter nRow);
				read all into oB; close _covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
	            oBB = oPP * oB * T(oPP);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _tcovmat;
			create _tcovmatt var varNames;
			%do jj=1 %to &nrep;
				use _covmatt(where=(_rep = &jj) drop= Parameter);
				read all into oB; close _covmatt;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = oPP * T(oB);
				oBB = oB1 || T(oBB);
				append from oBB;
			%end;
			close _tcovmatt;
		quit;

		/* eMKF: combine both square and rectangular block matrices */
	    data _tcovmat;
		  set _tcovmat _tcovmatt;
		run;

		/* eMKF: re-sort rows */
		proc sort data=_tcovmat;
	  		by _rep Row ;
		run;

		/* eMKF: re-order columns as they were initially from NLMIXED */
		data _tcovmat2;
	  	  retain  _rep Row ag1-ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then b1g1-b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then b1g1-b1g&g b2g1-b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then b1 b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then b1 b2 b3; ;
		  set _tcovmat; 
		run;
		data _tcovmatt2;
	  	  retain  _rep Row ag1-ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then b1g1-b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then b1g1-b1g&g b2g1-b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then b1g1-b1g&g b2g1-b2g&g b3g1-b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then b1 b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then b1 b2 b3; ;
		  set _tcovmatt; 
		run;
		
		/* eMKF: merge */
		data _tcovmatt2;
		  merge &out._covmat(where=(not(substr(Parameter, 1, 1) in ('a','b'))) keep = _rep Row Parameter) _tcovmatt2;
		  by _rep Row;
		run;

		/* eMKF: transpose _tcovmatt2 to add into larger matrix */
		proc transpose data=_tcovmatt2(drop=Row) out=_tcovmatt2 name = Parameter;
	      by _rep;
		  id Parameter;
	    run;

		/* eMKF: insert Row numbers */
		data _tcovmatt2;
		  set _tcovmatt2;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;

		/* eMKF: update covariance matrix dataset */
		data &out._covmat;
	  	  merge &out._covmat(keep = _rep Row Parameter) _tcovmat2 _tcovmatt2 
				&out._covmat(where=(not(substr(Parameter, 1, 1) in ('a','b'))) drop= a: %if &p > 1 %then b: ;) ;
		  by _rep Row;
		run;

		/* eMKF: extract variances of model parameters */
		%let jj = 0; 		
		proc iml;
			create _dcovmatt var{"_rep" "Row" "Var"};
			%do jj=1 %to &nrep;
				use &out._covmat(where=(_rep = &jj) drop= Parameter);
				read all into oB; close &out._covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = vecdiag(oB);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _dcovmatt;
		quit;
		data _dcovmatt;
		  merge _dcovmatt &out._covmat(keep = _rep Row Parameter);
		  by _rep Row;
		run;

	%end;

	/* eMKF: reverse-transformed regression estimates in long form */
	%if not(%upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
		data _lests;
		  set _tests(keep = _rep a rename=(a=Est))
			  %if &p > 1 %then _tests(keep = _rep b1 rename=(b1=Est));
			  %if &p > 2 %then _tests(keep = _rep b2 rename=(b2=Est));
			  %if &p > 3 %then _tests(keep = _rep b3 rename=(b3=Est));
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;
	%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
		%let jj = 0; 		
		data _lests;
		  set _tests(keep = _rep a rename=(a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &p > 1 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b1 rename=(b1=Est));
			   	  %if &p > 2 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b2 rename=(b2=Est));
			  	  %if &p > 3 %then _tests(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep b3 rename=(b3=Est));
			  %end;
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;
		/* eMKF: merge reverse-transformed estimates and variances into fitstat dataset and update */
		data _tfits;
		  merge &out._fitstat _dcovmatt;
		  by _rep ;
		run;
	%end;
	%if %upcase(&nlmixedDetails) ^= YES %then %do;
		data _tfits;
		  set &out._fitstat;
		  by _rep;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	data _tfits;
	  merge _tfits _lests;
	  by _rep Row;
	run;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	data _tfits;
	  set _tfits;
	  if Est ne . then Estimate = Est;
	  %if %upcase(&nlmixedDetails) = YES %then %do;
		  if Var > 0 then StandardError = sqrt(Var);
		  else StandardError = .;
		  tValue = Estimate/StandardError;
		  Probt = (1-probt(abs(tValue), DF))*2;
		  Lower = Estimate + tinv(Alpha/2, DF)*StandardError;
		  Upper = Estimate + tinv(1-Alpha/2, DF)*StandardError;
	  %end;
	  drop Row Est %if %upcase(&nlmixedDetails) = YES %then Var;;
	run;
	data &out._fitstat;
	  set _tfits;
	run;

%end;

/* eMKF: Add labels for stratification variable */
%if &by ^=%str() %then %do;
	data &out._ests;
 	  merge &out._ests _freq_;
 	  by _rep;
	run;
%end;

data &out._ests; /* eMKF: Added parameter estimates for quadratic and cubic terms */
   set &out._ests;
   label _2loglike =" -2 log-likelihood estimate"
	     /* eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied -- they are estimated instead */
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 /* eMKF: Added labels for by variable */
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
	     a="Parameter estimate: intercept (a)"
		 %if &p > 1 %then b1="Parameter estimate: linear term (b1)";
   		 %if &p > 2 %then b2="Parameter estimate: quadratic term (b2)" ;
   		 %if &p > 3 %then b3="Parameter estimate: cubic term (b3)" ; 
    ;
	drop &group %if &by ^= %str() %then &by; ;
run;

data &out._pred; /* eMKF: added a few useful labels */
   set &out._pred(rename=(Predvar=PredOnlyVar HatMSE=PredMSE));
   PredSE= sqrt(PredMSE);
   label _2loglike =" -2 log-likelihood estimate"
	     /* eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied -- they will be estimated instead */
         _rho_ ="Estimated rho of the model"
	     _tausq_="Estimated tau-square of the model"
	     _group_="Model reset group ID in case group is not ordered"
	     &group ="Numeric &&group variable"
		 _rep="Model reset stratum ID in case stratification variable, if any, is not ordered"
	     &by ="&&by variable"
		 &rlag = "Elapsed real time from previous time point"
		 &rtm ="Real time used in calculations "
	     _time ="Time index variable"
	     _y  ="Original outcome"
	     _se ="Original Standard Error"
		 _avgse = "Average Standard Error across timepoints used for imputation"
		 %if &by ^= %str() %then  _avgseb = "Average Standard Error across strata used for imputation";
         impute = "Whether original Standard Error was imputed using average across timepoints"
		 %if &by ^= %str() %then imputeb = "Whether original Standard Error was imputed using average across strata";
		 inputorder = "Original ordering of the groups if it was not alphabetical"
	     prediction="Kalman estimator prediction of the outcome assuming &bvalue trend model"
	     PredMSE="Prediction variability: Mean Squared Error (MSE) assuming &bvalue trend model "
	     PredSE="Prediction standard error: Square root of MSE assuming &bvalue trend model "
		 a="Parameter estimate: intercept (a)"
	     /* eMKF: added labels for parameter estimates for quadratic and cubic terms */
   		 %if &p > 1 %then b1="Parameter estimate: linear term (b1) assuming &bvalue trend model " ;
   		 %if &p > 2 %then b2="Parameter estimate: quadratic term (b2) assuming &bvalue trend model " ;
   		 %if &p > 3 %then b3="Parameter estimate: cubic term (b3) assuming &bvalue trend model " ;
	;
	/* These will be deleted for now. If needed they can be useful. */
   drop mu err delta lambda w gamma Hat_y PredOnlyVar &group group_rep &rlag %if &by ^= %str() %then &by; ; 
run;

/* eMKF: Rename any remaining instances of numeric &group variable to _group_ + remove numeric &by variable */
data &out._predVar;
  set &out._predVar;
  rename &group = _group_;
  %if &by ^= %str() %then drop &by;;
run;
/* eMKF v2.4 streamlining: added option to omit covariance matrices and model diagnostics */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._covY;
	  set &out._covY;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrices and other model details */ 
proc datasets nolist;
 delete _freqn_ _freqg_ _freq_ _sdata_ _beta_ _inits_ _initsr_ _ests _fitstat _convstat _llike_ _empty_ 
        _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_  _Xmat_ _junk_ _junk0_ _junk01_ 
        _oXmat_ _oPmat_ _tests _lests _tfits _tcmat _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt
		%if %upcase(&nlmixedDetails) ^= YES %then &out._H &out._covY &out._covmat &out._fitstat ;
		&out._predVar
        ;
run;
quit;

%mend htrp;

data _null_;
run;


/*HTRP 2D macro
Macro defined 08-27-2010
It allows for the estimation of parameters from the non-linear mixed effect model

Modified for eMKF in 2023 Q1-Q2 by Makram Talih.
Revised for eMKF v2.4 in 2025 Q1 (Makram Talih) to disable user supply of _rho_ and _tausq_ and add heteroskedastic AR options.
In eMKF, this assumes data has been pre-formatted using macro reformat.

data 	: name of the dataset.
outcome : outcome of interest.
se      : standard errors of the outcome.
outcome2 : outcome2 of interest.
se2      : standard errors of outcome2.
time    : time variable.
by      : allows models to run for multiple strata at the same time and can be used for simulations
xtrakeep: Any variable one wants to keep in the data while runing models: weights, ... (eMKF: could be used to retain labels for multiyear data)
orpoly  : (eMKF) YES (default) for pre-transforming the design matrix using SAS IML orpol function. NO for "raw" polynomials.
          If YES, regression coefficients and their SEs will be reverse-transformed prior to macro end.
bvalue  : Assumption about the trend model: eMKF options are the following:
             indep_cubic	: The values of the parameters b1, b2, and b3 are computed for each group
             indep_quad		: b3=0. The values of the parameters b1 and b2 are computed for each group
             indep_linear   : (DEFAULT) b3=0 and b2=0. The value of the slope b1 is computed for each group
             common_cubic	: The values of each of the parameters b1, b2, and b3 are assumed to be the same across groups
             common_quad	: b3=0. The values of each of the parameters b1 and b2 are assumed to be the same across groups
             common_linear  : b3=0 and b2=0. The value of the slope b1 is assumed to be the same across groups
             dropped    	: A model without time trend is computed
ARvalue	: [New in eMKF v2.4] Assumption about the AR(1) model.  Options are:
			 common_ar (default): AR parameters are common across groups; 
		     common_arh			: AR correlation is common but innovation variance parameters are group-specific.
			 indep_ar			: Both AR(1) parameters are group-specific. 
group   : the different groups (e.g., race/ethnicity groups) variable
nlmixedDF: Non-linear model degrees of freedom for proc nlmixed. The default is set pretty high at 10000
nlmixedDetails: (eMKF v2.4 streamlining)(default = NO) option to omit covariance matrix of parameters and other model information.
nlmixedTech:	(eMFK v2.4 streamlining) (default = QUANEW here) added to give user more control over choice of optimization algorithm
print   : Yes will print the nlmixed results and No will not. Default is No
out     : The name of the output baseline. All the following outputs (baseline + suffix) are saved. 
          Here are the suffixes:
          	_fitstat : model fit estimates from the proc nlmixed
          	_ests    : model fit estimates formated for use in the estimation of the Kalman prediction
          	_covmat  : model fit covariance matrix
          	_pred    : Kalman prediction of the outcome of interest includes original values as well as parameters
         (e.g., for OUT=result then RESULT_PRED will be the Kalman prediction data of the outcome of interest. )
*/
%macro htrp2d(data=, 
              outcome=, 
              se=, 
              outcome2=, 
              se2=, 
              group=, 
              time=, 
              by=, 
              xtrakeep= ,
			  orpoly=YES,
              bvalue= indep_linear, 
  			  ARvalue = common_ar,
              nlmixedDF=10000, 
			  nlmixedDetails=NO,
			  nlmixedTech=QUANEW,
              out=param, 
              print=NO
              ) / minoperator; /* eMKF v2.4 streamlining: minoperator keyword allows evaluation of macro IN operator instead of compiling string of OR conditions */

%local formatted dsop dscl g n _rtimess rtm rlag nrep p k d jdelta tline jj tauline rholine b1line b2line b3line i j nlmerr _emkfmu_ _emkfmu2_ 
		group_rep lj amat oPPmat colList1 colList2 ;

/* eMKF: Data assumed to have been pre-formatted using macro reformat: check and reformat if not */
%let formatted = 0;
%let dsop = %sysfunc(open(&data));
%if &dsop ne 0 %then %do;
	%if %sysfunc(varnum(&dsop, inputorder)) ne 0 and %sysfunc(varnum(&dsop, &time)) ne 0 %then %let formatted = 1;
%end; 
%let dscl = %sysfunc(close(&dsop));
%let formatted = %eval(&formatted + 0);

data _sdata_ _jdata_;
run;

%if &formatted = 1 %then %do;
	/* eMKF v2.4 note: recall that _groupnum and _reps are created before HTRP is called from parent MKF macro */
	data _sdata_;
	  set &data;
	run;
%end;
%else %do;
    %put ;
	%put Reformatting data prior to MLE-based estimation;
	%reformat(data=&data, outcome=&outcome, se=&se, outcome2=&outcome2, se2=&se2, group=&group, time=&time, by=&by, outformat= _sdata_);
	/* eMKF: Create copies of _group_ and _rep variables for use in proc iml matrix calculations */
	data _sdata_; 
	  set _sdata_;
	  _groupnum = _group_; 					 
	  %if &by ^= %str() %then _reps = _rep;;
	run;
	/* eMKF: Replace &group and &by macro variables by their numeric versions */
	%let group = _groupnum; 				
	%if &by ^= %str() %then %let by = _reps;;
%end;

/* eMKF: Sort by replications (if any), group, and time */
/* eMKF: Use _time as &time could be empty if data was still in format 1 when htrp was called */
proc sort data= _sdata_;
  by _rep _group_ _time ;
run;

/* eMKF: Macro variable for the number of groups */
%let g=0;
data _freqg_;
run;
proc freq data=_sdata_ noprint;
  tables &group /list out=_freqg_;
run;
data _freqg_;
  set _freqg_;
  _group_ +1;
  call symput('g',_group_);
  keep _group_ &group;
run;
%let g=%eval(0+&g);

/* eMKF: Macro variable for the number of time points */
%let n=0;
data _freqn_;
run;
proc freq data=_sdata_ noprint;
  tables _rtime /list out=_freqn_;
run;
data _freqn_;
  set _freqn_;
  _time +1;
  call symput('n',_time);
  keep _time _rtime;
run;
%let n=%eval(0+&n);

/* eMKF: Macro variable for the real times to use in calculations */
%let _rtimess = ;
data _freqn_;
  set _freqn_;
  retain _rts;
  if _n_= 1 then _rts = cat(_rtime);
  else _rts = catx(" ", _rts, _rtime);
  call symput('_rtimess', _rts);
  drop _rts;
run;

/* eMKF allows for irregular and fractional times points */
/* This is the variable that will be used for real time in case it is not just 1,2,3,... */
%let rtm=_rtime; 		

/* eMKF: macro reformat now also tracks lags between successive real time points */
%let rlag=_rlag;

/* eMKF: Macro variable for the number of replications */
%let nrep=1;
data _freq_;
run;
%if &by ^=%str() %then %do;
	proc freq data=_sdata_ noprint;
	  tables &by /list out=_freq_;
	  format &by ;
	run;
	data _freq_;
	  set _freq_;
	  _rep +1;
	  call symput('nrep',_rep);
	  keep _rep &by;
	run;
%end;
%let nrep=%eval(0+&nrep);

/* eMKF v2.4 streamlining: Error check to make sure there are at least 2 timepoints */
%if (&n < 2) %then %do;
	%put ERROR: htrp2d macro requires at least 2 timepoints. Please review!;
  	%return;
%end;

/* eMKF v2.4 streamlining: moved up definition of dimensionality p for easier referencing of various models instead of using labels */
%let p=0;
%if %upcase(&bvalue) in INDEP_CUBIC COMMON_CUBIC %then %let p = 4;
%if %upcase(&bvalue) in INDEP_QUAD COMMON_QUAD %then %let p = 3;
%if %upcase(&bvalue) in INDEP_LINEAR COMMON_LINEAR %then %let p = 2;
%if %upcase(&bvalue) = DROPPED %then %let p = 1;
%let k = %eval(&p - 1);

/* eMKF v2.4 streamlining: max polynomial rank d-1 to use in orpoly */
%let d = 0;
%if &n > 4 %then %let d = 4;	/* cubic allowed */
%else %do;
	%if &n > 3 %then %let d = 3;	/* quad allowed */
	%else %do;
		%if &n > 2 %then %let d = 2;	/* linear allowed */
		%else %let d = 1;						/* intercepts-only model allowed */
	%end;
%end;
%let d = %eval(0+&d);

/* eMKF v2.4 streamlining: Error check to make sure requested trend models can be fit */
%if &p > &d %then %do;
	%put ERROR: Specified trend model(s) cannot be fit. Please review!;
	%put ERROR- &bvalue was requested, yet there are only enough data for a degree %eval(&d-1) polynomial.; 
  	%return;
%end;

/* Correlation between outcomes*/
/* eMKF v2.4 streamlining: _delta_ can no longer be user-supplied -- it is estimated instead */
%let jdelta=;
proc corr data=_sdata_ outp=aa noprint;
  var _y _y2;
run;
data _null_;
  set aa;
  id+1;
  if id=5 then call symput("jdelta",_y);
run;
/* End of Correlation estimates*/

/* eMKF: Modification to set up orthogonal cubic polynomial design matrix */

data _oXmat_ _oPmat_;
run;

/* eMKF v2.4 streamlining: accounted for max polynomial degree in case of fewer timepoints than 5 */
%if %upcase(&orpoly) = YES %then %do;
	proc iml;
	  x = { &_rtimess };	
	  x = T(x);											/* eMKF: column vector with real times */
	  %if &d = 1 %then oP = orpol(x, 1)[,1];;
	  %if &d > 1 %then oP = orpol(x, &d - 1);;			/* eMKF v2.4: orthonormal design matrix oP */
	  x0 = { %cnstss(1, &n) };
	  x0 = T(x0);
	  %if &n > 2 %then x1 = x;;
	  %if &n > 3 %then x2 = x#x1;;
	  %if &n > 4 %then x3 = x#x2;;
	  uP = x0;										
	  %if &n > 2 %then uP = uP || x1;;	
	  %if &n > 3 %then uP = uP || x2;;	
	  %if &n > 4 %then uP = uP || x3;;					/* eMKF v2.4: raw/unstandardized design matrix s1uP */
	  oP1 = inv(T(uP)*uP)*T(uP)*oP[,1];
      %if &n > 2 %then oP2 = inv(T(uP)*uP)*T(uP)*oP[,2];;
      %if &n > 3 %then oP3 = inv(T(uP)*uP)*T(uP)*oP[,3];;
      %if &n > 4 %then oP4 = inv(T(uP)*uP)*T(uP)*oP[,4];;
	  oPP = oP1;									
	  %if &n > 2 %then oPP = oPP || oP2;;
	  %if &n > 3 %then oPP = oPP || oP3;;
	  %if &n > 4 %then oPP = oPP || oP4;;				/* eMKF: right multiplication of s1uP with s1oPP produces s1oP */
	  y = T(do(1, &n, 1));								/* eMKF: column vector of consecutive time indices */
	  yP = y || oP;
	  /* eMKF v2.4: datasets for later use */
	  %if &d = 4 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1" "&rtm.2" "&rtm.3"} ] ;;
	  %if &d = 3 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1" "&rtm.2"} ] ;;
	  %if &d = 2 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0" "&rtm.1"} ] ;;
	  %if &d = 1 %then create _oXmat_ from yP [ colname = {"_time" "&rtm.0"} ] ;;
	  append from yP; close _oXmat_;
	  %if &d = 4 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2" "t3"} ] ;;
	  %if &d = 3 %then create _oPmat_ from oPP [ colname = {"t0" "t1" "t2"} ] ;;
	  %if &d = 2 %then create _oPmat_ from oPP [ colname = {"t0" "t1"} ] ;;
	  %if &d = 1 %then create _oPmat_ from oPP [ colname = {"t0"} ] ;;
	  append from oPP; close _oPmat_;
	quit;
	proc sort data=_sdata_;
	  by _time;
	run;
	data _sdata_;
	   merge _sdata_ _oXmat_;
	   by _time;
	run;
	proc sort data= _sdata_;
	  by _rep _group_ _time ;
	run;
%end;
%else %do;
	data _sdata_; /* eMKF v2.4: add raw quad and cubic time terms as columns in _sdata_ */
	   set _sdata_;
	   &rtm.0 = 1;
	   %if &d > 1 %then &rtm.1 = &rtm;;
	   %if &d > 2 %then &rtm.2 = &rtm**2;;				
	   %if &d > 3 %then &rtm.3 = &rtm**3;;
	run;
%end;

/* eMKF v2.4 streamlining: accounted for max polynomial degree in case of fewer timepoints than 5 */
data _jdata_;
  set _sdata_(in=a rename=(_y =_oy _se=_ose)) _sdata_(in=b rename=(_y2 =_oy _se2=_ose));
  if a then orep=1;
  if b then orep=2;
  ones 	   = orep - 1;
  onetime0 = &rtm.0 * ones;
  %if &d > 1 %then onetime1 = &rtm.1 * ones;;
  %if &d > 2 %then onetime2 = &rtm.2 * ones;;
  %if &d > 3 %then onetime3 = &rtm.3 * ones;;
run;

/* eMKF v2.4 correction: additional sorting by _rep in case of stratified data */
proc sort data=_jdata_;
  by _rep _group_ orep;
run;

/* eMKF: Set up model statement symbolically for use in proc reg
 * Initial regression when no time trend is desired differs from the original MKF, here.  
 * In MKF, initial values for intercepts were based on those from linear trend model instead of dropped model.
 */
%let tline=;
%if &p = 4 %then %let tline = &rtm.0 onetime0 &rtm.1 onetime1 &rtm.2 onetime2 &rtm.3 onetime3;
%if &p = 3 %then %let tline = &rtm.0 onetime0 &rtm.1 onetime1 &rtm.2 onetime2;
%if &p = 2 %then %let tline = &rtm.0 onetime0 &rtm.1 onetime1;
%if &p = 1 %then %let tline = &rtm.0 onetime0;

/* eMKF: Modified call to proc reg to include quad and cubic terms
 * Implemented regression by _rep instead of relying only on _rep = 1 for initial values to pass to proc nlmixed
 */
proc reg data=_jdata_ outest=_beta_ noprint;
	by _rep _group_ ;
	model _oy = &tline /noint;;
run;

/* Setup initial values (modified for eMKF to hold quad and cubic coefficients)
   Use the beta data estimates from the model above. For &g groups, then:
     ag1-ag&g are the intercept from each of the &g groups models
     b1g1-b1g&g are the linear coefficients from each of the &g groups models
     b2g1-b2g&g are the quadratic coefficients from each of the &g groups models
     b3g1-b3g&g are the cubic coefficients from each of the &g groups models
   eMKF v2.4 also allows for group-specific AR parameters
*/

/* eMKF: Sort regression coefficients by _rep and _group_ */
proc sort data=_beta_;
 by _rep _group_;
run;

/* eMKF: Initial parameter values for the first replication */
%let jj = 1;
data _inits_;
   set _beta_(where=(_rep = &jj)) end=end;
   _rep = &jj;
   array o1ag o1ag1-o1ag&g;
   array o1b1g o1b1g1-o1b1g&g;
   array o1b2g o1b2g1-o1b2g&g;
   array o1b3g o1b3g1-o1b3g&g;
   array o2ag o2ag1-o2ag&g;
   array o2b1g o2b1g1-o2b1g&g;
   array o2b2g o2b2g1-o2b2g&g;
   array o2b3g o2b3g1-o2b3g&g;
   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
   retain o1ag1-o1ag&g o1b1g1-o1b1g&g o1b2g1-o1b2g&g o1b3g1-o1b3g&g o2ag1-o2ag&g o2b1g1-o2b1g&g o2b2g1-o2b2g&g o2b3g1-o2b3g&g
		 %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
		 %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
   ; 
   o1ag{_group_} = &rtm.0; o2ag{_group_} = onetime0;
   %if &p > 1 %then %str( o1b1g{_group_} = &rtm.1; o2b1g{_group_} = onetime1;) ;;
   %if &p > 2 %then %str( o1b2g{_group_} = &rtm.2; o2b2g{_group_} = onetime2;) ;;
   %if &p > 3 %then %str( o1b3g{_group_} = &rtm.3; o2b3g{_group_} = onetime3;) ;;
   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
   if end then do; 
        /* eMKF v2.4 streamlining: _rho_, _tausq_, and _delta_ can no longer be user-supplied: they will be estimated using these initial values instead */
		/* eMKF v2.4 also allows for group-specific AR parameters */
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
		delta= &jdelta  - 1;
      	output;
   end;
   keep _rep o1ag1-o1ag&g o2ag1-o2ag&g o1b1g1-o1b1g&g o2b1g1-o2b1g&g o1b2g1-o1b2g&g o2b2g1-o2b2g&g o1b3g1-o1b3g&g o2b3g1-o2b3g&g
		%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
		%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
		%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
		delta
   ;
run;

/* eMKF: Initial estimates from each subsequent replication */
data _initsr_;
run;
%if &nrep > 1 %then %do;
	%do jj = 2 %to &nrep;
		data _initsr_;
		   set _beta_(where=(_rep = &jj)) end=end;
		   _rep = &jj;
		   array o1ag o1ag1-o1ag&g;
		   array o1b1g o1b1g1-o1b1g&g;
		   array o1b2g o1b2g1-o1b2g&g;
		   array o1b3g o1b3g1-o1b3g&g;
		   array o2ag o2ag1-o2ag&g;
		   array o2b1g o2b1g1-o2b1g&g;
		   array o2b2g o2b2g1-o2b2g&g;
		   array o2b3g o2b3g1-o2b3g&g;
		   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2g logtau2g1-logtau2g&g;;
		   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhog logitrhog1-logitrhog&g;;
		   retain o1ag1-o1ag&g o1b1g1-o1b1g&g o1b2g1-o1b2g&g o1b3g1-o1b3g&g o2ag1-o2ag&g o2b1g1-o2b1g&g o2b2g1-o2b2g&g o2b3g1-o2b3g&g
		  		  %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g1-logtau2g&g; 
				  %if %upcase(&ARvalue) = INDEP_AR %then logitrhog1-logitrhog&g; 
 		   ;
		   o1ag{_group_} = &rtm.0; o2ag{_group_} = onetime0;
		   %if &p > 1 %then %str( o1b1g{_group_} = &rtm.1; o2b1g{_group_} = onetime1;) ;;
		   %if &p > 2 %then %str( o1b2g{_group_} = &rtm.2; o2b2g{_group_} = onetime2;) ;;
		   %if &p > 3 %then %str( o1b3g{_group_} = &rtm.3; o2b3g{_group_} = onetime3;) ;;
		   %if %upcase(&ARvalue) ^= COMMON_AR %then logtau2g{_group_} = log(.002) ;;
		   %if %upcase(&ARvalue) = INDEP_AR %then logitrhog{_group_} = 0 ;; 
		   if end then do; 
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 = log(.002);;
		   		%if %upcase(&ARvalue) ^= INDEP_AR %then logitrho = 0;;
				delta= &jdelta  - 1;
		      	output;
		   end;
		   keep _rep o1ag1-o1ag&g o2ag1-o2ag&g o1b1g1-o1b1g&g o2b1g1-o2b1g&g o1b2g1-o1b2g&g o2b2g1-o2b2g&g o1b3g1-o1b3g&g o2b3g1-o2b3g&g
				%if %upcase(&ARvalue) = COMMON_AR %then logtau2 logitrho; 
				%if %upcase(&ARvalue) = COMMON_ARH %then logtau2g1-logtau2g&g logitrho;
				%if %upcase(&ARvalue) = INDEP_AR %then logtau2g1-logtau2g&g logitrhog1-logitrhog&g;
				delta 
           ;
		run;
		data _inits_;
		  set _inits_ _initsr_;
		run;
		data _initsr_;
		run;
	%end;
%end;

/* eMKF: calculate initial estimates for common_ scenarios and remove extraneous variables */
data _inits_;
  set _inits_;
  o1b1=.; 
  o1b2=.; 
  o1b3=.; 
  o2b1=.;
  o2b2=.;
  o2b3=.;
  %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %str( o1b1 = mean(of o1b1g1-o1b1g&g); o2b1 = mean(of o2b1g1-o2b1g&g);) ;;
  %if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR) %then drop o1b1g1-o1b1g&g o2b1g1-o2b1g&g ;;
  %if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD %then %str( o1b2 = mean(of o1b2g1-o1b2g&g); o2b2 = mean(of o2b2g1-o2b2g&g);) ;;
  %if not(%upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD) %then drop o1b2g1-o1b2g&g o2b2g1-o2b2g&g ;;
  %if %upcase(&bvalue) = COMMON_CUBIC %then %str( o1b3 = mean(of o1b3g1-o1b3g&g); o2b3 = mean(of o2b3g1-o2b3g&g);) ;;
  %if %upcase(&bvalue) ^= INDEP_CUBIC %then drop o1b3g1-o1b3g&g o2b3g1-o2b3g&g ;;
  %if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR) %then drop o1b1 o2b1;;;
  %if not(%upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD) %then drop o1b2 o2b2;;;
  %if %upcase(&bvalue) ^= COMMON_CUBIC %then drop o1b3 o2b3;;;
run;

/* eMKF v2.4: re-order columns in common trend cases so the logitrho and logtau2 remain last and coefficients are grouped by outcome */
%if %upcase(&bvalue) in COMMON_CUBIC COMMON_QUAD COMMON_LINEAR %then %do;
	data _inits_;
	  merge _inits_(drop = o2: logtau2: logitrho: delta) _inits_(keep = _rep o2:) _inits_(keep = _rep logtau2: logitrho: delta);
	  by _rep;
	run;
%end;

/* eMKF v2.4: Set up array declarations for tau and rho parameters symbolically for use in proc nlmixed */
%let tauline=; %let rholine=;
%if %upcase(&ARvalue) ^= COMMON_AR %then %let tauline = array logtau2g(&g) logtau2g1-logtau2g&g%str(;) array _tausq_(&g) _tausq_1-_tausq_&g%str(;) ;
%if %upcase(&ARvalue) = INDEP_AR %then %let rholine= array logitrhog(&g) logitrhog1-logitrhog&g%str(;) array _rho_(&g) _rho_1-_rho_&g%str(;) ; 

/* eMKF: Set up array declarations symbolically for use in proc nlmixed */
%let b1line=; %let b2line=; %let b3line=;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %let b1line= array o1b1g(&g) o1b1g1-o1b1g&g%str(;) array o2b1g(&g) o2b1g1-o2b1g&g%str(;) ;
%if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then %let b2line= array o1b2g(&g) o1b2g1-o1b2g&g%str(;) array o2b2g(&g) o2b2g1-o2b2g&g%str(;) ;
%if %upcase(&bvalue) = INDEP_CUBIC %then %let b3line= array o1b3g(&g) o1b3g1-o1b3g&g%str(;) array o2b3g(&g) o2b3g1-o2b3g&g%str(;) ;

/* eMKF: Set up model statement symbolically for use in proc nlmixed */
/* eMKF v2.4 streamlining: delta can no longer be user-supplied -- it is estimated instead */
%let tline=;
%if %upcase(&bvalue) = INDEP_CUBIC %then /* eMKF v2.4 correction: for indep_cubic, ones column in X matrix replaced with onetime0 */
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1g[_group_] + onetime1*o2b1g[_group_] 
						+ &rtm.2*o1b2g[_group_] + onetime2*o2b2g[_group_] + &rtm.3*o1b3g[_group_] + onetime3*o2b3g[_group_]
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = INDEP_QUAD %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1g[_group_] + onetime1*o2b1g[_group_] 
						+ &rtm.2*o1b2g[_group_] + onetime2*o2b2g[_group_] 
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = INDEP_LINEAR %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1g[_group_] + onetime1*o2b1g[_group_] 
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = COMMON_CUBIC %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1 + onetime1*o2b1 
						+ &rtm.2*o1b2 + onetime2*o2b2 + &rtm.3*o1b3 + onetime3*o2b3
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = COMMON_QUAD %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1 + onetime1*o2b1 
						+ &rtm.2*o1b2 + onetime2*o2b2
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = COMMON_LINEAR %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] + &rtm.1*o1b1 + onetime1*o2b1 
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);
%if %upcase(&bvalue) = DROPPED %then 
	%let tline= normal(&rtm.0*o1ag[_group_] + onetime0*o2ag[_group_] 
						+ gamma[_time] + delta*ones*gamma[_time], _ose**2);

/* Fit a Non-linear mixed model. Capture covariance matrix COV and covariance matrix from additional estimate ECOV */

data _ests _fitstat _convstat &out._fitstat &out._covmat; 	/* eMKF v2.4 streamlining: no longer creating copy of _sdata_ to store in &out._data*/
run;

%put ;
%put Start model fitting using PROC NLMIXED; 				/* eMKF: substituted put statement */

/* eMKF: model print handling */
%if %upcase(&print) ^=YES %then ods exclude all;;

/* eMKF v2.4: initialized counters for use in proc nlmixed */
%let i=0; %let j=0;

/* eMKF v2.4: Error check to make sure specified optimization method is valid */
%if not(%upcase(&nlmixedTech) in CONGRA DBLDOG NEWRAP NMSIMP NONE NRRIDG QUANEW TRUREG) %then %do;
	%put ERROR: proc nlmixed syntax error. Specified optimization algorithm &nlmixedTech not recognized. Please check!;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */
/* eMKF v2.4 streamlining: omitted calculation of reverse-transformed rho and tausq (estimate statements) and ecov */ 
/* eMKF v2.4 now also allows for group-specific AR parameters (_rho_ and _tausq_ can no longer be user-supplied) */
proc nlmixed data=_jdata_ DF=&nlmixedDF %if %upcase(&nlmixedDetails) = YES %then cov; 
	tech=&nlmixedTech						/* eMKF v2.4: can replace default (QUANEW) optimization with other available methods */
	method=firo maxiter=500; 				/* eMKF: increased maxiter to 500 from the 200 default for dealing with cubic */
	by _rep;								/* eMKF: stratified by _rep (trivial if _rep is constant = 1 (i.e., no stratification) */
	array gamma(&n) gamma1-gamma&n; 		/* Give the gamma values a generic name */
	array o1ag(&g) o1ag1-o1ag&g; 			/* Give the a values a generic name */
	array o2ag(&g) o2ag1-o2ag&g; 			/* Give the a values a generic name */
	&b1line;; 						 		/* Give the bl values a generic name */
	&b2line;; 						 		/* eMKF: Give the b2 values a generic name */
	&b3line;; 						 		/* eMKF: Give the b3 values a generic name */ 
	&tauline;;						 		/* eMKF v2.4: group-specific innovation variances (if any) */
	&rholine;;						 		/* eMKF v2.4: group-specific autocorrelation coefficients (if any) */
	%if %upcase(&ARvalue)^=COMMON_AR 
	  %then array nu(&g) nu1-nu&g;; 		/* eMKF v2.4: group-specific stationary variances (if any) */
	parms / bydata data=_inits_; 			/* eMKF: Setup parameters and their initial values stratified by _rep */

	%if %upcase(&ARvalue)=COMMON_AR %then %do; 
		bounds logitrho >= 0;				/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		_tausq_ = exp(logtau2);
		nu = _tausq_/(1-(_rho_**2));
	%end;
	%if %upcase(&ARvalue)=COMMON_ARH %then %do;
		bounds logitrho >= 0;				/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		_rho_ = 2/(1+exp(-logitrho)) - 1;
		%do j = 1 %to &g;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_**2));
		%end;
	%end;
	%if %upcase(&ARvalue)=INDEP_AR %then %do;
		bounds logitrhog1-logitrhog&g >= 0;	/* eMKF v2.4: added restriction so _rho_ remains nonnegative */ 
		%do j = 1 %to &g;
			_rho_&j = 2/(1+exp(-logitrhog&j)) - 1;
			_tausq_&j = exp(logtau2g&j);
			nu&j = _tausq_&j/(1-(_rho_&j**2));
		%end;
	%end;

	/* Random effects gamma1 gamma2 ... gamma&n ~ normal ([0,0,0,..,0],[nu, half triangular matrix]) */
	/* eMKF: Replaced call to thevarcomp with call to thevarcompr to allow noninteger/unequally-spaced time points */
	/* eMKF v2.4 allows for group-specific AR coefficients */
	%if %upcase(&ARvalue) = COMMON_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu, vrho=_rho_)) subject=_group_ out=&out._BLUP;
	%end;
	%if %upcase(&ARvalue) = COMMON_ARH %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_)) subject=_group_ out=&out._BLUP;
	%end;
	%if %upcase(&ARvalue) = INDEP_AR %then %do;
		random %do i = 1 %to &n; gamma&i %end; ~ normal([%zeros(&n)], %thevarcompr(times=&_rtimess, nu=nu[_group_], vrho=_rho_[_group_])) subject=_group_ out=&out._BLUP;
	%end;

	model _oy ~ &tline;;

	/* eMKF v2.4 streamlining: added output for convergence status */
	ods output parameterestimates=_ests fitstatistics=_fitstat convergencestatus=_convstat;
	%if %upcase(&nlmixedDetails) = YES %then ods output CovMatParmEst=&out._covmat;;
run;

/* eMKF v2.4: Error check to make sure proc nlmixed converged */
%let nlmerr = 0;
data _null_;
  set _convstat;
  if Status = 1 then call symput("nlmerr" , 1);
run;
%let nlmerr = %eval(0 + &nlmerr);
%if &nlmerr %then %do;
	%put ERROR: proc nlmixed returned an error. Try specifying an optimization algorithm other than &nlmixedTech.;
  	%return;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model information and test statistics */ 
%if %upcase(&nlmixedDetails) ^= YES %then %do;
	data _ests;
	  set _ests;
	  drop StandardError DF tValue Probt Alpha Lower Upper Gradient;
	run;
%end;

/* eMKF: Replace missing values in CovMatParmEst with 0s for later use */
%if %upcase(&nlmixedDetails) = YES and %upcase(&orpoly) = YES %then %do;
	data &out._covmat;
	  set &out._covmat;
	  array NAs _numeric_;
	  do over NAs;
	      if NAs = . then NAs = 0;
	  end;
	run;
%end;

/* eMKF: Reset ODS destinations if they were turned off */
%if %upcase(&print) ^=YES %then ods exclude none;;

/* eMKF: Added put statements for log */
%put ;
%put End model fitting using PROC NLMIXED;
%if %upcase(&print) ^= YES %then %put Model printout was turned off by user.;;

/* eMKF: Model estimates */
data _fitstat;
   set _fitstat;
   if descr = "-2 Log Likelihood";
   _2loglike=value;
   keep _2loglike _rep;
run;
data &out._fitstat;
   merge _ests _fitstat;
   by _rep;
run;
data _llike_;
run;
data _llike_;
 set &out._fitstat;
 by _rep;
 if first._rep then output;
 keep _rep _2loglike;
run;
data &out._ests;
run;
proc transpose data=&out._fitstat out=&out._ests;
   by _rep;
   var estimate;
   id parameter;
run;

/* eMKF v2.4 streamlining: _emkfmu_ and _emkfmu2_ track the means; _emkfkeep_ is now defunct; p will be used to track which coefficients to keep */
%let _emkfmu_ = ; %let _emkfmu2_ = ;
%if &p = 4 %then %do;
	%let _emkfmu_ = mu = o1a*&rtm.0 + o1b1*&rtm.1 + o1b2*&rtm.2 + o1b3*&rtm.3;
	%let _emkfmu2_ = mu2 = o2a*&rtm.0 + o2b1*&rtm.1 + o2b2*&rtm.2 + o2b3*&rtm.3;
%end;
%if &p = 3 %then %do;
	%let _emkfmu_ = mu = o1a*&rtm.0 + o1b1*&rtm.1 + o1b2*&rtm.2;
	%let _emkfmu2_ = mu2 = o2a*&rtm.0 + o2b1*&rtm.1 + o2b2*&rtm.2;
%end;
%if &p = 2 %then %do;
	%let _emkfmu_ = mu = o1a*&rtm.0 + o1b1*&rtm.1;
	%let _emkfmu2_ = mu2 = o2a*&rtm.0 + o2b1*&rtm.1;
%end;
%if &p = 1 %then %do;
	%let _emkfmu_ = mu  = o1a*&rtm.0; 
	%let _emkfmu2_ = mu2 = o2a*&rtm.0;
%end;

/* eMKF: Re-structure estimates by _rep and _group_ */
data &out._ests;
   merge &out._ests _llike_;
   by _rep;
   array o1as o1ag1-o1ag&g;
   array o2as o2ag1-o2ag&g;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %str(array o1b1s o1b1g1-o1b1g&g; array o2b1s o2b1g1-o2b1g&g;);;
   %if %upcase(&bvalue) = DROPPED %then %str(o1b1 = 0; o2b1 = 0;);;
   %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then %str(array o1b2s o1b2g1-o1b2g&g; array o2b2s o2b2g1-o2b2g&g;);;
   %if %upcase(&bvalue) = DROPPED %then %str(o1b2 = 0; o2b2 = 0;);;
   %if %upcase(&bvalue) = INDEP_CUBIC %then %str(array o1b3s o1b3g1-o1b3g&g; array o2b3s o2b3g1-o2b3g&g;);;
   %if %upcase(&bvalue) = DROPPED %then %str(o1b3 = 0; o2b3 = 0;);;
   /* eMKF v2.4 allows for group-specific AR coefficients */
   %if %upcase(&ARvalue) ^= COMMON_AR %then array logtau2s logtau2g1-logtau2g&g ;;
   %if %upcase(&ARvalue) = COMMON_AR %then _tausq_ = exp(logtau2) ;; 
   %if %upcase(&ARvalue) = INDEP_AR %then array logitrhos logitrhog1-logitrhog&g ;;
   %if %upcase(&ARvalue) ^= INDEP_AR %then _rho_ = 2/(1+exp(-logitrho))-1 ;;
   do _group_ = 1 to &g;
      o1a = o1as{_group_};
      o2a = o2as{_group_};
      %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD INDEP_LINEAR %then %str(o1b1 = o1b1s{_group_}; o2b1 = o2b1s{_group_};);;
	  %if %upcase(&bvalue) in INDEP_CUBIC INDEP_QUAD %then %str(o1b2 = o1b2s{_group_}; o2b2 = o2b2s{_group_};);;
      %if %upcase(&bvalue) = INDEP_CUBIC %then %str(o1b3 = o1b3s{_group_}; o2b3 = o2b3s{_group_};);;
	  %if %upcase(&ARvalue) ^= COMMON_AR %then _tausq_ = exp(logtau2s{_group_}) ;;
	  %if %upcase(&ARvalue) = INDEP_AR %then _rho_ = 2/(1+exp(-logitrhos{_group_}))-1 ;;
      output;
   end;
  /* eMKF v2.4 streamlining: used &p (and &k = &p-1) instead of &_emkfkeep_ to track which coefficients to keep */
  keep _rep _group_ o1a o2a %if &p > 1 %then o1b1-o1b&k o2b1-o2b&k ; _tausq_ _rho_ delta _2loglike;
run;

/* eMKF v2.4 streamlining: reordered columns here and used &p (and &k = &p-1) instead of &_emkfkeep_ to track which coefficients to keep */
data &out._ests; 
  merge &out._ests(keep= _rep _group_)
		&out._ests(keep= o1a) %if &p > 1 %then &out._ests(keep= o1b1-o1b&k); 
		&out._ests(keep= o2a) %if &p > 1 %then &out._ests(keep= o2b1-o2b&k);
		&out._ests(keep= _tausq_) &out._ests(keep= _rho_) &out._ests(keep= delta) &out._ests(keep= _2loglike) ;
run;

/* eMKF: Reset contrasts to get outcome-specific estimates */
data &out._ests;
  set &out._ests;
  o2a = o2a + o1a;
  %if &p > 1 %then %str(o2b1 = o2b1 + o1b1;);;
  %if &p > 2 %then %str(o2b2 = o2b2 + o1b2;);;
  %if &p > 3 %then %str(o2b3 = o2b3 + o1b3;);;
  delta = 1 + delta;
run;

/* eMKF: Merge with group labels */
proc sort data= &out._ests;
 by _group_ ;
run;
proc sort data=_freqg_;
 by _group_;
run;
data &out._ests;
 merge &out._ests _freqg_;
  by _group_;
run;

/***************************************************************************/
/* Now let's use the Kalman technique to estimate the outcome observations */
/***************************************************************************/

data &out._pred;
run;
proc sort data=_sdata_ out=&out._pred;
  by _rep _group_ _time;
run;

proc sort data=&out._ests;
  by _rep _group_;
run;

data &out._pred;
  merge &out._pred &out._ests;
  by _rep _group_ ;
  &_emkfmu_;; 		/* eMKF: invoke symbolic calculation for mu */
  err=_y - mu;
  &_emkfmu2_;; 		/* eMKF: invoke symbolic calculation for mu2 */
  err2=_y2 - mu2;
  _tausq2_= _tausq_ * (delta**2);
  _rho2_= _rho_ ;; * delta ; *This was a mistake that was fixed but need to be double checked again ;
  err3 = (err + (err2/delta) )/2;  *Add this one to use the KF on combined errors;
  _se3 = sqrt((_se**2 + (_se2/delta)**2 )/2); * The new addition;
  /* These next steps are only needed if we assume the same AR(1) processes up to a scale. */
  /* For now, we are relaxing that assumption that both series only help estimate rho. */
  *_se=_se3; 
  *_se2 = delta*_se3; /* Reset standard error out assumption */
  *err=err3; 
  *err2=delta*err3;
  rename delta=moddelta;
run;

data _empty_;
  set &out._pred;
  if _time=1;
  w01 = _tausq_/(1-(_rho_**2));
  gamma01 = 0 ;
  w02 = _tausq2_/(1-(_rho2_**2));
  gamma02 = 0 ;
  _time=0;
  &rtm = 0;
  &rlag = .;
  keep _time &rtm 	/* eMKF v2.4 streamlining: modified to condition on polynomial rank */
		&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3;
		&rlag &by _rep &group _group_ w01 gamma01 w02 gamma02;
run;

data &out._pred;
 set &out._pred _empty_;
 if _time = 1 then &rlag = 1;	/* eMKF: set to lag 1 instead of missing relative to time 0 */
run;

proc sort data=&out._pred;
 by _rep _group_ _time;
run;

/* eMKF recursion formulas modified to allow lag s > 0 between time points */
data &out._pred;
  set &out._pred;
  retain wold gamold wold2 gamold2;
  delta = ((_rho_**(2*&rlag)) * wold) + _tausq_*(1 - (_rho_**(2*&rlag)))/(1 - (_rho_**2));
  if &rlag > 0 or &rlag = . then lambda = delta/(delta + (_se**2));
  else lambda = 0; 				/* eMKF: in the limiting case, recursion breaks down: set lambda = 0 instead */
  w = delta * (1-lambda);
  gamma = (lambda* err) + (1-lambda)*(_rho_**&rlag)*gamold ; /* eMKF: &rlag=1 reduces to unit-increment case */
  prediction = mu + gamma ;
  delta2 = ((_rho2_**(2*&rlag)) * wold2) + _tausq2_*(1 - (_rho2_**(2*&rlag)))/(1 - (_rho2_**2));
  if &rlag > 0 or &rlag = . then lambda2 = delta2/(delta2 + (_se2**2));
  else lambda2 = 0;
  w2 = delta2 * (1-lambda2);
  gamma2 = (lambda2* err2) + (1-lambda2)*(_rho2_**&rlag)* gamold2 ;
  prediction2 = mu2 + gamma2 ;
  output;
  if _time =0 then do;
 	 wold=w01;
	 gamold=gamma01;
	 wold2=w02;
	 gamold2=gamma02;
  end;
  if _time ^=0 then do;
 	 wold=w;
  	 gamold=gamma;
	 wold2=w2;
 	 gamold2=gamma2;
  end;
run;

/* eMKF v2.4 correction: added hyphen separator between _rep and _group_ to cover cases with more than 10 reps or groups (e.g., 1-11 vs 11-1) */
%let group_rep = compress(_rep ||"-"|| _group_);

data &out._pred;
  set &out._pred;
  group_rep= &group_rep;
  if _time ne 0;
  drop w01 gamma01 wold gamold w02 gamma02 wold2 gamold2 ;
run;

/* Let's re-estimate gamma as a weighted linear combination of the two gamma and use that for prediction:
 For now, let's use weight =1/2 according to the assumption of no covariance between the gammas and 
 that the variances are the same: If different variance, then we should use 
 \lambda= (1/sigma1)/(1/sigma1 +1/sigma2) and gamma= lambda gamma1 + (1- lambda) gamma2.
*/
data &out._pred;
  set &out._pred;
  gammaeff= (gamma + (gamma2 / moddelta))/2; *Take the average for now;
  predeff = mu + gammaeff ;
  predeff2 = mu2 + (moddelta*gamma2) ;
run;

/* eMKF: reset lag for time 1 to missing */
data &out._pred;
  set &out._pred;
  if _time = 1 then &rlag = .; 
run;

/******************/
/* Compute the MSE*/
/******************/

data _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_  _Xmat_ _junk_ _junk0_ _junk01_;
run;

proc sort data=&out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4 streamlining: modified to condition on polynomial rank */
								&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
								&rlag _y _se _y2 _se2 _rho_ _rho2_ _tausq_ _tausq2_ err err2 lambda lambda2 prediction prediction2 group_rep)
  out=_Amat_ ;
  by group_rep;
run;

data _Amat_;
  set _Amat_; 
  by group_rep;
  array hs ah1 - ah&n (%zeross(&n) );
  array o2hs o2ah1 - o2ah&n (%zeross(&n) );
  if first.group_rep then do _k=1 to &n; hs{_k}=0; o2hs{_k}=0; end;
  if _time = 1 then do; ah1=lambda; o2ah1=lambda2; end;
  else do;
  	do _j=1 to _time -1; 		/* eMKF: updated to account for &rlag if not 1 */
	    hs{_j} 	 = hs{_j}  *(1-lambda) *(_rho_**&rlag) ;
	    o2hs{_j} = o2hs{_j}*(1-lambda2)*(_rho2_**&rlag) ;
  	end;
  	hs{_time}	= lambda;
  	o2hs{_time} = lambda2;
 end;

 drop group_rep _k _j;
 keep _rep &by _group_ &group _time &rtm &rlag ah: o2ah:;
run;

proc sort data=_Amat_;
 by _rep _group_ _time  ;
run;

/* Attach row number _id to each of the A Matrix so that when computing group by group the appropriate Ag could be called*/
data _Amat_;
  set _Amat_;
  _id+1;
run;

data _Dmat_;
  set &out._pred(keep= _rep &by _group_ &group _time &rtm /* eMKF v2.4 streamlining: modified to condition on polynomial rank */
						&rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
						&rlag _y _y2 _rho_ _rho2_ _tausq_ _tausq2_ _se _se2);
  w0   = _tausq_ /(1- (_rho_**2));
  o2w0 = _tausq2_/(1- (_rho2_**2));
run;

/* The Matrix _Dmat_ is actually the same within group and within replication*/
proc sort data= _Dmat_ nodupkey;
  by _rep _group_ _time;
run;

/* Here the standard error is the same from one replication to another by different from group to group. 
   So these matrices should just be estimated differently for each group as well as replication if possible */
data _Vmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array o2ad o2ad1-o2ad&n;
  array rt rt1-rt&n (&_rtimess); 				/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
  	 if i = _time then do;  					/* Add the variances of Y to the diagonal elements */
		ad{i}  =   w0 + _se**2; 
		o2ad{i}= o2w0 + _se2**2; 
 	 end;
  	 else do; 
		ad{i}  =   w0*( _rho_**abs(rt{i} - &rtm));  
		o2ad{i}= o2w0*(_rho2_**abs(rt{i} - &rtm)); 
	 end;
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n o2ad1-o2ad&n;
run;

/* Recreate the variance where only the Variance of gamma is estimated.
   This is mostly needed for check of what the estimates are giving us. */
data _Vgmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array o2ad o2ad1-o2ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
  	 if i = _time then do; 
		ad{i}  =   w0 ; 
		o2ad{i}= o2w0 ; 
 	 end;
  	 else do; 
		ad{i}  =   w0*( _rho_**abs(rt{i} - &rtm));  
		o2ad{i}= o2w0*(_rho2_**abs(rt{i} - &rtm)); 
	 end;
  end;
  drop i rt1-rt&n;
  keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n o2ad1-o2ad&n;
run;

/* This is the diagonal Variance matrix of the errors */
data _Vemat_;
 set _Dmat_;
 array ad ad1-ad&n;
 array o2ad o2ad1-o2ad&n;
 do i=1 to &n;
 	if i=_time then do; 
		ad{i}= _se**2; 
		o2ad{i}= _se2**2;   
	end;
  	else do; 
		ad{i}=0; 
		o2ad{i}=0; 
	end;
 end;
 drop i;
 keep _rep &by _group_ &group _time &rtm &rlag ad1-ad&n o2ad1-o2ad&n;
run;

/* This is just like the _Vgmat_ but with extra variables kept to be used later for the creation of the X matrix for example*/
data _Dmat_;
  set _Dmat_;
  array ad ad1-ad&n;
  array o2ad o2ad1-o2ad&n;
  array rt rt1-rt&n (&_rtimess); 	/* eMKF: modification to deal with irregular time points */
  do i=1 to &n;
  	 if i = _time then do; 
		ad{i}  =   w0 ; 
		o2ad{i}= o2w0 ; 
 	 end;
  	 else do; 
		ad{i}  =   w0*( _rho_**abs(rt{i} - &rtm));  
		o2ad{i}= o2w0*(_rho2_**abs(rt{i} - &rtm)); 
	 end;
  end;
  drop i rt1-rt&n;
run;

/* This is the X matrix */
data _Xmat_;
  set _Dmat_;
  /* eMKF v2.4 streamlining: modification to deal with orthogonal polynomials now also accounts for polynomial degree */
  x0 = &rtm.0; 
  %if &d > 1 %then x1 = &rtm.1;;
  %if &d > 2 %then x2 = &rtm.2;;
  %if &d > 3 %then x3 = &rtm.3;;
  keep _rep &by _group_ &group 
		x0 %if &d > 1 %then x1; %if &d > 2 %then x2; %if &d > 3 %then x3;
  ;
run;

data &out._H &out._PredVar &out._CovY;
run;

/********************************************************************************************************************************/
/* eMKF v2.4 streamlining: Removed portion of code that pertained to symbolic matrix operations redundant with use of proc iml  */
/*                         Those symbolic operations were stored in defunct macro variables iis, vmatinv, vmat, xmat, and blmat */
/********************************************************************************************************************************/

/* Now let's capture the A Matrix and turn it into a diagonal block matrix  */

data _junk_;
  set _Amat_;
  by _rep;
  if first._rep then sid=0;
  sid+1;
  repgrp=&group_rep; /* eMKF v2.4 streamlining: repgrp assigned value of macro variable &group_rep */
run;

proc sort data=_junk_;
  by repgrp sid;
run;

data _junk_;
  set _junk_;
  by repgrp;
  if first.repgrp then kp=1;
  if last.repgrp then kp=2;
  if kp=1 or kp=2;
  keep _rep &by _group_ &group _time &rtm &rlag sid kp repgrp; /* eMKF: also keeping &rtm and &rlag */
run;

data _junk_;
  set _junk_;
  by repgrp;
  retain minid maxid;
  array Aid(1:2) minid maxid;
  if first.repgrp then do;
    do i = 1 to 2;
      Aid[i] = .; /*initializing to missing*/
    end;
  end;
  Aid(kp) = sid; 
  if last.repgrp then output; 
  drop kp sid i;
run;

proc sort data=_junk_;
  by _rep _group_ _time;
run;

%let jj = 0; %let lj = 0;
data _junk_;
  set _junk_;
  by _rep;
  mm=0;
  if last._rep then mm=1;
  amat=compress("Z["||minid||":"||maxid||",]"); 			/* Here Z will be the standard matrix definition that can be used */
  if mm=0 then amat=compress(amat||",");
  if first._rep or mm=0 then amat=compress("block("||amat); /* eMKF: modified to allow for arbitrary number of groups */
  call symput("jj", _n_);
  if last._rep then call symput("lj", length(amat));		/* eMKF: added to capture maximal length of character variable needed */
run;

/* eMKF: modification to allow for arbitrary number of groups (function block restricted to 15) */
data _junk_;
  set _junk_;
  if _n_=&jj then mm=2;
  length amat2 $ %eval(&g+&lj+10);							/* eMKF: set large enough character length to cover block( + lj + g times ) */
  amat2 = amat;
  %if &g = 1 %then %do;
  	  if mm=1 then amat2=compress(amat||") ");
  	  if mm=2 then amat2=compress(amat||") ");
  %end;
  %if &g > 1 %then %do;
      if mm=1 then amat2=compress(amat||repeat(") ", &g-2));
      if mm=2 then amat2=compress(amat||repeat(") ", &g-2));
  %end;
  drop amat;
  rename amat2 = amat;
run;

proc sort data=_junk_;
  by _rep _group_;
run;

data _junk_;
  set _junk_;
  name=compress("&group"||_group_);
run;

data _junk0_ _junk01_;
run;

proc transpose data=_junk_(keep=name _rep &by amat) out=_junk0_;
  var amat;
  by _rep;
  id name;
run;

proc sort data=_junk_ out=_junk01_ nodupkey;
 by _group_;
run;

%let amat=;
proc sql noprint;
   select name into :amat separated by ' || ' from _junk01_;
quit;

data _junk0_;
  set _junk0_;
  i+1;
  code=compress("Z"||i);
  mcode=compress("_Z"||i);
  amat=compress(code||"="||&amat);
  keep amat _rep  code mcode;
run;

%let jj=0;
%do jj=1 %to &nrep;
	%local _Z&jj ;
%end;

data _null_;
  set _junk0_;
  call symput(mcode,amat);
run;

%let jj=0;

proc iml;

	 %do jj=1 %to &nrep;

		/* Next for the Xmatrix */
		/* eMKF: modified to allow for quadratic and cubic trend models */
		use _Xmat_(where=(_rep=&jj) keep= _rep x:);
		read all into XX; close _Xmat_; /* eMKF: added close statements for cleanliness */
		Z =XX[,2:(1+&p)];
		&&_Z&jj ;;
	 	Xs = Z&jj;

		/* Next for the V matrix */
		use _Vmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VV; close _Vmat_;
		Z =VV[,2:(1+&n)]; 				/* eMKF v2.4 streamlining: replaced previously used macro variables &n1=2 and &n2=1+&n with their values */
		&&_Z&jj ;;
		Vs = Z&jj;
		invVs=inv(Vs);

		/* The o2V matrix for outcome 2*/
		use _Vmat_(where=(_rep=&jj) keep= _rep o2ad:);
		read all into o2VV; close _Vmat_;
		Z =o2VV[,2:(1+&n)];
		&&_Z&jj ;;
		o2Vs = Z&jj;
		invo2Vs=inv(o2Vs);

		/* Next for the Ve matrix */
		use _Vemat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVe; close _Vemat_;
		Z =VVe[,2:(1+&n)];
		&&_Z&jj ;;
		Ves = Z&jj;

		/* The Ve matrix for outcome 2*/
		use _Vemat_(where=(_rep=&jj) keep= _rep o2ad:);
		read all into o2VVe; close _Vemat_;
		Z =o2VVe[,2:(1+&n)];
		&&_Z&jj ;;
		o2Ves = Z&jj;

		/* Next for the Vg matrix */
		use _Vgmat_(where=(_rep=&jj) keep= _rep ad:);
		read all into VVg; close _Vgmat_;
		Z =VVg[,2:(1+&n)];
		&&_Z&jj ;;
		Vgs = Z&jj;

		/* The Vg matrix for outcome 2*/
		use _Vgmat_(where=(_rep=&jj) keep= _rep o2ad:);
		read all into o2VVg; close _Vgmat_;
		Z =o2VVg[,2:(1+&n)];
		&&_Z&jj ;;
		o2Vgs = Z&jj;

		/* Next for the A matrix */
		use _Amat_(where=(_rep=&jj)  keep= _rep ah:);
		read all into AA; close _Amat_;
		Z =AA[,2:(1+&n)];
		&&_Z&jj ;;
		As = Z&jj;

		/* The A matrix for outcome 2*/
		use _Amat_(where=(_rep=&jj)  keep= _rep o2ah:);
		read all into o2AA; close _Amat_;
		Z =o2AA[,2:(1+&n)];
		&&_Z&jj ;;
		o2As = Z&jj;

		/* Next for the data label matrix */
		use _Dmat_(where=(_rep=&jj) keep=_rep &by &group &rtm _time _y _se _y2 _se2); 	/* eMKF: also keeping &rtm */
		read all var{_y} into Y;
		read all var{_y2} into o2Y;
		read all var{_rep &by &group &rtm _time} into NM;
		close _Dmat_;

		/* Now do the estimations */
		i_&n = i(&n*&g);
		H = Xs * inv(t(Xs)*invVs*Xs)*t(Xs)*invVs;
		fH = H + As*(i_&n - H);
		fY = fH * Y;
		Vy = vecdiag(fH * Vs * t(fH));
		MSEy = vecdiag(  (fH - i_&n) * Vgs * t(fH - i_&n)   ) + vecdiag(fH * Ves * t(fH));

		/* Then for outcome 2 */
		o2H = Xs * inv(t(Xs)*invo2Vs*Xs)*t(Xs)*invo2Vs;
		fo2H = o2H + o2As*(i_&n - o2H);
		fo2Y = fo2H * o2Y;
		Vo2y = vecdiag(fo2H * o2Vs * t(fo2H));
		MSEo2y = vecdiag(  (fo2H - i_&n) * o2Vgs * t(fo2H - i_&n)   ) + vecdiag(fo2H * o2Ves * t(fo2H));

		ff= NM || fH;
		o2ff= NM || fo2H;
		fV= NM || Vs;
		o2fV= NM || o2Vs;

		fVy=NM || fY || Vy || MSEy || fo2Y || Vo2y || MSEo2y;

		%if &jj = 1 %then ffs= ff;;
		%if &jj = 1 %then o2ffs= o2ff;;
		%if &jj = 1 %then fVs= fV;;
		%if &jj = 1 %then o2fVs= o2fV;;
		%if &jj = 1 %then fVys= fVy;;
		%if &jj > 1 %then ffs= ffs // ff;;
		%if &jj > 1 %then o2ffs= o2ffs // o2ff;;
		%if &jj > 1 %then fVs= fVs // fV;;
		%if &jj > 1 %then o2fVs= o2fVs // o2fV;;
		%if &jj > 1 %then fVys= fVys // fVy;;

	 %end;

	 /* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	 %if %upcase(&nlmixedDetails) = YES %then %do;
		 create &out._H from ffs ;
		 append from ffs; close &out._H;
		 create &out._o2H from o2ffs ;
		 append from o2ffs; close &out._o2H;
		 create &out._CovY from fVs ;
		 append from fVs; close &out._CovY;
		 create &out._o2CovY from o2fVs ;
		 append from o2fVs; close &out._o2CovY;
	 %end;

	 %if &by ^=%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&by" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE" "Hat_y2" "PredVar2" "HatMSE2"} ];;;
	 %if &by  =%str() %then create &out._PredVar from fVys [ colname = {"_rep" "&group" "&rtm" "_time" "Hat_y" "PredVar" "HatMSE" "Hat_y2" "PredVar2" "HatMSE2"} ];;;
	 append from fVys; close &out._PredVar;

quit; /* eMKF: ends call to proc iml with matrix calculations */

/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H; 			/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4= &rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep 		   col2= &group col3= &rtm col4=_time;;;
	run;
	data &out._o2H;
	  set &out._o2H;
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4= &rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep 		   col2= &group col3= &rtm col4=_time;;;
	run;
	data &out._CovY;
	  set &out._CovY;		/* eMKF: column names */
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4= &rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep 		   col2= &group col3= &rtm col4=_time;;;
	run;
	data &out._o2CovY;
	  set &out._o2CovY;
	  %if &by ^=%str() %then rename col1=_rep col2=&by col3= &group col4= &rtm col5=_time;;;
	  %if &by  =%str() %then rename col1=_rep 		   col2= &group col3= &rtm col4=_time;;;
	run;
%end;

/* eMKF: merge with predictions dataset */
data &out._pred;
  merge &out._pred &out._PredVar;
  by _rep &group _time;
  /* eMKF v2.4 streamlining: remove polynomial time terms from &out._pre, modified to condition on polynomial rank */ 
  drop &rtm.0 %if &d > 1 %then &rtm.1; %if &d > 2 %then &rtm.2; %if &d > 3 %then &rtm.3; 
  ;
run;

/* eMKF: BLUP estimation results */
data &out._BLUP;
  set &out._BLUP;
  _l2 = length(effect)-5;
  _time = 1*substr(effect,6,_l2);
  rename estimate=gamma_blup stderrpred=gamma_se;
  drop _l2;
run;

/* eMKF: sort and merge with predictions dataset */
proc sort data=&out._BLUP;
  by _rep _group_ _time;
run;
proc sort data=&out._pred;
  by _rep _group_ _time;
run;
data &out._pred; 
  merge &out._pred &out._BLUP(keep=_rep _group_ _time gamma_blup gamma_se);
  by  _rep _group_ _time;
  pred_blup = mu + gamma_blup ;
  pred_blup2 = mu2 + (moddelta*gamma_blup) ;
  label gamma_blup = " BLUP estimate of gamma from NLMIXED"
        gamma_se   = " Standard error of the BLUP estimate of gamma from NLMIXED"
        pred_blup  = "Outcome &outcome prediction using the BLUP estimate of gamma from NLMIXED"
        pred_blup2 = "Outcome &outcome2 prediction using the BLUP estimate of gamma from NLMIXED"
  ;
run;

/************************/
/* End of MSE estimation*/
/************************/

/*************************************************************************/
/* eMKF: Reverse-transform regression coefficients and covariance matrix */
/*************************************************************************/

data _tests1 _tests2 _lests _tfits _tcmat1 _tcmat2 _covmat1 _covmat2 _covmat12 _covmat21 
	 _covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt ;
run;

%if %upcase(&orpoly) = YES %then %do;

	/* eMKF: reverse-transform regression coefficients */
	%let jj = 0; 
	proc iml;
		use _oPmat_;
		read all into oPP; close _oPmat_;
		oPP = oPP[1:&p, 1:&p];
		/* Outcome 1 */
		varNames = {"_rep" "_group_" "o1a" };
		%if &p > 1 %then %do;
			o1bNames = "o1b1":"o1b&k";	
			varNames = varNames || o1bNames;
		%end;
		create _tests1 var varNames;
		%do jj=1 %to &nrep;
			use &out._ests(where=(_rep = &jj) keep= _rep _group_ o1: ); /* eMKF v2.4 streamlining: used o1: to reference both o1a and o1b: */
			read all into oB; close &out._ests;
			oB1 = oB[,1:2];
            oB = T(oB[,3:(2+&p)]);
            oBB = oPP * oB;
			oBB = T(oBB);
			oBB = oB1 || oBB;
			append from oBB;
		%end;
		close _tests1;
		/* Outcome 2 */
		varNames = {"_rep" "_group_" "o2a" };
		%if &p > 1 %then %do;
			o1bNames = "o2b1":"o2b&k";	
			varNames = varNames || o1bNames;
		%end;
		create _tests2 var varNames;
		%do jj=1 %to &nrep;
			use &out._ests(where=(_rep = &jj) keep= _rep _group_ o2: ); /* eMKF v2.4 streamlining: used o2: to reference both o2a and o2b: */
			read all into oB; close &out._ests;
			oB1 = oB[,1:2];
            oB = T(oB[,3:(2+&p)]);
            oBB = oPP * oB;
			oBB = T(oBB);
			oBB = oB1 || oBB;
			append from oBB;
		%end;
		close _tests2;
	quit;

	/* eMKF: sort by _rep and _group_ */
	proc sort data=_tests1;
  	  by _rep _group_ ;
	run;
	proc sort data=_tests2;
  	  by _rep _group_ ;
	run;

	/* eMKF: update estimates dataset */
	data &out._ests;
  	  merge _tests1 _tests2 &out._ests(drop= o1: o2:) ; /* eMKF v2.4 streamlining: used o1: (o2:) to reference entirety of outcome 1 (2) estimates */
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: update predictions dataset with columns re-ordered for consistency */
	data &out._pred;
  	  merge &out._pred(drop= o1: o2: /* eMKF v2.4 streamlining: used o1: (o2:) to reference entirety of outcome 1 (2) estimates */
							moddelta _rho_ _tausq_ _2loglike mu err mu2 err2 _tausq2_ _rho2_ err3 _se3 delta lambda
							w gamma prediction delta2 lambda2 w2 gamma2 prediction2 group_rep gammaeff predeff predeff2 
							Hat_y PredVar HatMSE Hat_y2 PredVar2 HatMSE2 gamma_blup gamma_se pred_blup pred_blup2) 
			_tests1 _tests2
			&out._pred(keep=_rep _group_ 
							moddelta _rho_ _tausq_ _2loglike mu err mu2 err2 _tausq2_ _rho2_ err3 _se3 delta lambda
							w gamma prediction delta2 lambda2 w2 gamma2 prediction2 group_rep gammaeff predeff predeff2 
							Hat_y PredVar HatMSE Hat_y2 PredVar2 HatMSE2 gamma_blup gamma_se pred_blup pred_blup2) 
	  		;
	  by _rep _group_;
	run;

	/* eMKF v2.4 streamlining: added option to omit covariance matrix of parameters and other model details */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;

		/* eMKF: symbolic set up for reverse-transformation of covariance matrix */
		%let oPPmat = ; %let i = 0;
		%do i=1 %to &g;  /* eMKF: block diagonal by group */
			%if &i = 1 %then %let oPPmat = block( oP ;
			%if &i > 1 and &i < &g %then %let oPPmat = &oPPmat , block ( oP ;
			%if &i = &g and &g > 1  %then %let oPPmat = &oPPmat , oP %sysfunc(repeat( %str(%)), &g-2));
			%if &i = &g and &g = 1  %then %let oPPmat = &oPPmat );
		%end;
		/* eMKF v2.4 streamlining: removed code that refered to row names symbolically (via parList1 and parList2) and used substring matching instead when possible */
		%let colList1 = ; %let colList2 = ; %let i = 0;
		%do i=1 %to &g; /* eMKF: column and row labels sorted by group */
			%let colList1 = &colList1 o1ag&i;
			%let colList2 = &colList2 o2ag&i;
			%if %upcase(&bvalue) in INDEP_LINEAR INDEP_QUAD INDEP_CUBIC %then %do;
				%let colList1 = &colList1 o1b1g&i;
				%let colList2 = &colList2 o2b1g&i;
			%end;
			%if %upcase(&bvalue) in INDEP_QUAD INDEP_CUBIC %then %do;
				%let colList1 = &colList1 o1b2g&i;
				%let colList2 = &colList2 o2b2g&i;
			%end;
			%if %upcase(&bvalue) = INDEP_CUBIC %then %do;
				%let colList1 = &colList1 o1b3g&i;
				%let colList2 = &colList2 o2b3g&i;
			%end;
		%end;
		%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
			%let colList1 = &colList1 o1b1;
			%let colList2 = &colList2 o2b1;
		%end;
		%if %upcase(&bvalue) in COMMON_QUAD COMMON_CUBIC %then %do;
			%let colList1 = &colList1 o1b2;
			%let colList2 = &colList2 o2b2;
		%end;
		%if %upcase(&bvalue) = COMMON_CUBIC %then %do;
			%let colList1 = &colList1 o1b3;
			%let colList2 = &colList2 o2b3;
		%end;

		/* eMKF: square block matrix of covariances for regression coefficients by group */
		data _covmat1; 	/* Outcome 1 */
		  retain _rep Row Parameter &colList1;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 'o1') keep = _rep Row Parameter &colList1);;
		run;
		data _covmat2; /* Outcome 2 */
		  retain _rep Row Parameter &colList2;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 'o2') keep = _rep Row Parameter &colList2);;
		run;
		data _covmat12; /* Outcome 1 by 2 */
		  retain _rep Row Parameter &colList2;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 'o1') keep = _rep Row Parameter &colList2);;	  
		run;
		data _covmat21; /* Outcome 2 by 1 */
		  retain _rep Row Parameter &colList1;;
		  set &out._covmat(where=(substr(Parameter, 1, 2) = 'o2') keep = _rep Row Parameter &colList1);;	  
		run;

		/* eMKF: obtain new row numbers associated with modified column order */
		data _tcmat1; /* Outcome 1 */
		  set _covmat1;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat1 out=_tcmat1;
	      by _rep;
	    run;
		data _tcmat1;
		  set _tcmat1;
	      by _rep;
	      if first._rep then nRow = 0; 		/* eMKF v2.4 correction: reset counter to zero for each new replication */
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col: ;
		run;
		data _tcmat2; /* Outcome 2 */
		  set _covmat2;
	      by _rep;
	      if first._rep then output;
	 	  drop Row Parameter;
		run;
		proc transpose data=_tcmat2 out=_tcmat2;
	      by _rep;
	    run;
		data _tcmat2;
		  set _tcmat2;
	      by _rep;
	      if first._rep then nRow = 0; 		/* eMKF v2.4 correction: reset counter to zero for each new replication */
		  nRow + 1;
		  rename _NAME_ = Parameter;
		  drop col: ;
		run;

		/* eMKF v2.4 streamlining: offset to add to row numbers in _tcmat2 is now determined from model dimensions */
		data _tcmat2;
		  set _tcmat2;
		  %if not(%upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then nRow = nRow + &g*&p;;
		  %if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then nRow = nRow + &g + &k;;
		run;

		/* eMKF: sort, merge, and re-sort using the new row numbers */
		proc sort data=_covmat1; /* Outcome 1 */
		  by _rep Parameter;
		run;
		proc sort data=_covmat12;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat1;
		  by _rep Parameter;
		run;
		data _covmat1;
		  merge _covmat1 _covmat12 _tcmat1;
		  by _rep Parameter;
		run;
		proc sort data=_covmat1;
		  by _rep nRow;
		run;
		proc sort data=_covmat2; /* Outcome 2 */
		  by _rep Parameter;
		run;
		proc sort data=_covmat21;
		  by _rep Parameter;
		run;
		proc sort data=_tcmat2;
		  by _rep Parameter;
		run;
		data _covmat2;
		  merge _covmat21 _covmat2 _tcmat2;
		  by _rep Parameter;
		run;
		proc sort data=_covmat2;
		  by _rep nRow;
		run;

		/* eMKF: set into single square block matrix */
		data _covmat;
		  set _covmat1 _covmat2;
		run;
		/* eMKF v2.4 correction: sorted by _rep and nRow */
		proc sort data=_covmat;
		  by _rep nRow;
		run;

		/* eMKF: rectangular block matrix of covariances between regression coefficients and remaining parameters */
		data _covmatt;
		  retain _rep Row Parameter &colList1 &colList2;;
		  set &out._covmat(where=(not(substr(Parameter, 1, 2) in ('o1','o2'))) keep = _rep Row Parameter &colList1 &colList2);;	  
		run;

		/* eMKF: apply reverse-transformation to both square and rectangular block matrices */
		%let i = 0; %let jj = 0;
		proc iml;
			use _oPmat_;
			read all into oP; close _oPmat_;
			oP = oP[1:&p, 1:&p];
			oPP = &oPPmat;;
			/* eMKF: re-structure block matrix in the common trend cases (where &p > 1) */
			%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
				oPP1 = oPP[do(1, &g*&p, &p), do(1, &g*&p, &p)];
				oPP2 = vecdiag(oPP[do(1, &g*&p, &p), do(2, &g*&p, &p)]);
				ToPP2 = vecdiag(oPP[do(2, &g*&p, &p), do(1, &g*&p, &p)]);
				oPP1 = oPP1 // T(ToPP2);
				oPP0 = oPP2;
				%if &p > 2 %then %do;
					oPP3 = vecdiag(oPP[do(1, &g*&p, &p), do(3, &g*&p, &p)]);
					ToPP3 = vecdiag(oPP[do(3, &g*&p, &p), do(1, &g*&p, &p)]);
					oPP1 = oPP1 // T(ToPP3);
					oPP0 = oPP0 || oPP3;
				%end;
				%if &p > 3 %then %do;
					oPP4 = vecdiag(oPP[do(1, &g*&p, &p), do(4, &g*&p, &p)]);
					ToPP4 = vecdiag(oPP[do(4, &g*&p, &p), do(1, &g*&p, &p)]);
					oPP1 = oPP1 // T(ToPP4);
					oPP0 = oPP0 || oPP4;
				%end;
				oPP0 = oPP0 // oPP[2:&p, 2:&p];
				oPP = oPP1 || oPP0;
			%end;
			oPP = block(oPP, oPP); /* one block per outcome */
			varNames = {"_rep" "Row"};
			%do i=1 %to &g; /* Outcome 1 */
				varNames = varNames || {"o1ag&i"};
				%if %upcase(&bvalue) = INDEP_LINEAR %then varNames = varNames || {"o1b1g&i"};;
				%if %upcase(&bvalue) = INDEP_QUAD   %then varNames = varNames || {"o1b1g&i"} || {"o1b2g&i"};;
				%if %upcase(&bvalue) = INDEP_CUBIC  %then varNames = varNames || {"o1b1g&i"} || {"o1b2g&i"} || {"o1b3g&i"};;
			%end;
			%if %upcase(&bvalue) = COMMON_LINEAR %then varNames = varNames || {"o1b1"};;
			%if %upcase(&bvalue) = COMMON_QUAD   %then varNames = varNames || {"o1b1" "o1b2"};;
			%if %upcase(&bvalue) = COMMON_CUBIC  %then varNames = varNames || {"o1b1" "o1b2" "o1b3"};;
			%do i=1 %to &g; /* Outcome 2 */
				varNames = varNames || {"o2ag&i"};
				%if %upcase(&bvalue) = INDEP_LINEAR %then varNames = varNames || {"o2b1g&i"};;
				%if %upcase(&bvalue) = INDEP_QUAD   %then varNames = varNames || {"o2b1g&i"} || {"o2b2g&i"};;
				%if %upcase(&bvalue) = INDEP_CUBIC  %then varNames = varNames || {"o2b1g&i"} || {"o2b2g&i"} || {"o2b3g&i"};;
			%end;
			%if %upcase(&bvalue) = COMMON_LINEAR %then varNames = varNames || {"o2b1"};;
			%if %upcase(&bvalue) = COMMON_QUAD   %then varNames = varNames || {"o2b1" "o2b2"};;
			%if %upcase(&bvalue) = COMMON_CUBIC  %then varNames = varNames || {"o2b1" "o2b2" "o2b3"};;
			create _tcovmat var varNames;
			%do jj=1 %to &nrep;
				use _covmat(where=(_rep = &jj) drop= Parameter nRow);
				read all into oB; close _covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
	            oBB = oPP * oB * T(oPP);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _tcovmat;
			create _tcovmatt var varNames;
			%do jj=1 %to &nrep;
				use _covmatt(where=(_rep = &jj) drop= Parameter);
				read all into oB; close _covmatt;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = oPP * T(oB);
				oBB = oB1 || T(oBB);
				append from oBB;
			%end;
			close _tcovmatt;
		quit;

		/* eMKF: combine both square and rectangular block matrices */
	    data _tcovmat;
		  set _tcovmat _tcovmatt;
		run;

		/* eMKF: re-sort rows */
		proc sort data=_tcovmat;
	  		by _rep Row ;
		run;

		/* eMKF: re-order columns as they were initially from NLMIXED */
		data _tcovmat2;
	  	  retain  _rep Row 
				  o1ag1-o1ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then o1b1g1-o1b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then o1b1g1-o1b1g&g o1b2g1-o1b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then o1b1g1-o1b1g&g o1b2g1-o1b2g&g o1b3g1-o1b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then o1b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then o1b1 o1b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then o1b1 o1b2 o1b3; 
				  o2ag1-o2ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then o2b1g1-o2b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then o2b1g1-o2b1g&g o2b2g1-o2b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then o2b1g1-o2b1g&g o2b2g1-o2b2g&g o2b3g1-o2b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then o2b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then o2b1 o2b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then o2b1 o2b2 o2b3; ;
		  set _tcovmat; 
		run;
		data _tcovmatt2;
	  	  retain  _rep Row 
				  o1ag1-o1ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then o1b1g1-o1b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then o1b1g1-o1b1g&g o1b2g1-o1b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then o1b1g1-o1b1g&g o1b2g1-o1b2g&g o1b3g1-o1b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then o1b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then o1b1 o1b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then o1b1 o1b2 o1b3; 
				  o2ag1-o2ag&g 
				  %if %upcase(&bvalue) = INDEP_LINEAR  %then o2b1g1-o2b1g&g; 
				  %if %upcase(&bvalue) = INDEP_QUAD    %then o2b1g1-o2b1g&g o2b2g1-o2b2g&g; 
				  %if %upcase(&bvalue) = INDEP_CUBIC   %then o2b1g1-o2b1g&g o2b2g1-o2b2g&g o2b3g1-o2b3g&g; 
				  %if %upcase(&bvalue) = COMMON_LINEAR %then o2b1; 
				  %if %upcase(&bvalue) = COMMON_QUAD   %then o2b1 o2b2; 
				  %if %upcase(&bvalue) = COMMON_CUBIC  %then o2b1 o2b2 o2b3; ;
		  set _tcovmatt; 
		run;
	
		/* eMKF: merge */
		data _tcovmatt2;
		  merge &out._covmat(where=(not(substr(Parameter, 1, 2) in ('o1','o2'))) keep = _rep Row Parameter) _tcovmatt2;
		  by _rep Row;
		run;

		/* eMKF: transpose _tcovmatt2 to add into larger matrix */
		proc transpose data=_tcovmatt2(drop=Row) out=_tcovmatt2 name = Parameter;
	      by _rep;
		  id Parameter;
	    run;

		/* eMKF: insert Row numbers */
		data _tcovmatt2;
		  set _tcovmatt2;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;

		/* eMKF: update covariance matrix dataset */
		data &out._covmat;
	  	  merge &out._covmat(keep = _rep Row Parameter) _tcovmat2 _tcovmatt2 
				&out._covmat(where=(not(substr(Parameter, 1, 2) in ('o1','o2'))) drop = o1: o2:) ;
		  by _rep Row;
		run;

		/* eMKF: extract variances of model parameters */
		%let jj = 0; 		
		proc iml;
			create _dcovmatt var{"_rep" "Row" "Var"};
			%do jj=1 %to &nrep;
				use &out._covmat(where=(_rep = &jj) drop= Parameter);
				read all into oB; close &out._covmat;
				oB1 = oB[,1:2];
				oB = oB[,3:ncol(oB)];
				oBB = vecdiag(oB);
				oBB = oB1 || oBB;
				append from oBB;
			%end;
			close _dcovmatt;
		quit;
		data _dcovmatt;
		  merge _dcovmatt &out._covmat(keep = _rep Row Parameter);
		  by _rep Row;
		run;

	%end;

	/* eMKF: reset regression coefficients for o2 as differences relative to o1 */
	data _tests2;
  	  merge _tests2 _tests1;
	  by _rep _group_;
  	  o2a = o2a - o1a;
  	  %if &p > 1 %then %str(o2b1 = o2b1 - o1b1;);;
  	  %if &p > 2 %then %str(o2b2 = o2b2 - o1b2;);;
  	  %if &p > 3 %then %str(o2b3 = o2b3 - o1b3;);;
	run;

	/* eMKF: reverse-transformed regression estimates in long form */
	%if not(%upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC) %then %do;
		data _lests;
		  set _tests1(keep = _rep o1a rename=(o1a=Est))
			  %if &p > 1 %then _tests1(keep = _rep o1b1 rename=(o1b1=Est));
			  %if &p > 2 %then _tests1(keep = _rep o1b2 rename=(o1b2=Est));
			  %if &p > 3 %then _tests1(keep = _rep o1b3 rename=(o1b3=Est));
			  _tests2(keep = _rep o2a rename=(o2a=Est))
			  %if &p > 1 %then _tests2(keep = _rep o2b1 rename=(o2b1=Est));
			  %if &p > 2 %then _tests2(keep = _rep o2b2 rename=(o2b2=Est));
			  %if &p > 3 %then _tests2(keep = _rep o2b3 rename=(o2b3=Est));
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;
	%if %upcase(&bvalue) in COMMON_LINEAR COMMON_QUAD COMMON_CUBIC %then %do;
		%let jj = 0; 		
		data _lests;
		  set _tests1(keep = _rep o1a rename=(o1a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &p > 1 %then _tests1(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o1b1 rename=(o1b1=Est));
			   	  %if &p > 2 %then _tests1(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o1b2 rename=(o1b2=Est));
			  	  %if &p > 3 %then _tests1(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o1b3 rename=(o1b3=Est));
			  %end;
			  _tests2(keep = _rep o2a rename=(o2a=Est))
		  	  %do jj=1 %to &nrep;
			  	  %if &p > 1 %then _tests2(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o2b1 rename=(o2b1=Est));
			   	  %if &p > 2 %then _tests2(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o2b2 rename=(o2b2=Est));
			  	  %if &p > 3 %then _tests2(where=(_rep=&jj) firstobs=1 obs=1 keep = _rep o2b3 rename=(o2b3=Est));
			  %end;
		  ;
		  by _rep;
		  retain Row;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	%if %upcase(&nlmixedDetails) = YES %then %do;
		/* eMKF: merge reverse-transformed estimates and variances into fitstat dataset and update */
		data _tfits;
		  merge &out._fitstat _dcovmatt;
		  by _rep ;
		run;
	%end;
	%if %upcase(&nlmixedDetails) ^= YES %then %do;
		data _tfits;
		  set &out._fitstat;
		  by _rep;
		  if first._rep then Row = 1;
		  else Row + 1;
		run;
	%end;

	data _tfits;
	  merge _tfits _lests;
	  by _rep Row;
	run;

	/* eMKF v2.4 streamlining: added option to omit test statistics */ 
	data _tfits;
	  set _tfits;
	  if Est ne . then Estimate = Est;
	  %if %upcase(&nlmixedDetails) = YES %then %do;
		  if Var > 0 then StandardError = sqrt(Var);
		  else StandardError = .;
		  tValue = Estimate/StandardError;
		  Probt = (1-probt(abs(tValue), DF))*2;
		  Lower = Estimate + tinv(Alpha/2, DF)*StandardError;
		  Upper = Estimate + tinv(1-Alpha/2, DF)*StandardError;
	  %end;
	  drop Row Est %if %upcase(&nlmixedDetails) = YES %then Var;;
	run;
	data &out._fitstat;
	  set _tfits;
	run;

%end;

/* eMKF: Add labels for stratification variable */
%if &by ^=%str() %then %do;
	data &out._ests;
	  merge &out._ests _freq_;
	  by _rep;
	run;
%end;

data &out._ests; /* eMKF: added parameter estimates for quadratic and cubic terms */
  set &out._ests;
  label _2loglike =" -2 log-likelihood estimate"
		/* eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied -- they are estimated instead */
		_rho_ ="Estimated rho of the model"
	    _tausq_="Estimated tau-square of the model"
        delta ="Multiplicative factor of the latent AR(1) process for &outcome2"
	    _group_="Model reset group ID just in case group is not ordered"
	    &group ="Numeric &&group variable"
		/* eMKF: Added labels for by variable */
		_rep="Model reset stratum ID just in case stratification variable, if any, is not ordered"
		&by="&&by variable"
	    o1a="Parameter estimate (a) for the outcome &outcome"
        o2a="Parameter estimate (a) for the outcome &outcome2"
		%if &p > 1 %then o1b1="Parameter estimate (b1) for the outcome &outcome assuming &bvalue trend model "
            	         o2b1="Parameter estimate (b1) for the outcome &outcome2 assuming &bvalue trend model " ;
  		%if &p > 2 %then o1b2="Parameter estimate (b2) for the outcome &outcome assuming &bvalue trend model "
                   	     o2b2="Parameter estimate (b2) for the outcome &outcome2 assuming &bvalue trend model " ;
  		%if &p > 3 %then o1b3="Parameter estimate (b3) for the outcome &outcome assuming &bvalue trend model "
                  		 o2b3="Parameter estimate (b3) for the outcome &outcome2 assuming &bvalue trend model " ;
	;
	drop &group %if &by ^= %str() %then &by; ;
run;

data &out._pred;  /* eMKF: added a few useful labels */
	 set &out._pred(rename=(Predvar=PredOnlyVar HatMSE=PredMSE Predvar2=PredOnlyVar2 HatMSE2=PredMSE2));
	 PredSE= sqrt(PredMSE);
	 PredSE2= sqrt(PredMSE2);
	 label _2loglike =" -2 log-likelihood estimate"
			/* eMKF v2.4 streamlining: _rho_ and _tausq_ can no longer be user-supplied -- they are estimated instead */
		   _rho_ ="Estimated rho of the model for the outcome &outcome"
		   _tausq_="Estimated tau-square of the model for the outcome &outcome"
	       _rho2_  ="Estimated rho of the model for the outcome &outcome2"
		   _tausq2_="Estimated tau-square of the model for the outcome &outcome2"
		   _group_="Model reset group ID just in case group is not ordered"
		   &group ="Numeric &&group variable"
		   _rep="Model reset stratum ID just in case stratification variable, if any, is not ordered"
		   &by="&&by variable"
		   &rlag = "Elapsed real time from previous time point"
		   &rtm = "Real time used in calculations"
		   _time ="Time "
		   _y  ="Original outcome for the outcome &outcome"
		   _se ="Original Standard Error for the outcome &outcome"
		   _avgse ="Average Standard Error across timepoints for the outcome &outcome used for imputation"
	       %if &by ^= %str() %then _avgseb ="Average Standard Error across strata for the outcome &outcome used for imputation";
           _y2  ="Original outcome for the outcome &outcome2"
		   _se2 ="Original Standard Error for the outcome &outcome2"
		   _avgse2 ="Average Standard Error across timepoints for the outcome &outcome2 used for imputation"
		   %if &by ^= %str() %then _avgse2b ="Average Standard Error across strata for the outcome &outcome2 used for imputation";
		   impute= "Whether original Standard Error for outcome &outcome or &outcome2 was imputed using average across timepoints"
		   %if &by ^= %str() %then imputeb= "Whether original Standard Error for outcome &outcome or &outcome2 was imputed using average across strata";
		   inputorder="Original orderng of the groups if it was not alphabetical"
		   prediction="Kalman estimator prediction of the outcome &outcome assuming &bvalue trend model"
		   PredMSE="Prediction variability: Mean Squared Error (MSE) for the outcome &outcome assuming &bvalue trend model "
		   PredSE="Prediction standard error: Square root of MSE for the outcome &outcome assuming &bvalue trend model "
		   predeff ="Kalman estimator prediction of the outcome &outcome assuming &bvalue trend model and using a combined (averaged) gamma"
		   prediction2="Kalman estimator prediction of the outcome &outcome2 assuming &bvalue trend model"
		   PredMSE2="Prediction variability: Mean Squared Error (MSE) for the outcome &outcome2 assuming &bvalue trend model "
		   PredSE2="Prediction standard error: Square root of MSE for the outcome &outcome2 assuming &bvalue trend model "
	       predeff2="Kalman estimator prediction of the outcome &outcome2 assuming &bvalue trend model and using a combined (averaged) gamma"
		   o1a="Parameter estimate (a) for the outcome &outcome"
	       o2a="Parameter estimate (a) for the outcome &outcome2"
	 	   %if &p > 1 %then o1b1="Parameter estimate (b1) for the outcome &outcome assuming &bvalue trend model "
	                 		o2b1="Parameter estimate (b1) for the outcome &outcome2 assuming &bvalue trend model " ;
	   	   %if &p > 2 %then o1b2="Parameter estimate (b2) for the outcome &outcome assuming &bvalue trend model "
	                 		o2b2="Parameter estimate (b2) for the outcome &outcome2 assuming &bvalue trend model " ;
		   %if &p > 3 %then o1b3="Parameter estimate (b3) for the outcome &outcome assuming &bvalue trend model "
	                  		o2b3="Parameter estimate (b3) for the outcome &outcome2 assuming &bvalue trend model " ;
	 ;
	 /* These will be deleted for now. If needed they can be useful */
	 drop mu mu2 err err2 delta delta2 lambda lambda2 w w2 Hat_y PredOnlyVar Hat_y2 PredOnlyVar2 &group group_rep &rlag %if &by ^= %str() %then &by; ; 
run;

/* eMKF: Rename any remaining instances of numeric &group variable to _group_ + remove numeric &by variable */
data &out._predVar;
  set &out._predVar;
  rename &group = _group_;
  %if &by ^= %str() %then drop &by;;
run;
/* eMKF v2.4 streamlining: added option to omit covariance matrices and model diagnostics */ 
%if %upcase(&nlmixedDetails) = YES %then %do;
	data &out._H;
	  set &out._H;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._o2H;
	  set &out._o2H;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._covY;
	  set &out._covY;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
	data &out._o2covY;
	  set &out._o2covY;
	  rename &group = _group_;
	  %if &by ^= %str() %then drop &by;;
	run;
%end;

/* eMKF v2.4 streamlining: added option to omit covariance matrices and other model details */ 
proc datasets nolist;
 delete _freqn_ _freqg_ _freq_ _sdata_ _jdata_ _beta_ _inits_ _initsr_ _ests _fitstat _convstat _llike_ _empty_ _Amat_ _Dmat_ _Vmat_ _Vgmat_ _Vemat_ _Xmat_ 
		_junk_ _junk0_ _junk01_ aa _oXmat_ _oPmat_ _tests1 _tests2 _lests _tfits _tcmat1 _tcmat2 _covmat1 _covmat2 _covmat12 _covmat21 
	 	_covmat _covmatt _tcovmat _tcovmat2 _tcovmatt _tcovmatt2 _dcovmatt 
		%if %upcase(&nlmixedDetails) ^= YES %then &out._H &out._o2H &out._covY &out._o2covY &out._covmat &out._fitstat ;
		&out._predVar &out._BLUP
        ;
run ;
quit; 

%mend htrp2d;

data _null_;
run;


/* This macro allows us to reformat the data in a way that only one outcome is defined with time and group variables */

/* eMKF: Modified to track real time for use in calculations and calculate lags between succesive time points
 *		 Modified to allow for effective sample sizes to be specified, and to allow for imputing SEs across strata if needed
 * 		 Added random variance option
 * eMKF v2.4 streamlining: Format 1, used in previous versions, is no longer supported. 
						   The reformat macro now simply computes intermediate columns needed for internal calculations.
 */
%macro reformat(
			 data=, 
             outcome=, 
             se=,
             neff=,    			
			 outcome2=, 
             se2=, 
			 neff2=,
             group=, 
             time=, 
             by= ,
			 randomVars = NO, 	
			 outformat= 
             );

%local wt2;

/* eMKF v2.4 streamlining: Added error check to rule out "format 1" used in previous versions of the macro */
%if %scan(&outcome,2) ^=%str() or %scan(&se,2) ^=%str() or %scan(&outcome2,2) ^=%str() or %scan(&se2,2) ^=%str() or 
	&outcome =%str() or &se =%str() or &time =%str() %then %do;
	%put ERROR: Format 1 is no longer supported.;
	%put ERROR- Please ensure data are in long (stacked) format and the outcome, SE, and time variables are specified!;
	%return;
%end;

/* eMKF: inputorder variable definition */
data &outformat _freqg_ _freq_ _freqn_;
run;
data &outformat;
 set &data;
 inputorder +1;
run;

/* eMKF: _group_ variable definition */
proc freq data=&data noprint;
 tables &group /list out=_freqg_;
run;
data _freqg_;
 set _freqg_;
 _group_ +1;
 keep _group_ &group;
run;

/* eMKF: sort and merge */
proc sort data=&outformat;
 by &group;
run;
proc sort data=_freqg_;
 by &group;
run;
data &outformat;
 merge &outformat _freqg_;
 by &group;
run;

/* eMKF: _rep variable definition */
%if &by =%str() %then %do; /* eMKF: constant _rep */
	data &outformat;
	 set &outformat;
	 _rep=1;
	run;
%end;
%else %do; 	/* eMKF: incremented _rep */
	proc freq data=&outformat noprint;
	 tables &by /list out=_freq_;
	run;
	data _freq_;
	 set _freq_;
	 _rep +1;
	 keep _rep &by;
	run;
	proc sort data=&outformat; /* eMKF: sort and merge */
	 by &by;
	run;
	data &outformat;
	 merge &outformat _freq_;
	 by &by;
	run;
%end;

/* eMKF v2.4 streamlining: Assuming "format 2", find number of time points and define generic variables for outcome(s) and SE(s) */

%let wt2=;

/* eMKF: _time variable definition */
proc freq data=&outformat noprint;
 tables &time /list out=_freqn_;
run;

/* eMKF: modified to also calculate real time assuming &time is numeric: this allows handling unequally-spaced time points */
data _freqn_;
  set _freqn_;
  retain base _rtimeold;
  if _n_ = 1 then do;
	base=&time;
	_rtimeold=base;
  end;
  _rlag = &time - _rtimeold;
  _rtimeold = &time;
  _rtime = &time - base + 1;
  _time + 1;
  call symput("wt2", _time);	
  keep _rlag _rtime _time &time;
run;

data _freqn_; /* eMKF: Set first lag to missing instead of 0*/
  set _freqn_;
  if _n_ = 1 then _rlag = .;
run;

/* eMKF: number of time points */
%let wt2 = %eval(0 + &wt2 );

/* eMKF: sort prior to merging */
proc sort data=&outformat;
 by &time;
run;

/* eMKF: merge and define outcomes(s) and SE(s) generic variables */
data &outformat;
 merge &outformat _freqn_;
 by &time;
 _y =&outcome;
 _se=&se;
 %if &outcome2 ^=%str() and &se2 ^=%str() %then _y2 =&outcome2;;
 %if &outcome2 ^=%str() and &se2 ^=%str() %then _se2 =&se2;;
run;

/* eMKF: mean imputations for missing or zero SEs */

data _means_ _means2_ _meansb_ _means2b_;
run;

data &outformat;
  set &outformat;
  if _se le 0 then _se=.;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _se2 le 0 then _se2=.;;;
run;

proc sort data= &outformat;
  by _rep _group_ _time;
run;

/* eMKF: Averages across timepoints */
proc means data=&outformat noprint;
  var _se;
  where _se ne .;
  by _rep _group_;
  output out= _means_(drop= _type_ _freq_) mean=_avgse;
run;
%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	proc means data=&outformat noprint;
	 var _se2;
	 where _se2 ne .;
	 by _rep _group_;
	 output out= _means2_(drop= _type_ _freq_) mean=_avgse2;
	run;
%end;

/* eMKF: Averages across strata */
%if &by ^= %str() %then %do; 
  proc sort data= &outformat;
    by _group_ _time _rep;
  run;
  proc means data=&outformat noprint;
    var _se;
    where _se ne .;
    by _group_ _time;
    output out= _meansb_(drop= _type_ _freq_) mean=_avgseb;
  run;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
    proc means data=&outformat noprint;
	  var _se2;
	  where _se2 ne .;
	  by _group_ _time;
	  output out= _means2b_(drop= _type_ _freq_) mean=_avgse2b;
	run;
  %end;
  proc sort data= &outformat;
    by _rep _group_ _time;
  run;
%end;

data &outformat;
  merge &outformat _means_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2_ ;;
  by _rep _group_;
  impute=0;
  if _se=. and _avgse > 0 then do;
	impute=1;
	_se = _avgse;
  end;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	if _se2=. and _avgse2 > 0 then do;
		impute=1;
		_se2 = _avgse2;
	end;
  %end;
run;

/* eMKF: (new in eMKF) use average SE across strata if still have missing SEs */
%if &by ^= %str() %then %do; 
  proc sort data= &outformat;
    by _group_ _time _rep;
  run;
  data &outformat;
    merge &outformat _meansb_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2b_ ;;
    by _group_ _time;
    imputeb=0;
    if _se=. and _avgseb > 0 then do;
	  imputeb=1;
	  _se = _avgseb;
    end;
    %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	  if _se2=. and _avgse2b > 0 then do;
		  imputeb=1;
		  _se2 = _avgse2b;
	  end;
    %end;
  run;
  proc sort data= &outformat;
    by _rep _group_ _time;
  run;
%end;

/* eMKF: Added effective sample size imputations */

data _means_ _means2_ _meansb_ _means2b_;
run;

%if %upcase(&randomVars) = YES %then %do;

	%if &neff = %str() or (&outcome2 ^=%str() and &se2 ^=%str() and &neff2 = %str()) %then %do;
		/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
		%put ERROR: (Effective) sample sizes must be specified to fit random sampling variances.;
		%return;
	%end;

	data &outformat;
	  set &outformat;
	  _n = &neff;
	  if _n le 0 then _n=.;
	  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	  	_n2 = &neff2;
		if _n2 le 0 then _n2=.;
	  %end;
	run;

	/* eMKF: Averages across timepoints */
	proc means data=&outformat noprint;
	  var _n;
	  where _n ne .;
	  by _rep _group_;
	  output out= _means_(drop= _type_ _freq_) mean=_avgn;
	run;
	%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
		proc means data=&outformat noprint;
		  var _n2;
		  where _n2 ne .;
		  by _rep _group_;
		  output out= _means2_(drop= _type_ _freq_) mean=_avgn2;
		run;
	%end;

	/* eMKF: Averages across strata */
    %if &by ^= %str() %then %do; 
      proc sort data= &outformat;
        by _group_ _time _rep;
      run;
      proc means data=&outformat noprint;
        var _n;
        where _n ne .;
        by _group_ _time;
        output out= _meansb_(drop= _type_ _freq_) mean=_avgnb;
      run;
      %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
        proc means data=&outformat noprint;
	      var _n2;
	      where _n2 ne .;
	      by _group_ _time;
	      output out= _means2b_(drop= _type_ _freq_) mean=_avgn2b;
	    run;
      %end;
      proc sort data= &outformat;
        by _rep _group_ _time;
      run;
    %end;

	/* eMKF: first pass at imputation using average over timepoints */
	data &outformat;
	  merge &outformat _means_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2_ ;;
	  by _rep _group_;
	  if _n=. and _avgn > 0 then _n = _avgn;
	  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _n2=. and _avgn2 > 0 then _n2 = _avgn2;;;
	run;

	/* eMKF: second pass at imputation using average across strata */
	%if &by ^= %str() %then %do; 
      proc sort data= &outformat;
        by _group_ _time _rep;
      run;
	  data &outformat;
	    merge &outformat _meansb_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2b_ ;;
	    by _group_ _time;
	    if _n=. and _avgnb > 0 then _n = _avgnb;
	    %if &outcome2 ^=%str() and &se2 ^=%str() %then if _n2=. and _avgn2b > 0 then _n2 = _avgn2b;;;
	  run;
      proc sort data= &outformat;
        by _rep _group_ _time;
      run;
	%end;

%end;

data _means_;
run;
data _means_;
  set &outformat;
  %if &by = %str() %then if impute=1;;
  %if &by ^= %str() %then if impute=1 or imputeb=1;;
run;

data &outformat;
  merge &outformat(drop=impute %if &by ^= %str() %then imputeb;) 
        _means_(keep= _rep _group_ impute %if &by ^= %str() %then imputeb;);
  by _rep _group_;
  if impute=. then impute=0;
  %if &by ^= %str() %then if imputeb=. then imputeb=0;;
run;

data _means_;
  set &outformat;
  if _time= &wt2;
  order=inputorder;
  keep order _rep _group_ _time;
run;
proc sort data=_means_;
  by order;
run;
data _means_;
  set _means_;
  inputorder +1;
  drop order;
run;
proc sort data= _means_;
  by _rep _group_;
run;

proc sort data= &outformat;
  by _rep _group_;
run;
data &outformat;
  merge &outformat(drop=inputorder) _means_(keep= _rep _group_ inputorder);
  by _rep _group_;
run;
proc sort data= &outformat;
  by _rep inputorder;
run;

proc datasets nolist;
  delete _means_ _means2_ _meansb_ _means2b_ _freqg_ _freqn_ _freq_ ;
run ;
quit; 

%mend reformat;

data _null_;
run;


/* eMKF v2.4: Standalone version of macro reformat for dealing with specified break point */
/*            Assumes data are in format 2 */
%macro reformatXPT(
			 data=, 
             outcome=, 
             se=,
             neff=,    			
			 outcome2=, 
             se2=, 
			 neff2=,
             group=, 
             time=, 
			 xpt=,
             by= ,
			 randomVars = NO, 	
			 outformat= 
             );

%local wt2 xptfound;

/* eMKF v2.4 streamlining: Added error check to rule out "format 1" used in previous versions of the macro */
%if %scan(&outcome,2) ^=%str() or %scan(&se,2) ^=%str() or %scan(&outcome2,2) ^=%str() or %scan(&se2,2) ^=%str() or 
	&outcome =%str() or &se =%str() or &time =%str() %then %do;
	%put ERROR: Format 1 is no longer supported.;
	%put ERROR- Please ensure data are in long (stacked) format and the outcome, SE, and time variables are specified!;
	%return;
%end;

/* eMKF: inputorder variable definition */
data &outformat _freqg_ _freq_ _freqn_;
run;
data &outformat;
 set &data;
 inputorder +1;
run;

/* eMKF: _group_ variable definition */
proc freq data=&data noprint;
 tables &group /list out=_freqg_;
run;
data _freqg_;
 set _freqg_;
 _group_ +1;
 keep _group_ &group;
run;

/* eMKF: sort and merge */
proc sort data=&outformat;
 by &group;
run;
proc sort data=_freqg_;
 by &group;
run;
data &outformat;
 merge &outformat _freqg_;
 by &group;
run;

/* eMKF: _rep variable definition */

%if &by =%str() %then %do; /* eMKF: constant _rep */
	data &outformat;
	 set &outformat;
	 _rep=1;
	run;
%end;
%else %do; 	/* eMKF: incremented _rep */
	proc freq data=&outformat noprint;
	 tables &by /list out=_freq_;
	run;
	data _freq_;
	 set _freq_;
	 _rep +1;
	 keep _rep &by;
	run;
	proc sort data=&outformat; /* eMKF: sort and merge */
	 by &by;
	run;
	data &outformat;
	 merge &outformat _freq_;
	 by &by;
	run;
%end;

%let wt2=;

/* eMKF: _time variable definition */
proc freq data=&outformat noprint;
 tables &time /list out=_freqn_;
run;

/* eMKF v2.4: check that specified break point is a valid timepoint */
%let xptfound = 0;
data _null_;
  set _freqn_;
  if &time = &xpt then call symput("xptfound" , 1);
run;
%let xptfound = %eval(0 + &xptfound );

/* eMKF v2.4: warning if break point not found */ 
%if not(&xptfound) %then %do;
	%put WARNING: The specified break point was not found in the &time column. Please check! ;
%end;

/* eMKF: modified to also calculate real time assuming &time is numeric: this allows handling unequally-spaced time points */
data _freqn_;
  set _freqn_;
  retain base _rtimeold;
  if _n_ = 1 then do;
	base=&time;
	_rtimeold=base;
  end;
  _rlag = &time - _rtimeold;
  _rtimeold = &time;
  _rtime = &time - base + 1;
  _time + 1;
  %if &xptfound %then %do;
	  if &time < &xpt then do;
	    _s1rtime = _rtime;  /* eMKF v2.4:  track time segments */
		_s2rtime = 0;
	  end;
	  else do;
		_s1rtime = 0;
	    _s2rtime = _rtime;
	  end;
  %end;
  %if not(&xptfound) %then %do;
	    _s1rtime = _rtime;
		_s2rtime = 0;
  %end;
  call symput("wt2", _time);	
  keep _rlag _rtime _time &time _s1rtime _s2rtime ;
run;

data _freqn_; /* eMKF: Set first lag to missing instead of 0*/
  set _freqn_;
  if _n_ = 1 then _rlag = .;
run;

/* eMKF: number of time points */
%let wt2 = %eval(0 + &wt2 );

/* eMKF: sort prior to merging */
proc sort data=&outformat;
 by &time;
run;

/* eMKF: merge and define outcomes(s) and SE(s) generic variables */
data &outformat;
 merge &outformat _freqn_;
 by &time;
 _y =&outcome;
 _se=&se;
 %if &outcome2 ^=%str() and &se2 ^=%str() %then _y2 =&outcome2;;
 %if &outcome2 ^=%str() and &se2 ^=%str() %then _se2 =&se2;;
run;

/* eMKF: mean imputations for missing or zero SEs */

data _means_ _means2_ _meansb_ _means2b_;
run;

data &outformat;
  set &outformat;
  if _se le 0 then _se=.;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _se2 le 0 then _se2=.;;;
run;

proc sort data= &outformat;
  by _rep _group_ _time;
run;

/* eMKF: Averages across timepoints */
proc means data=&outformat noprint;
  var _se;
  where _se ne .;
  by _rep _group_;
  output out= _means_(drop= _type_ _freq_) mean=_avgse;
run;
%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	proc means data=&outformat noprint;
	 var _se2;
	 where _se2 ne .;
	 by _rep _group_;
	 output out= _means2_(drop= _type_ _freq_) mean=_avgse2;
	run;
%end;

/* eMKF: Averages across strata */
%if &by ^= %str() %then %do; 
  proc sort data= &outformat;
    by _group_ _time _rep;
  run;
  proc means data=&outformat noprint;
    var _se;
    where _se ne .;
    by _group_ _time;
    output out= _meansb_(drop= _type_ _freq_) mean=_avgseb;
  run;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
    proc means data=&outformat noprint;
	  var _se2;
	  where _se2 ne .;
	  by _group_ _time;
	  output out= _means2b_(drop= _type_ _freq_) mean=_avgse2b;
	run;
  %end;
  proc sort data= &outformat;
    by _rep _group_ _time;
  run;
%end;

data &outformat;
  merge &outformat _means_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2_ ;;
  by _rep _group_;
  impute=0;
  if _se=. and _avgse > 0 then do;
	impute=1;
	_se = _avgse;
  end;
  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	if _se2=. and _avgse2 > 0 then do;
		impute=1;
		_se2 = _avgse2;
	end;
  %end;
run;

/* eMKF: (new in eMKF) use average SE across strata if still have missing SEs */
%if &by ^= %str() %then %do; 
  proc sort data= &outformat;
    by _group_ _time _rep;
  run;
  data &outformat;
    merge &outformat _meansb_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2b_ ;;
    by _group_ _time;
    imputeb=0;
    if _se=. and _avgseb > 0 then do;
	  imputeb=1;
	  _se = _avgseb;
    end;
    %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	  if _se2=. and _avgse2b > 0 then do;
		  imputeb=1;
		  _se2 = _avgse2b;
	  end;
    %end;
  run;
  proc sort data= &outformat;
    by _rep _group_ _time;
  run;
%end;

/* eMKF: Added effective sample size imputations */

data _means_ _means2_ _meansb_ _means2b_;
run;

%if %upcase(&randomVars) = YES %then %do;

	%if &neff = %str() or (&outcome2 ^=%str() and &se2 ^=%str() and &neff2 = %str()) %then %do;
		%put ERROR: (Effective) sample sizes must be specified to fit random sampling variances.;
		%return;
	%end;

	data &outformat;
	  set &outformat;
	  _n = &neff;
	  if _n le 0 then _n=.;
	  %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
	  	_n2 = &neff2;
		if _n2 le 0 then _n2=.;
	  %end;
	run;

	/* eMKF: Averages across timepoints */
	proc means data=&outformat noprint;
	  var _n;
	  where _n ne .;
	  by _rep _group_;
	  output out= _means_(drop= _type_ _freq_) mean=_avgn;
	run;
	%if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
		proc means data=&outformat noprint;
		  var _n2;
		  where _n2 ne .;
		  by _rep _group_;
		  output out= _means2_(drop= _type_ _freq_) mean=_avgn2;
		run;
	%end;

	/* eMKF: Averages across strata */
    %if &by ^= %str() %then %do; 
      proc sort data= &outformat;
        by _group_ _time _rep;
      run;
      proc means data=&outformat noprint;
        var _n;
        where _n ne .;
        by _group_ _time;
        output out= _meansb_(drop= _type_ _freq_) mean=_avgnb;
      run;
      %if &outcome2 ^=%str() and &se2 ^=%str() %then %do;
        proc means data=&outformat noprint;
	      var _n2;
	      where _n2 ne .;
	      by _group_ _time;
	      output out= _means2b_(drop= _type_ _freq_) mean=_avgn2b;
	    run;
      %end;
      proc sort data= &outformat;
        by _rep _group_ _time;
      run;
    %end;

	/* eMKF: first pass at imputation using average over timepoints */
	data &outformat;
	  merge &outformat _means_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2_ ;;
	  by _rep _group_;
	  if _n=. and _avgn > 0 then _n = _avgn;
	  %if &outcome2 ^=%str() and &se2 ^=%str() %then if _n2=. and _avgn2 > 0 then _n2 = _avgn2;;;
	run;

	/* eMKF: second pass at imputation using average across strata */
	%if &by ^= %str() %then %do; 
      proc sort data= &outformat;
        by _group_ _time _rep;
      run;
	  data &outformat;
	    merge &outformat _meansb_ %if &outcome2 ^=%str() and &se2 ^=%str() %then _means2b_ ;;
	    by _group_ _time;
	    if _n=. and _avgnb > 0 then _n = _avgnb;
	    %if &outcome2 ^=%str() and &se2 ^=%str() %then if _n2=. and _avgn2b > 0 then _n2 = _avgn2b;;;
	  run;
      proc sort data= &outformat;
        by _rep _group_ _time;
      run;
	%end;

%end;

data _means_;
run;
data _means_;
  set &outformat;
  %if &by = %str() %then if impute=1;;
  %if &by ^= %str() %then if impute=1 or imputeb=1;;
run;

data &outformat;
  merge &outformat(drop=impute %if &by ^= %str() %then imputeb;) 
        _means_(keep= _rep _group_ impute %if &by ^= %str() %then imputeb;);
  by _rep _group_;
  if impute=. then impute=0;
  %if &by ^= %str() %then if imputeb=. then imputeb=0;;
run;

data _means_;
  set &outformat;
  if _time= &wt2;
  order=inputorder;
  keep order _rep _group_ _time;
run;
proc sort data=_means_;
  by order;
run;
data _means_;
  set _means_;
  inputorder +1;
  drop order;
run;
proc sort data= _means_;
  by _rep _group_;
run;

proc sort data= &outformat;
  by _rep _group_;
run;
data &outformat;
  merge &outformat(drop=inputorder) _means_(keep= _rep _group_ inputorder);
  by _rep _group_;
run;
proc sort data= &outformat;
  by _rep inputorder;
run;

proc datasets nolist;
  delete _means_ _means2_ _meansb_ _means2b_ _freqg_ _freqn_ _freq_ ;
run ;
quit; 

%mend reformatXPT;

data _null_;
run;

/************************************************************************************/
/*                                 Utility macros                                   */
/************************************************************************************/
data _null_;
run;

/* 
Macro defined 03-02-2007
This macro %_counts_ allows to count number of words in a string.
The first argument is the string
split allows to specify the character that splits between the words
If split is empty it will just estimate the number of different words.

This will be used to count the number of variables in a list of variables.
This is just a utility macro
*/
%macro _counts_(arg1, text=&arg1, notes=, split=%str( ));
  %local i; %let i=0;
  %do %while(%length(%nrbquote(%scan(&text, &i+1, &split))));
	%let i=%eval(&i+1);
  %end;
  &i
  %if %length(&notes) %then %put NOTE: _COUNT is returning the value: &i..;
%mend _counts_;

/* eMKF v2.4: utility macro to return unique words in a string with space separators */
/* Optionally, this macro will also remove and/or add specified word(s) */
%macro _unique_(_oldvar, remove=%str(), add=%str()) / minoperator;
  %local _ii_ _newvar; %let _ii_ = 0;
  %if &add ^= %str() %then %do; /* assumes word(s) to add already separated using spaces */
  	%let _oldvar = &_oldvar &add;
  %end;
  %do _ii_ = 1 %to %_counts_(&_oldvar, split=%str( ));
	%if %symexist(loc_%scan(&_oldvar, &_ii_)) = 0 %then %do;
		%local loc_%scan(&_oldvar, &_ii_); 
		%let loc_%scan(&_oldvar, &_ii_) = 1;
		%if &remove = %str() %then %do;
			%let _newvar = &_newvar %scan(&_oldvar, &_ii_);
		%end;
		%if &remove ^= %str() %then %do;
			%if not(%upcase(%scan(&_oldvar, &_ii_)) in %upcase(&remove)) %then %do;
				%let _newvar = &_newvar %scan(&_oldvar, &_ii_);
			%end;
		%end;
	%end;
  %end;
  &_newvar
%mend _unique_;

/* 
Macro defined 03-02-2007
These 2 %zeros and %zeross macros just prints a number of zeros.
They respectively print them with and without comma.
 This is used in the non-linear mixed model to define parameter mean values.
*/

%macro zeros(t);
0
%do j = 1 %to %eval(&t-1);
 ,0
%end;
%mend zeros; 

%macro zeross(t);
0
%do j = 1 %to %eval(&t-1);
  0
%end;
%mend zeross; 

/* eMKF: Just like %zeross, this macro prints the specified constant a number of times */
%macro cnstss(v, t);
%sysevalf(&v)
%do j = 1 %to %eval(&t-1);
  %sysevalf(&v)
%end;
%mend cnstss; 

/* eMKF: This is the autoregressive covariance matrix from RAND used for random effects in proc nlmixed */
/* Compare to covariance matrix used in the built-in MVNAR distribution in proc mcmc */
%macro thevarcomp(t=, nu=, vrho= , delta= );
	%local ii_ jj_ kk_ ll_  _nn _tvar1 _tvar2 rr_ rr2_ nu_;
	%let _tvar1=; %let _tvar2=;
	%let ii_=0; %let jj_=0; %let kk_=0; %let ll_=0; /* eMKF: added to initialize values */
	%let _nn=0; %let _nn= %_counts_(&delta); %let _nn= %eval(&_nn + 1);
	[
	%do ii_ = 1 %to &_nn;
		%if &ii_=1 %then %do;
	  		%do jj_ = 1 %to &t;
   				%if &jj_ > 1 %then %do;
    				%do kk_ = 1 %to %eval(&jj_ -1);
     					%if %eval(&jj_ -&kk_ ) ne 1 %then ,&vrho.**%eval(&jj_ -&kk_ )*&nu ;
     					%if %eval(&jj_ -&kk_ ) =  1 %then ,&vrho.*&nu ;
    				%end; 
   				%end; 
   				%if &jj_ > 1 %then , ;
   				&nu
  			%end; 
 		%end;
	 	%if &ii_ > 1 %then %do;
	    	%let _tvar1=%scan( &delta, %eval(&ii_-1));
	     	%let nu_=;
	  		%do jj_ = 1 %to &t;
	  			%do ll_ =1 %to &ii_;
	   				%if &ll_ > 1 %then  %let _tvar2=%scan(&delta, %eval(&ll_-1));
	   				%if &ll_ < &ii_ %then %do;
	   					%let nu_=;
	   					%if &ll_ = 1 %then %let nu_ = &_tvar1.*&nu ;
	   					%if &ll_ > 1 %then %let nu_ = &_tvar2.*&_tvar1.*&nu ;
	    				%do kk_ = 1 %to &t;
	    					%let rr_= %eval(&jj_ -&kk_ );
	    					%let rr2_= %eval(&kk_ -&jj_ );
	      					%if &rr_ =  0  %then %do; ,&nu_ %end;
	      					%if &rr_ < 0 and &rr2_ ne 1 %then %do; ,&vrho.**&rr2_.*&nu_ %end;
	      					%if &rr_ > 0 and &rr_ ne 1 %then %do; ,&vrho.**&rr_.*&nu_ %end; 
	      					%if &rr_ < 0 and &rr2_ = 1 %then %do; ,&vrho.*&nu_ %end;
	      					%if &rr_ > 0 and &rr_  = 1 %then %do; ,&vrho.*&nu_ %end; 
	    				%end; 
	    			%end; 
	      			%if &ll_ = &ii_ %then %do;
	      				%let nu_=;
	      				%let nu_ = &_tvar1.**2*&nu ;
	   					%if &jj_ > 1 %then %do;
	    					%do kk_ = 1 %to %eval(&jj_ -1);
	     						%if %eval(&jj_ -&kk_ ) ne 1 %then ,&vrho.**%eval(&jj_ -&kk_ )*&nu_ ;
	     						%if %eval(&jj_ -&kk_ ) =  1 %then ,&vrho.*&nu_ ;
	    					%end; 
	   					%end; 
	   					,&nu_
	    			%end; 
	   			%end; 
  			%end; 
 		%end; 
	%end;
	]
%mend thevarcomp;

/* eMKF: This is a modified/simplified version of original thevarcomp macro to allow for unequally spaced or noninteger times */
/* eMKF: Also corrected how delta = 0 was handled, which should have been equivalent to delta = %str() */

%macro thevarcompr(times= , nu=, vrho= );
	%local jj_ kk_ tj_ tk_ t;
	%let jj_ = 0; %let kk_ = 0; %let tj_ = 0; %let tk_ = 0; 
	%let t=0; %let t = %_counts_(&times);
	[
  	%do jj_ = 1 %to &t;
	    %let tj_ = %scan(&times, &jj_, character=" ");
   		%if &jj_ > 1 %then %do;
    		%do kk_ = 1 %to %eval(&jj_ - 1);
			   	%let tk_ = %scan(&times, &kk_, character=" ");
     			, &vrho.**%sysevalf(&tj_ - &tk_)*&nu 
    		%end; 
   		%end; 
   		%if &jj_ > 1 %then , ;
   		&nu
  	%end; 
	]
%mend thevarcompr;

data _null_;
run;

/****************************************************************************
 * eMKF
 * Wrapper macros to compile applicable Gibbs samplers for use with proc mcmc
 * Makram Talih, Ph.D. (NCHS contractor)
 ****************************************************************************/
data _null_;
run;

/**************************************************/
/* eMKF: Gibbs sampler for true state predictions */
/**************************************************/
%macro gibbs_uds_compile_EP(g=, n=, loc=);

%local uloc;
%let uloc = &loc..uds;
 
proc fcmp outlib=&uloc; 			

	subroutine EP(etaarr[*],			/* 1-dimensional array (length gn) of updated values of true states */
				  etamnarr[*],			/* 1-dimensional array (length gn) of predictions from regression */
				  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
				  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
				  rts[*],				/* 1-dimensional array (length n) of real times */
				  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
				  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
				  );

	outargs etaarr;						/* arguments that are updated after execution */

	array Yvec[&n, 1]					/nosym; /* vector (nx1) for use in calculations */
	array Xbeta[&n, 1]					/nosym;	/* holds matrix multiplication */
	array Wgamma[&n, &n]   				/nosym;	/* Vgamma^{-1} */
	array Vg[&n, &n]  					/nosym;	/* Vgamma + sampling variances */
	array Wg[&n, &n]   					/nosym;	/* (Vgamma + sampling variances)^{-1} */
	array petas[&n, 1]					/nosym;	/* contribution to posterior mean from random effects prior */
	array yetas[&n, 1]					/nosym;	/* contribution to posterior mean from data*/
	array etas[&n, 1]					/nosym;	/* sampled vector (nx1) of group-specific etas */
	array EE[&n, &n] 					/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
	array EI[&n, &n] 					/nosym;	/* inverse of EE */

	do k = 1 to &g;
		do i = 1 to &n;							/* predictions from regression for group k */
			Xbeta[i,1] = etamnarr[(k-1)*&n+i];	
		end;
	    call zeromatrix(Wgamma);													/* Wgamma = Vgamma^{-1} is tridiagonal */
		Wgamma[1,1] = (1/((1-(rhoarr[k]**(2*(rts[2]-rts[1]))))*nuarr[k]));			/* First main diagonal entry */
		do j = 2 to &n-1; 															/* Intermediate main diagonal entries */
			Wgamma[j,j] = ((1-(rhoarr[k]**(2*(rts[j+1]-rts[j-1]))))
				 	        /((1-(rhoarr[k]**(2*(rts[j+1]-rts[j]))))
				  		  	  *(1-(rhoarr[k]**(2*(rts[j]-rts[j-1]))))*nuarr[k])); 
  		end; 
		Wgamma[&n,&n]= (1/((1-(rhoarr[k]**(2*(rts[&n]-rts[&n-1]))))*nuarr[k])); 	/* Last main diagonal entry */
		do i = 1 to &n-1;															/* Entries in second and third diagonals */
			Wgamma[i,i+1] = -(rhoarr[k]**(rts[i+1]-rts[i]))
						 	/((1-(rhoarr[k]**(2*(rts[i+1]-rts[i]))))*nuarr[k]); 
			Wgamma[i+1,i] = Wgamma[i,i+1]; 
  		end; 
		call mult(Wgamma, Xbeta, petas);		/* contribution to posterior mean from random effects prior */
		call zeromatrix(Vg); 					/* initialize Vg to all zeroes */
		do j = 1 to &n;							
			Yvec[j,1] = Yarr[(k-1)*&n + j]; 	/* populate nx1 data vector Yvec */
			Vg[j,j] = 1/Sarr[(k-1)*&n + j]; 	/* populate diagonal entries of Vg using sampling precisions */
		end;
		call mult(Vg, Yvec, yetas);				/* contribution to posterior mean from data */
		call addmatrix(yetas, petas,petas); 	/* sum of prior and data contributions */
		call addmatrix(Wgamma, Vg, Wg);			/* precision matrix Wg = sum of Wgamma and diagonal of sampling precisions */
		do i = 1 to &n;
			etas[i,1] = rand('normal');			/* sample from univariate standard normal */
		end;
		call chol(Wg, EE);						/* calculate Cholesky decomposition for precision matrix (returns lower triangular) */
		call inv(EE, EI);						/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(EI, petas, petas);			/* re-scale petas (part 1) */
		call transpose(EI, EI);					/* transpose */
		call mult(EI, petas, petas);			/* re-scale petas (part 2) */
		call mult(EI, etas, etas);				/* re-scale etas */
		call addmatrix(petas, etas, etas);		/* re-center */
		do j = 1 to &n;
			etaarr[(k-1)*&n+j] = etas[j,1];		/* output argument etaarr is an array of group by time state predictions */
		end;
	end;

	endsub;
run;
quit;

%mend gibbs_uds_compile_EP;

data _null_;
run;

/*****************************************************/
/* eMKF: Gibbs sampler for random sampling variances */
/*****************************************************/
%macro gibbs_uds_compile_RP(g=, n=, loc=);

%local uloc;
%let uloc = &loc..uds;
 
proc fcmp outlib=&uloc; 			

	subroutine RP(varr[*],				/* 1-dimensional array (length g) of updated values of true variances */
				  vhyp[*],				/* shape and scale for inverse gamma prior */
				  Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
				  Narr[*]				/* 1-dimensional array for _n from dataset */
				  );

	outargs varr;						/* arguments that are updated after execution */

	do k = 1 to &g;	
		pvshape = vhyp[1];				/* shape parameter for inverse gamma prior */
		pvscale = vhyp[2];				/* scale parameter for inverse gamma prior */
		do j = 1 to &n;
			pvshape = pvshape + ((Narr[(k-1)*&n + j] - 1) / 2);
			pvscale = pvscale + ((Narr[(k-1)*&n + j] - 1) * Sarr[(k-1)*&n + j] / 2);
		end;
		varr[k] = 1/rand('gamma', pvshape, 1/pvscale);
	end;

	endsub;
run;
quit;

%mend gibbs_uds_compile_RP;

data _null_;
run;

/*************************************************************************************/
/* eMKF: Gibbs samplers for mean hyper-parameters in the fully Bayesian trend models */
/*************************************************************************************/
%macro gibbs_uds_compile_MP(uvar=, g=, loc=) / minoperator; /* eMKF v2.4 streamlining: added minoperator keyword */

/* eMKF: return if no applicable model is indicated */
%if not(%upcase(&uvar) in FULL_LINEAR FULL_QUAD FULL_CUBIC) %then %do;
	/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
	%put ERROR: No Gibbs sampler for mean hyper-parameters was found for the specified model &uvar: Please check!;
	%return;
%end;

%local uloc;
%let uloc = &loc..uds;

%if %upcase(&uvar) = FULL_LINEAR %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_bfl(mb1,					/* updated value of prior mean mb1 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  sb1					/* updated value of prior SD sb1 from M-H sampler */
						  );

		outargs mb1, mbetag, Dbetag;			/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[2,1] = mb1; 
		Dbetag[2,2] = 1/sb1**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_QUAD %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_bfq(mb1,					/* updated value of prior mean mb1 */
						  mb2,					/* updated value of prior mean mb2 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 */
						  sb1,					/* updated value of prior SD sb1 from M-H sampler */
						  sb2					/* updated value of prior SD sb2 from M-H sampler */
						  );

		outargs mb1, mb2, mbetag, Dbetag;		/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[2,1] = mb1; 
		Dbetag[2,2] = 1/sb1**2;

		/*************************/
		/* Update prior mean mb2 */
		/*************************/
		b2mn = 0;
		do k = 1 to &g;
			b2mn = b2mn + b2g[k];
		end;
		mb2mn = ((b2mn/mb2hyp[2]) + (mb2hyp[1]*(sb2**2)))/((&g/mb2hyp[2]) + (sb2**2));
		mb2sd = 1/sqrt(mb2hyp[2] + (&g/(sb2**2)));
		mb2 = mb2mn + mb2sd*rand('normal');

		mbetag[3,1] = mb2; 
		Dbetag[3,3] = 1/sb2**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_CUBIC %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_bfc(mb1,					/* updated value of prior mean mb1 */
						  mb2,					/* updated value of prior mean mb2 */
						  mb3,					/* updated value of prior mean mb3 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 */
						  mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 */
						  sb1,					/* updated value of prior SD sb1 from M-H sampler */
						  sb2,					/* updated value of prior SD sb2 from M-H sampler */
						  sb3					/* updated value of prior SD sb3 from M-H sampler */
						  );

		outargs mb1, mb2, mb3, mbetag, Dbetag;	/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[2,1] = mb1; 
		Dbetag[2,2] = 1/sb1**2;

		/*************************/
		/* Update prior mean mb2 */
		/*************************/
		b2mn = 0;
		do k = 1 to &g;
			b2mn = b2mn + b2g[k];
		end;
		mb2mn = ((b2mn/mb2hyp[2]) + (mb2hyp[1]*(sb2**2)))/((&g/mb2hyp[2]) + (sb2**2));
		mb2sd = 1/sqrt(mb2hyp[2] + (&g/(sb2**2)));
		mb2 = mb2mn + mb2sd*rand('normal');

		mbetag[3,1] = mb2; 
		Dbetag[3,3] = 1/sb2**2;

		/*************************/
		/* Update prior mean mb3 */
		/*************************/
		b3mn = 0;
		do k = 1 to &g;
			b3mn = b3mn + b3g[k];
		end;
		mb3mn = ((b3mn/mb3hyp[2]) + (mb3hyp[1]*(sb3**2)))/((&g/mb3hyp[2]) + (sb3**2));
		mb3sd = 1/sqrt(mb3hyp[2] + (&g/(sb3**2)));
		mb3 = mb3mn + mb3sd*rand('normal');

		mbetag[4,1] = mb3; 
		Dbetag[4,4] = 1/sb3**2;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_MP;

data _null_;
run;

/***********************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for mean hyper-parameters in the fully Bayesian trend models with trend shift */
/***********************************************************************************************************/
%macro gibbs_uds_compile_MP_xptl(uvar=, g=, loc=) / minoperator;

%if not(%upcase(&uvar) in FULL_LINEAR FULL_QUAD FULL_CUBIC) %then %do;
	%put ERROR: No Gibbs sampler for mean hyper-parameters was found for the specified model &uvar: Please check!;
	%return;
%end;

%local uloc;
%let uloc = &loc..uds;

%if %upcase(&uvar) = FULL_LINEAR %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptl_bfl(
						  mb1,					/* updated value of prior mean mb1 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  sb1					/* updated value of prior SD sb1 from M-H sampler */
						  );

		outargs mb1, mbetag, Dbetag;			/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[3,1] = mb1; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[3,3] = 1/sb1**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_QUAD %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptl_bfq(
						  mb1,					/* updated value of prior mean mb1 */
						  mb2,					/* updated value of prior mean mb2 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 */
						  sb1,					/* updated value of prior SD sb1 from M-H sampler */
						  sb2					/* updated value of prior SD sb2 from M-H sampler */
						  );

		outargs mb1, mb2, mbetag, Dbetag;		/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[3,1] = mb1; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[3,3] = 1/sb1**2;

		/*************************/
		/* Update prior mean mb2 */
		/*************************/
		b2mn = 0;
		do k = 1 to &g;
			b2mn = b2mn + b2g[k];
		end;
		mb2mn = ((b2mn/mb2hyp[2]) + (mb2hyp[1]*(sb2**2)))/((&g/mb2hyp[2]) + (sb2**2));
		mb2sd = 1/sqrt(mb2hyp[2] + (&g/(sb2**2)));
		mb2 = mb2mn + mb2sd*rand('normal');

		mbetag[4,1] = mb2; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[4,4] = 1/sb2**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_CUBIC %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptl_bfc(
						  mb1,				 	/* updated value of prior mean mb1 */
						  mb2,					/* updated value of prior mean mb2 */
						  mb3,					/* updated value of prior mean mb3 */
						  mbetag[*,*], 			/* updated prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix (p x p) of prior precisions for regression coefficients */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						  mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 */
						  mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 */
						  mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 */
						  sb1,					/* updated value of prior SD sb1 from M-H sampler */
						  sb2,					/* updated value of prior SD sb2 from M-H sampler */
						  sb3					/* updated value of prior SD sb3 from M-H sampler */
						  );

		outargs mb1, mb2, mb3, mbetag, Dbetag;	/* arguments that are updated after execution */

		/*************************/
		/* Update prior mean mb1 */
		/*************************/
		b1mn = 0;
		do k = 1 to &g;
			b1mn = b1mn + b1g[k];
		end;
		mb1mn = ((b1mn/mb1hyp[2]) + (mb1hyp[1]*(sb1**2)))/((&g/mb1hyp[2]) + (sb1**2));
		mb1sd = 1/sqrt(mb1hyp[2] + (&g/(sb1**2)));
		mb1 = mb1mn + mb1sd*rand('normal');

		mbetag[3,1] = mb1; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[3,3] = 1/sb1**2;

		/*************************/
		/* Update prior mean mb2 */
		/*************************/
		b2mn = 0;
		do k = 1 to &g;
			b2mn = b2mn + b2g[k];
		end;
		mb2mn = ((b2mn/mb2hyp[2]) + (mb2hyp[1]*(sb2**2)))/((&g/mb2hyp[2]) + (sb2**2));
		mb2sd = 1/sqrt(mb2hyp[2] + (&g/(sb2**2)));
		mb2 = mb2mn + mb2sd*rand('normal');

		mbetag[4,1] = mb2; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[4,4] = 1/sb2**2;

		/*************************/
		/* Update prior mean mb3 */
		/*************************/
		b3mn = 0;
		do k = 1 to &g;
			b3mn = b3mn + b3g[k];
		end;
		mb3mn = ((b3mn/mb3hyp[2]) + (mb3hyp[1]*(sb3**2)))/((&g/mb3hyp[2]) + (sb3**2));
		mb3sd = 1/sqrt(mb3hyp[2] + (&g/(sb3**2)));
		mb3 = mb3mn + mb3sd*rand('normal');

		mbetag[5,1] = mb3; 						/* eMKF v2.4: indices revised b/c of two intercept columns */
		Dbetag[5,5] = 1/sb3**2;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_MP_xptl;

data _null_;
run;

/****************************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for mean hyper-parameters in the fully Bayesian trend models with full trend break */
/****************************************************************************************************************/
%macro gibbs_uds_compile_MP_xptf(uvar=, s2uvar=, g=, loc=) / minoperator;

%if not(%upcase(&uvar) in FULL_LINEAR FULL_QUAD FULL_CUBIC) %then %do;
	%put ERROR: No Gibbs sampler for mean hyper-parameters was found for the segment 1 model &uvar: Please check!;
	%return;
%end;
%if not(%upcase(&s2uvar) in FULL_LINEAR FULL_QUAD FULL_CUBIC) %then %do;
	%put ERROR: No Gibbs sampler for mean hyper-parameters was found for the segment 2 model &s2uvar: Please check!;
	%return;
%end;
%if (%upcase(&uvar) = FULL_LINEAR and %upcase(&s2uvar) ^= FULL_LINEAR) or (%upcase(&uvar) = FULL_QUAD and %upcase(&s2uvar) = FULL_CUBIC) %then %do;
	%put ERROR: Model combination &uvar for segment 1 and &s2uvar for segment 2 is not supported: Please check!;
	%return;
%end;

%local uloc;
%let uloc = &loc..uds;

%if %upcase(&uvar) = FULL_LINEAR and %upcase(&s2uvar) = FULL_LINEAR %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfl_bfl(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s2sb1					/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s2mb1,mbetag,Dbetag;		/* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[4,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[4,4] = 1/s2sb1**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_QUAD and %upcase(&s2uvar) = FULL_LINEAR %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfq_bfl(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s1mb2,			    /* updated value of prior mean mb2 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s1mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s1sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 1 */
						  s2sb1					/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s1mb2,s2mb1,mbetag,Dbetag;/* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 1 */
		/**************************************/
		s1b2mn = 0;
		do k = 1 to &g;
			s1b2mn = s1b2mn + s1b2g[k];
		end;
		s1mb2mn = ((s1b2mn/s1mb2hyp[2]) + (s1mb2hyp[1]*(s1sb2**2)))/((&g/s1mb2hyp[2]) + (s1sb2**2));
		s1mb2sd = 1/sqrt(s1mb2hyp[2] + (&g/(s1sb2**2)));
		s1mb2 = s1mb2mn + s1mb2sd*rand('normal');

		mbetag[3,1] = s1mb2;
		Dbetag[3,3] = 1/s1sb2**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[5,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[5,5] = 1/s2sb1**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_QUAD and %upcase(&s2uvar) = FULL_QUAD %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfq_bfq(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s1mb2,			    /* updated value of prior mean mb2 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  s2mb2,				/* updated value of prior mean mb2 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s1mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s2mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s1sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 1 */
						  s2sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  s2sb2					/* updated value of prior SD sb2 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s1mb2,s2mb1,s2mb2,mbetag,Dbetag;	/* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 1 */
		/**************************************/
		s1b2mn = 0;
		do k = 1 to &g;
			s1b2mn = s1b2mn + s1b2g[k];
		end;
		s1mb2mn = ((s1b2mn/s1mb2hyp[2]) + (s1mb2hyp[1]*(s1sb2**2)))/((&g/s1mb2hyp[2]) + (s1sb2**2));
		s1mb2sd = 1/sqrt(s1mb2hyp[2] + (&g/(s1sb2**2)));
		s1mb2 = s1mb2mn + s1mb2sd*rand('normal');

		mbetag[3,1] = s1mb2;
		Dbetag[3,3] = 1/s1sb2**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[5,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[5,5] = 1/s2sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 2 */
		/**************************************/
		s2b2mn = 0;
		do k = 1 to &g;
			s2b2mn = s2b2mn + s2b2g[k];
		end;
		s2mb2mn = ((s2b2mn/s2mb2hyp[2]) + (s2mb2hyp[1]*(s2sb2**2)))/((&g/s2mb2hyp[2]) + (s2sb2**2));
		s2mb2sd = 1/sqrt(s2mb2hyp[2] + (&g/(s2sb2**2)));
		s2mb2 = s2mb2mn + s2mb2sd*rand('normal');

		mbetag[6,1] = s2mb2; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[6,6] = 1/s2sb2**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_CUBIC and %upcase(&s2uvar) = FULL_LINEAR %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfc_bfl(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s1mb2,			    /* updated value of prior mean mb2 in segment 1 */
						  s1mb3,			    /* updated value of prior mean mb3 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s1mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 1 */
						  s1mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s1sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 1 */
						  s1sb3,				/* updated value of prior SD sb3 from M-H sampler in segment 1 */
						  s2sb1					/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s1mb2,s1mb3,s2mb1,mbetag,Dbetag;		/* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 1 */
		/**************************************/
		s1b2mn = 0;
		do k = 1 to &g;
			s1b2mn = s1b2mn + s1b2g[k];
		end;
		s1mb2mn = ((s1b2mn/s1mb2hyp[2]) + (s1mb2hyp[1]*(s1sb2**2)))/((&g/s1mb2hyp[2]) + (s1sb2**2));
		s1mb2sd = 1/sqrt(s1mb2hyp[2] + (&g/(s1sb2**2)));
		s1mb2 = s1mb2mn + s1mb2sd*rand('normal');

		mbetag[3,1] = s1mb2;
		Dbetag[3,3] = 1/s1sb2**2;

		/**************************************/
		/* Update prior mean mb3 in segment 1 */
		/**************************************/
		s1b3mn = 0;
		do k = 1 to &g;
			s1b3mn = s1b3mn + s1b3g[k];
		end;
		s1mb3mn = ((s1b3mn/s1mb3hyp[2]) + (s1mb3hyp[1]*(s1sb3**2)))/((&g/s1mb3hyp[2]) + (s1sb3**2));
		s1mb3sd = 1/sqrt(s1mb3hyp[2] + (&g/(s1sb3**2)));
		s1mb3 = s1mb3mn + s1mb3sd*rand('normal');

		mbetag[4,1] = s1mb3;
		Dbetag[4,4] = 1/s1sb3**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[6,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[6,6] = 1/s2sb1**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_CUBIC and %upcase(&s2uvar) = FULL_QUAD %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfc_bfq(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s1mb2,			    /* updated value of prior mean mb2 in segment 1 */
						  s1mb3,			    /* updated value of prior mean mb3 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  s2mb2,				/* updated value of prior mean mb2 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s1mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 1 */
						  s1mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s2mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s1sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 1 */
						  s1sb3,				/* updated value of prior SD sb3 from M-H sampler in segment 1 */
						  s2sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  s2sb2					/* updated value of prior SD sb2 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s1mb2,s1mb3,s2mb1,s2mb2,mbetag,Dbetag;	 /* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 1 */
		/**************************************/
		s1b2mn = 0;
		do k = 1 to &g;
			s1b2mn = s1b2mn + s1b2g[k];
		end;
		s1mb2mn = ((s1b2mn/s1mb2hyp[2]) + (s1mb2hyp[1]*(s1sb2**2)))/((&g/s1mb2hyp[2]) + (s1sb2**2));
		s1mb2sd = 1/sqrt(s1mb2hyp[2] + (&g/(s1sb2**2)));
		s1mb2 = s1mb2mn + s1mb2sd*rand('normal');

		mbetag[3,1] = s1mb2;
		Dbetag[3,3] = 1/s1sb2**2;

		/**************************************/
		/* Update prior mean mb3 in segment 1 */
		/**************************************/
		s1b3mn = 0;
		do k = 1 to &g;
			s1b3mn = s1b3mn + s1b3g[k];
		end;
		s1mb3mn = ((s1b3mn/s1mb3hyp[2]) + (s1mb3hyp[1]*(s1sb3**2)))/((&g/s1mb3hyp[2]) + (s1sb3**2));
		s1mb3sd = 1/sqrt(s1mb3hyp[2] + (&g/(s1sb3**2)));
		s1mb3 = s1mb3mn + s1mb3sd*rand('normal');

		mbetag[4,1] = s1mb3;
		Dbetag[4,4] = 1/s1sb3**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[6,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[6,6] = 1/s2sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 2 */
		/**************************************/
		s2b2mn = 0;
		do k = 1 to &g;
			s2b2mn = s2b2mn + s2b2g[k];
		end;
		s2mb2mn = ((s2b2mn/s2mb2hyp[2]) + (s2mb2hyp[1]*(s2sb2**2)))/((&g/s2mb2hyp[2]) + (s2sb2**2));
		s2mb2sd = 1/sqrt(s2mb2hyp[2] + (&g/(s2sb2**2)));
		s2mb2 = s2mb2mn + s2mb2sd*rand('normal');

		mbetag[7,1] = s2mb2; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[7,7] = 1/s2sb2**2;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = FULL_CUBIC and %upcase(&s2uvar) = FULL_CUBIC %then %do;
	proc fcmp outlib=&uloc; 			

		subroutine MP_xptf_bfc_bfc(
						  s1mb1,			    /* updated value of prior mean mb1 in segment 1 */
						  s1mb2,			    /* updated value of prior mean mb2 in segment 1 */
						  s1mb3,			    /* updated value of prior mean mb3 in segment 1 */
						  s2mb1,				/* updated value of prior mean mb1 in segment 2 */
						  s2mb2,				/* updated value of prior mean mb2 in segment 2 */
						  s2mb3,				/* updated value of prior mean mb3 in segment 2 */
						  mbetag[*,*], 			/* updated prior mean vector ((s1p+s2p) x 1) for regression coefficients */
						  Dbetag[*,*], 			/* updated diagonal matrix ((s1p+s2p) x (s1p+s2p)) of prior precisions for regression coefficients */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  s2b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 2 */
						  s1mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 1 */
						  s1mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 1 */
						  s1mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 in segment 1 */
						  s2mb1hyp[*],			/* hyper prior mean [1] and precision [2] for mb1 in segment 2 */
						  s2mb2hyp[*],			/* hyper prior mean [1] and precision [2] for mb2 in segment 2 */
						  s2mb3hyp[*],			/* hyper prior mean [1] and precision [2] for mb3 in segment 2 */
						  s1sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 1 */
						  s1sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 1 */
						  s1sb3,				/* updated value of prior SD sb3 from M-H sampler in segment 1 */
						  s2sb1,				/* updated value of prior SD sb1 from M-H sampler in segment 2 */
						  s2sb2,				/* updated value of prior SD sb2 from M-H sampler in segment 2 */
						  s2sb3					/* updated value of prior SD sb3 from M-H sampler in segment 2 */
						  );

		outargs s1mb1,s1mb2,s1mb3,s2mb1,s2mb2,s2mb3,mbetag,Dbetag; /* arguments that are updated after execution */

		/**************************************/
		/* Update prior mean mb1 in segment 1 */
		/**************************************/
		s1b1mn = 0;
		do k = 1 to &g;
			s1b1mn = s1b1mn + s1b1g[k];
		end;
		s1mb1mn = ((s1b1mn/s1mb1hyp[2]) + (s1mb1hyp[1]*(s1sb1**2)))/((&g/s1mb1hyp[2]) + (s1sb1**2));
		s1mb1sd = 1/sqrt(s1mb1hyp[2] + (&g/(s1sb1**2)));
		s1mb1 = s1mb1mn + s1mb1sd*rand('normal');

		mbetag[2,1] = s1mb1;
		Dbetag[2,2] = 1/s1sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 1 */
		/**************************************/
		s1b2mn = 0;
		do k = 1 to &g;
			s1b2mn = s1b2mn + s1b2g[k];
		end;
		s1mb2mn = ((s1b2mn/s1mb2hyp[2]) + (s1mb2hyp[1]*(s1sb2**2)))/((&g/s1mb2hyp[2]) + (s1sb2**2));
		s1mb2sd = 1/sqrt(s1mb2hyp[2] + (&g/(s1sb2**2)));
		s1mb2 = s1mb2mn + s1mb2sd*rand('normal');

		mbetag[3,1] = s1mb2;
		Dbetag[3,3] = 1/s1sb2**2;

		/**************************************/
		/* Update prior mean mb3 in segment 1 */
		/**************************************/
		s1b3mn = 0;
		do k = 1 to &g;
			s1b3mn = s1b3mn + s1b3g[k];
		end;
		s1mb3mn = ((s1b3mn/s1mb3hyp[2]) + (s1mb3hyp[1]*(s1sb3**2)))/((&g/s1mb3hyp[2]) + (s1sb3**2));
		s1mb3sd = 1/sqrt(s1mb3hyp[2] + (&g/(s1sb3**2)));
		s1mb3 = s1mb3mn + s1mb3sd*rand('normal');

		mbetag[4,1] = s1mb3;
		Dbetag[4,4] = 1/s1sb3**2;

		/**************************************/
		/* Update prior mean mb1 in segment 2 */
		/**************************************/
		s2b1mn = 0;
		do k = 1 to &g;
			s2b1mn = s2b1mn + s2b1g[k];
		end;
		s2mb1mn = ((s2b1mn/s2mb1hyp[2]) + (s2mb1hyp[1]*(s2sb1**2)))/((&g/s2mb1hyp[2]) + (s2sb1**2));
		s2mb1sd = 1/sqrt(s2mb1hyp[2] + (&g/(s2sb1**2)));
		s2mb1 = s2mb1mn + s2mb1sd*rand('normal');

		mbetag[6,1] = s2mb1; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[6,6] = 1/s2sb1**2;

		/**************************************/
		/* Update prior mean mb2 in segment 2 */
		/**************************************/
		s2b2mn = 0;
		do k = 1 to &g;
			s2b2mn = s2b2mn + s2b2g[k];
		end;
		s2mb2mn = ((s2b2mn/s2mb2hyp[2]) + (s2mb2hyp[1]*(s2sb2**2)))/((&g/s2mb2hyp[2]) + (s2sb2**2));
		s2mb2sd = 1/sqrt(s2mb2hyp[2] + (&g/(s2sb2**2)));
		s2mb2 = s2mb2mn + s2mb2sd*rand('normal');

		mbetag[7,1] = s2mb2; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[7,7] = 1/s2sb2**2;

		/**************************************/
		/* Update prior mean mb3 in segment 2 */
		/**************************************/
		s2b3mn = 0;
		do k = 1 to &g;
			s2b3mn = s2b3mn + s2b3g[k];
		end;
		s2mb3mn = ((s2b3mn/s2mb3hyp[2]) + (s2mb3hyp[1]*(s2sb3**2)))/((&g/s2mb3hyp[2]) + (s2sb3**2));
		s2mb3sd = 1/sqrt(s2mb3hyp[2] + (&g/(s2sb3**2)));
		s2mb3 = s2mb3mn + s2mb3sd*rand('normal');

		mbetag[8,1] = s2mb3; 					/* eMKF v2.4: indices revised b/c of column order with 2 segments */
		Dbetag[8,8] = 1/s2sb3**2;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_MP_xptf;

data _null_;
run;

/**********************************************************************************/
/* eMKF: Gibbs samplers for regression coefficients in the supported trend models */
/**********************************************************************************/
%macro gibbs_uds_compile_CP(uvar=, g=, n=, loc=) / minoperator; /* eMKF v2.4 streamlining: added minoperator keyword */

/* eMKF: return if no applicable model is indicated */
%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR FULL_CUBIC FULL_QUAD FULL_LINEAR 
						  INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
	/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
	%put ERROR: No Gibbs sampler was found for the specified model &uvar: Please check!;
	%return;
%end;

%local p uloc;

/* eMKF: dimensionality (needed for UDS set up) */
%let p = 0;
%if %upcase(&uvar) = DROPPED %then %let p = 1;
%if %upcase(&uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR %then %let p = 2;
%if %upcase(&uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD %then %let p = 3;
%if %upcase(&uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC %then %let p = 4;
%let p = %eval(0+&p);

%let uloc = &loc..uds;

%if %upcase(&uvar) = DROPPED %then %do;
	/***********************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the dropped (no trend) model */
	/***********************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine  CP_b0(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, etamnarr;					/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;						
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 							
		      etamnarr[(k-1)*&n+i] = Xbeta[i,1];/* updated predictions from regression */
			end;
												/* p = 1 here */
			ag[k] = beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_LINEAR FULL_LINEAR %then %do;
	/********************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the group-specific linear trend model */
	/********************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_bgl(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1g, etamnarr;				/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* p = 2 here */
			ag[k] = beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
			b1g[k] = beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_QUAD FULL_QUAD %then %do;
	/******************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the group-specific quad trend model */
	/******************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_bgq(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1g, b2g, etamnarr;			/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;	
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* p = 3 here */
			ag[k] = beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
			b1g[k] = beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
			b2g[k] = beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_CUBIC FULL_CUBIC %then %do;
	/*******************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the group-specific cubic trend model */
	/*******************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_bgc(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1g, b2g, b3g, etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* p = 4 here */
			ag[k] = beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
			b1g[k] = beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
			b2g[k] = beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients */
			b3g[k] = beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_LINEAR %then %do;
	/******************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the common linear model */
	/******************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_b1l(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1, 					/* updated value of common linear coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1, etamnarr;				/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-1),%eval(&p-1)] /nosym;	/* cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-1), 1] 	    /nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array bXt[%eval(&p-1), &n] 				/nosym; /* transpose of design matrix (excl. intercept) */
		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array bXtW[%eval(&p-1), &n]				/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array bXtWX[%eval(&p-1), %eval(&p-1)] 	/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array bDXtWX[%eval(&p-1), %eval(&p-1)]  /nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array bprbeta[%eval(&p-1), 1]           /nosym; /* vector of regression estimates (excl. intercept) from prior */
		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-1), 1]            /nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array bzbeta[%eval(&p-1), 1]	 		/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array bbeta[%eval(&p-1), 1]		 	    /nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-1), %eval(&p-1)]     /nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array bCI[%eval(&p-1), %eval(&p-1)]     /nosym; /* inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 1 to &p-1;
			bbeta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* updated vector bX (used below) */
														/* p=2 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* sample intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			ag[k] = abeta[1,1];							/* output argument a is 1-dimensional array of group-specific intercepts */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_QUAD %then %do;
	/**********************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the common quad trend model */
	/**********************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_b1q(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1, 					/* updated value of common linear coefficient */
						  b2, 					/* updated value of common quad coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1, b2, etamnarr;			/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-1),%eval(&p-1)] /nosym;	/* cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-1), 1] 	    /nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array bXt[%eval(&p-1), &n] 				/nosym; /* transpose of design matrix (excl. intercept) */
		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array bXtW[%eval(&p-1), &n]				/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array bXtWX[%eval(&p-1), %eval(&p-1)] 	/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array bDXtWX[%eval(&p-1), %eval(&p-1)]  /nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array bprbeta[%eval(&p-1), 1]           /nosym; /* vector of regression estimates (excl. intercept) from prior */
		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-1), 1]            /nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array bzbeta[%eval(&p-1), 1]	 		/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array bbeta[%eval(&p-1), 1]		 	    /nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-1), %eval(&p-1)]     /nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array bCI[%eval(&p-1), %eval(&p-1)]     /nosym; /* inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */	
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 1 to &p-1;
			bbeta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* updated vector bX (used below) */
														/* p=3 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */
		b2 = bbeta[2,1];								/* output argument b2 is updated value of common quad coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* sample intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			ag[k] = abeta[1,1];							/* output argument a is 1-dimensional array of group-specific intercepts */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_CUBIC %then %do;
	/***********************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the common cubic trend model */
	/***********************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_b1c(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						  b1, 					/* updated value of common linear coefficient */
						  b2, 					/* updated value of common quad coefficient */
						  b3, 					/* updated value of common cubic coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs ag, b1, b2, b3, etamnarr;		/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-1),%eval(&p-1)] /nosym;	/* cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-1), 1] 	    /nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array bXt[%eval(&p-1), &n] 				/nosym; /* transpose of design matrix (excl. intercept) */
		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array bXtW[%eval(&p-1), &n]				/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array bXtWX[%eval(&p-1), %eval(&p-1)] 	/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array bDXtWX[%eval(&p-1), %eval(&p-1)]  /nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array bprbeta[%eval(&p-1), 1]           /nosym; /* vector of regression estimates (excl. intercept) from prior */
		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-1), 1]            /nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array bzbeta[%eval(&p-1), 1]	 		/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array bbeta[%eval(&p-1), 1]		 	    /nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-1), %eval(&p-1)]     /nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array bCI[%eval(&p-1), %eval(&p-1)]     /nosym; /* inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */		
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 1 to &p-1;
			bbeta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* updated vector bX (used below) */
														/* p=4 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */
		b2 = bbeta[2,1];								/* output argument b2 is updated value of common quad coefficient */
		b3 = bbeta[3,1];								/* output argument b3 is updated value of common cubic coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* sample intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			ag[k] = abeta[1,1];							/* output argument a is 1-dimensional array of group-specific intercepts */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_LINEAR %then %do;
	/*********************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA linear trend model */
	/*********************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_bmal(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...3 in the linear case) */
						   );

		outargs ag, b1g, b1, etamnarr;			/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/*************************************************************************************/
		/* Array structures for indep trend models in the full dimensional linear BMA: p = 2 */
		/*************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep linear] */
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [dropped] */

		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */

		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */

		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */

		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */

		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */

		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */

		array q2ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q1ybeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */

		array q2beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */
		array q1beta[1, 1] 	       				/nosym;	/* sampled vector (1 x 1) of regression coefficients */

		array q2CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[1, 1]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q2CI[2, 2] 					  	/nosym;	/* inverse of CC */
		array q1CI[1, 1] 					  	/nosym;	/* inverse of CC */

		/***************************************************************************************/
		/* Array structures for common trend models in the full dimensional linear BMA: p = 2  */
		/***************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[1, 1]						/nosym; /* prior mean vector (1 x 1) for intercepts */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[1, 1] 					/nosym; /* diagonal matrix (1 x 1) of prior precisions for intercepts */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep linear: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 2;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* dropped: q = 1 */
			do i = 1 to &n;
				do m = 1 to 1;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 1;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* common linear: q = 2 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 2;
					b1X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 2;
				b1mbetag[m-1, 1]   = mbetag[m, 1];
			    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 3 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific linear trend model (q=2)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
				end;
				if flg = 3 then do;							/* group-specific intercept-only model (q=1)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 1;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta, q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = 0;								/* 2nd output argument is 1-d array of group-specific linear coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
			end;
			b1 = tmpb1/&g;
		end;

		/**********************/
		/* Common trend model */
		/**********************/
		if flg = 2 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = ag[k];								/* group-specific abeta vector */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - a */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
			    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
			    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
			    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
			    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
			    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */
			end;												/* end cycle through groups */
			call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
			call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
			do m = 2 to 2;
				b1beta[m-1,1] = rand('normal');					/* sample from univariate standard normal(s) */
			end;
			call chol(b1DXtWX, b1CC);							/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
			call inv(b1CC, b1CI);								/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 1) */
			call transpose(b1CI, b1CI);							/* transpose */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 2) */
			call mult(b1CI, b1beta, b1beta);					/* re-scale beta */
			call addmatrix(b1pbeta, b1beta, b1beta);			/* re-center */
			call mult(b1X, b1beta, bXbeta);						/* updated vector bX */
			b1 = b1beta[1,1];									/* output argument b1 is updated value of common linear coefficient */
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				ag[k] = abeta[1,1];								/* output argument a is 1-dimensional array of group-specific intercepts */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD %then %do;
	/*******************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA quad trend model */
	/*******************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_bmaq(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   b2, 					/* updated value of common quad coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...5 in the quad case) */
						   );

		outargs ag, b1g, b2g, b1, b2, etamnarr;	/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/***********************************************************************************/
		/* Array structures for indep trend models in the full dimensional quad BMA: p = 3 */
		/***********************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q3X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep quad] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep linear] */
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [dropped] */

		array q3mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */

		array q3Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */

		array q3Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */

		array q3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */

		array q3DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q3prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */

		array q3pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */

		array q3ybeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q2ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q1ybeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */

		array q3beta[3, 1] 	       				/nosym;	/* sampled vector (3 x 1) of regression coefficients */
		array q2beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */
		array q1beta[1, 1] 	       				/nosym;	/* sampled vector (1 x 1) of regression coefficients */

		array q3CC[3, 3]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[1, 1]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q3CI[3, 3] 					  	/nosym;	/* inverse of CC */
		array q2CI[2, 2] 					  	/nosym;	/* inverse of CC */
		array q1CI[1, 1] 					  	/nosym;	/* inverse of CC */

		/*************************************************************************************/
		/* Array structures for common trend models in the full dimensional quad BMA: p = 3  */
		/*************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[1, 1]						/nosym; /* prior mean vector (1 x 1) for intercepts */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [common quad] */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[1, 1] 					/nosym; /* diagonal matrix (1 x 1) of prior precisions for intercepts */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array b2beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array b2CI[2, 2]     					/nosym; /* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep quad: q = 3 */
			do i = 1 to &n;
				do m = 1 to 3;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 3;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* indep linear: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 2;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 5 then do;								/* dropped: q = 1 */
			do i = 1 to &n;
				do m = 1 to 1;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 1;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* common quad: q = 3 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 3;
					b2X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 3;
				b2mbetag[m-1, 1]   = mbetag[m, 1];
			    b2Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 4 then do;								/* common linear: q = 2 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 2;
					b1X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 2;
				b1mbetag[m-1, 1]   = mbetag[m, 1];
			    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 2 or flg = 5 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific quad trend model (q=3)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 3;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients */
				end;
				if flg = 2 then do;							/* group-specific linear trend model (q=2)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = 0;								/* 3rd output argument is 1-d array of group-specific quad coefficients */
				end;
				if flg = 5 then do;							/* group-specific intercept-only model (q=1)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 1;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = 0;								/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = 0;								/* 3rd output argument is 1-d array of group-specific quad coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			tmpb2 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
				tmpb2 = tmpb2 + b2g[k];
			end;
			b1 = tmpb1/&g;
			b2 = tmpb2/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 3 or flg = 4 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = ag[k];								/* group-specific abeta vector */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - a */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 3 then do;								/* common quad trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 4 then do;								/* common linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 3 then do;									/* common quad trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 2 to 3;
					b2beta[m-1,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				b1 = b2beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b2beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
			end;
			if flg = 4 then do;									/* common linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 2 to 2;
					b1beta[m-1,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				b1 = b1beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = 0;											/* output argument b2 is updated value of common quad coefficient */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
				b2g[k] = b2;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				ag[k] = abeta[1,1];								/* output argument a is 1-dimensional array of group-specific intercepts */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC %then %do;
	/********************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA cubic trend model */
	/********************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_bmac(ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						   b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   b2, 					/* updated value of common quad coefficient */
						   b3, 					/* updated value of common cubic coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...7 in the cubic case) */
						   );

		outargs ag, b1g, b2g, b3g, b1, b2, b3, etamnarr;/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/***********************************************************************************/
		/* Array structures for indep trend models in the full dimensional cubic BMA: p = 4*/
		/***********************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q4X[&n, 4]						/nosym; /* 4-column version of the design matrix X [indep cubic] */
		array q3X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep quad] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep linear] */
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [dropped] */

		array q4mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q3mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */

		array q4Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q3Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */

		array q4Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */

		array q4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */

		array q4DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q4prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q3prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */

		array q4pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q3pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */

		array q4ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q3ybeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q2ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q1ybeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */

		array q4beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q3beta[3, 1] 	       				/nosym;	/* sampled vector (3 x 1) of regression coefficients */
		array q2beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */
		array q1beta[1, 1] 	       				/nosym;	/* sampled vector (1 x 1) of regression coefficients */

		array q4CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[3, 3]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[1, 1]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q4CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q3CI[3, 3] 					  	/nosym;	/* inverse of CC */
		array q2CI[2, 2] 					  	/nosym;	/* inverse of CC */
		array q1CI[1, 1] 					  	/nosym;	/* inverse of CC */

		/*************************************************************************************/
		/* Array structures for common trend models in the full dimensional cubic BMA: p = 4 */
		/*************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[1, 1]						/nosym; /* prior mean vector (1 x 1) for intercepts */
		array b3mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [common cubic] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [common quad] */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[1, 1] 					/nosym; /* diagonal matrix (1 x 1) of prior precisions for intercepts */
		array b3Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array b3X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb3XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb3zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[1, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b3Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[1, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[1, 1] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[1, 1] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b3DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from prior */
		array b3prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[1, 1]	 					/nosym;	/* vector (1x1) of intercepts from pooled posterior */
		array b3pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[1, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b3zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[1, 1] 						/nosym;	/* sampled vector (1x1) of intercepts */
		array b3beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[1, 1] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b3CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[1, 1] 						/nosym;	/* inverse of CC */
		array b3CI[3, 3]     					/nosym; /* inverse of CC */
		array b2CI[2, 2]     					/nosym; /* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep cubic: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q4X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q4Dbetag);
			do m = 1 to 4;
				q4mbetag[m, 1] = mbetag[m, 1];
				q4Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q4X, q4Xt);					/* transpose qX */
			call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* indep quad: q = 3 */
			do i = 1 to &n;
				do m = 1 to 3;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 3;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* indep linear: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 2;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 7 then do;								/* dropped: q = 1 */
			do i = 1 to &n;
				do m = 1 to 1;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);	
			do m = 1 to 1;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 4 then do;								/* common cubic: q = 4 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 4;
					b3X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b3Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 4;
				b3mbetag[m-1, 1]   = mbetag[m, 1];
			    b3Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b3X, b3Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb3zbeta);	
		end;
		if flg = 5 then do;								/* common quad: q = 3 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 3;
					b2X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 3;
				b2mbetag[m-1, 1]   = mbetag[m, 1];
			    b2Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 6 then do;								/* common linear: q = 2 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	do m = 2 to 2;
					b1X[i, m-1] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
			do m = 2 to 2;
				b1mbetag[m-1, 1]   = mbetag[m, 1];
			    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 2 or flg = 3 or flg = 7 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific cubic trend model (q=4)*/
					call mult(q4Xt, Wg, q4XtW);				/* multiply Xt and Wg */
					call mult(q4XtW, q4X, q4XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q4Dbetag,q4XtWX,q4DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q4XtW, Yvec, q4ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q4prbeta,q4ybeta,q4pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q4beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q4DXtWX, q4CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q4CC, q4CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q4CI, q4CI);				/* transpose */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 2) */
					call mult(q4CI, q4beta, q4beta);		/* re-scale beta */
					call addmatrix(q4pbeta,q4beta,q4beta);	/* re-center */
					call mult(q4X, q4beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q4beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q4beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = q4beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients */
					b3g[k] = q4beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 2 then do;							/* group-specific quad trend model (q=3)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 3;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients */
					b3g[k] = 0;								/* 4th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 3 then do;							/* group-specific linear trend model (q=2)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = 0;								/* 3rd output argument is 1-d array of group-specific quad coefficients */
					b3g[k] = 0;								/* 4th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 7 then do;							/* group-specific intercept-only model (q=1)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 1;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts */
					b1g[k] = 0;								/* 2nd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = 0;								/* 3rd output argument is 1-d array of group-specific quad coefficients */
					b3g[k] = 0;								/* 4th output argument is 1-d array of group-specific cubic coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			tmpb2 = 0;
			tmpb3 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
				tmpb2 = tmpb2 + b2g[k];
				tmpb3 = tmpb3 + b3g[k];
			end;
			b1 = tmpb1/&g;
			b2 = tmpb2/&g;
			b3 = tmpb3/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 4 or flg = 5 or flg = 6 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = ag[k];								/* group-specific abeta vector */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - a */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 4 then do;								/* common cubic trend model */
				  call mult(b3Xt, Wg, b3XtW);					/* multiply bXt and Wg */
				  call mult(b3XtW, b3X, b3XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
				  call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);/* cumulative matrix sum */
				end;
				if flg = 5 then do;								/* common quad trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 6 then do;								/* common linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 4 then do;									/* common cubic trend model */
				call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 2 to 4;
					b3beta[m-1,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b3DXtWX, b3CC);						/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
				call inv(b3CC, b3CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b3CI, b3CI);						/* transpose */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 2) */
				call mult(b3CI, b3beta, b3beta);				/* re-scale beta */
				call addmatrix(b3pbeta, b3beta, b3beta);		/* re-center */
				call mult(b3X, b3beta, bXbeta);					/* updated vector bX */
				b1 = b3beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b3beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
				b3 = b3beta[3,1];								/* output argument b3 is updated value of common cubic coefficient */
			end;
			if flg = 5 then do;									/* common quad trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 2 to 3;
					b2beta[m-1,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				b1 = b2beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b2beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
				b3 = 0;											/* output argument b3 is updated value of common cubic coefficient */
			end;
			if flg = 6 then do;									/* common linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 2 to 2;
					b1beta[m-1,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-1)x(p-1) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				b1 = b1beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = 0;											/* output argument b2 is updated value of common quad coefficient */
				b3 = 0;											/* output argument b3 is updated value of common cubic coefficient */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
				b2g[k] = b2;
				b3g[k] = b3;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				ag[k] = abeta[1,1];								/* output argument a is 1-dimensional array of group-specific intercepts */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_CP;

data _null_;
run;

/******************************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for regression coefficients in the supported trend models for the level break option */
/******************************************************************************************************************/
%macro gibbs_uds_compile_CP_xptl(uvar=, g=, n=, loc=) / minoperator;

%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR FULL_CUBIC FULL_QUAD FULL_LINEAR 
						  INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
	%put ERROR: No Gibbs sampler was found for the specified model &uvar: Please check!;
	%return;
%end;

%local p uloc;

/* eMKF v2.4: dimensionality (needed for UDS set up) updated to allow for two intercepts */
%let p = 0;
%if %upcase(&uvar) = DROPPED %then %let p = 2;
%if %upcase(&uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR %then %let p = 3;
%if %upcase(&uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD %then %let p = 4;
%if %upcase(&uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC %then %let p = 5;
%let p = %eval(0+&p);

%let uloc = &loc..uds;

%if %upcase(&uvar) = DROPPED %then %do;
	/*******************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the dropped (no trend) model for the level break option */
	/*******************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_b0(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, etamnarr;			/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;						
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 							
		      etamnarr[(k-1)*&n+i] = Xbeta[i,1];/* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 2 here */
			s1ag[k] = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s2ag[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_LINEAR FULL_LINEAR %then %do;
	/****************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific linear trend model for the level break option */
	/****************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_bgl(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, b1g, etamnarr;		/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 3 here */
			s1ag[k] = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s2ag[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
			b1g[k]  = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific linear coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_QUAD FULL_QUAD %then %do;
	/**************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific quad trend model for the level break option */
	/**************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_bgq(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, b1g, b2g, etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;	
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 4 here */
			s1ag[k] = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s2ag[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
			b1g[k]  = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific linear coefficients */
			b2g[k]  = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific quad coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) in INDEP_CUBIC FULL_CUBIC %then %do;
	/***************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific cubic trend model for the level break option */
	/***************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_bgc(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						  b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						  b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, b1g, b2g, b3g, etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 5 here */
			s1ag[k] = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s2ag[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
			b1g[k]  = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific linear coefficients */
			b2g[k]  = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific quad coefficients */
			b3g[k]  = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific cubic coefficients */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_LINEAR %then %do;
	/**************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common linear model for the level break option */
	/**************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_b1l(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1, 					/* updated value of common linear coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (2 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-2) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (2 x 2) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-2) x (p-2)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 2) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-2)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, b1, etamnarr;		/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 1 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_QUAD %then %do;
	/******************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common quad trend model for the level break option */
	/******************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_b1q(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1, 					/* updated value of common linear coefficient */
						  b2, 					/* updated value of common quad coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s2ag, b1, b2, etamnarr;	/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 2 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */
		b2 = bbeta[2,1];								/* output argument b2 is updated value of common quad coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_CUBIC %then %do;
	/*******************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common cubic trend model for the level break option */
	/*******************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_b1c(
						  s1ag[*], 		 		/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  b1, 					/* updated value of common linear coefficient */
						  b2, 					/* updated value of common quad coefficient */
						  b3, 					/* updated value of common cubic coefficient */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s2ag, b1,b2,b3, etamnarr;	/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 3 here */
		b1 = bbeta[1,1];								/* output argument b1 is updated value of common linear coefficient */
		b2 = bbeta[2,1];								/* output argument b2 is updated value of common quad coefficient */
		b3 = bbeta[3,1];								/* output argument b3 is updated value of common cubic coefficient */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_LINEAR %then %do;
	/************************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA linear trend model for the level break option */
	/************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptl_bmal(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...3 in the linear case) */
						   );

		outargs s1ag,s2ag, b1g, b1, etamnarr;	/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/*************************************************************************************/
		/* Array structures for indep trend models in the full dimensional linear BMA: p = 3 */
		/*************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep linear + level shift] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped + level shift] */

		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q2ybeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q2beta[3, 1] 	       				/nosym;	/* sampled vector (3 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q2CC[3, 3]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q2CI[3, 3] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/***************************************************************************************/
		/* Array structures for common trend models in the full dimensional linear BMA: p = 3  */
		/***************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep linear: q = 3 */
			do i = 1 to &n;
				do m = 1 to 3;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 3;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* common linear: q = 3 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 3;
					b1X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 3;
				b1mbetag[m-2, 1]   = mbetag[m, 1];
			    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 3 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific linear trend model (q=3)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 3;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q2beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
				end;
				if flg = 3 then do;							/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta, q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q1beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = 0;							/* 3rd output argument is 1-d array of group-specific linear coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
			end;
			b1 = tmpb1/&g;
		end;

		/**********************/
		/* Common trend model */
		/**********************/
		if flg = 2 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* matrix of intercepts s1a and s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
			    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
			    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
			    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
			    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
			    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */
			end;												/* end cycle through groups */
			call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
			call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
			do m = 3 to 3;
				b1beta[m-2,1] = rand('normal');					/* sample from univariate standard normal(s) */
			end;
			call chol(b1DXtWX, b1CC);							/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
			call inv(b1CC, b1CI);								/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 1) */
			call transpose(b1CI, b1CI);							/* transpose */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 2) */
			call mult(b1CI, b1beta, b1beta);					/* re-scale beta */
			call addmatrix(b1pbeta, b1beta, b1beta);			/* re-center */
			call mult(b1X, b1beta, bXbeta);						/* updated vector bX */
			b1 = b1beta[1,1];									/* output argument b1 is updated value of common linear coefficient */
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal for segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal for segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* matrix of intercepts s1a and s2a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD %then %do;
	/**********************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA quad trend model for the level break option */
	/**********************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptl_bmaq(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   b2, 					/* updated value of common quad coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...5 in the quad case) */
						   );

		outargs s1ag,s2ag, b1g, b2g, b1, b2, etamnarr;	/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/***********************************************************************************/
		/* Array structures for indep trend models in the full dimensional quad BMA: p = 4 */
		/***********************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q3X[&n, 4]						/nosym; /* 4-column version of the design matrix X [indep quad + level shift] */
		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep linear + level shift] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped + level shift] */

		array q3mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q3Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q3Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q3DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q3prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q3pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q3ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q2ybeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q3beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q2beta[3, 1] 	       				/nosym;	/* sampled vector (3 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q3CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[3, 3]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q3CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q2CI[3, 3] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/*************************************************************************************/
		/* Array structures for common trend models in the full dimensional quad BMA: p = 4  */
		/*************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [common quad] */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b2beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b2CI[2, 2]     					/nosym; /* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep quad: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 4;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* indep linear: q = 3 */
			do i = 1 to &n;
				do m = 1 to 3;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 3;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 5 then do;								/* dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* common quad: q = 4 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 4;
					b2X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 4;
				b2mbetag[m-2, 1]   = mbetag[m, 1];
			    b2Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 4 then do;								/* common linear: q = 3 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 3;
					b1X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 3;
				b1mbetag[m-2, 1]   = mbetag[m, 1];
			    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 2 or flg = 5 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific quad trend model (q=4)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = q3beta[4,1];					/* 4th output argument is 1-d array of group-specific quad coefficients */
				end;
				if flg = 2 then do;							/* group-specific linear trend model (q=3)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 3;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q2beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = 0;							/* 4th output argument is 1-d array of group-specific quad coefficients */
				end;
				if flg = 5 then do;							/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q1beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = 0;							/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = 0;							/* 4th output argument is 1-d array of group-specific quad coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			tmpb2 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
				tmpb2 = tmpb2 + b2g[k];
			end;
			b1 = tmpb1/&g;
			b2 = tmpb2/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 3 or flg = 4 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta column for segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta column for segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 3 then do;								/* common quad trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 4 then do;								/* common linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 3 then do;									/* common quad trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 3 to 4;
					b2beta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				b1 = b2beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b2beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
			end;
			if flg = 4 then do;									/* common linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 3 to 3;
					b1beta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				b1 = b1beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = 0;											/* output argument b2 is updated value of common quad coefficient */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
				b2g[k] = b2;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal for segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal for segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC %then %do;
	/***********************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA cubic trend model for the level break option */
	/***********************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptl_bmac(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   b1g[*], 				/* 1-dimensional array (length g) of updated values of linear coefficients by group */
						   b2g[*], 				/* 1-dimensional array (length g) of updated values of quad coefficients by group */
						   b3g[*], 				/* 1-dimensional array (length g) of updated values of cubic coefficients by group */
						   b1, 					/* updated value of common linear coefficient */
						   b2, 					/* updated value of common quad coefficient */
						   b3, 					/* updated value of common cubic coefficient */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (1...7 in the cubic case) */
						   );

		outargs s1ag,s2ag,b1g,b2g,b3g,b1,b2,b3,etamnarr;/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/***********************************************************************************/
		/* Array structures for indep trend models in the full dimensional cubic BMA: p = 4*/
		/***********************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q4X[&n, 5]						/nosym; /* 5-column version of the design matrix X [indep cubic + level shift] */
		array q3X[&n, 4]						/nosym; /* 4-column version of the design matrix X [indep quad + level shift] */
		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep linear + level shift] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped + level shift] */

		array q4mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q3mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q4Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q3Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q4Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q4XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q4XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q4DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q4prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q3prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q4pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q3pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q4ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q3ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q2ybeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q4beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q3beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q2beta[3, 1] 	       				/nosym;	/* sampled vector (3 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q4CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[3, 3]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q4CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q3CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q2CI[3, 3] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/*************************************************************************************/
		/* Array structures for common trend models in the full dimensional cubic BMA: p = 5 */
		/*************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b3mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [common cubic] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [common quad] */
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for remaining coefficients [common linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b3Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */
		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b3X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb3XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb3zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b3Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b3DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b3prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b3pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b3zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b3beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[1, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b3CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[1, 1]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b3CI[3, 3]     					/nosym; /* inverse of CC */
		array b2CI[2, 2]     					/nosym; /* inverse of CC */
		array b1CI[1, 1]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 1 then do;								/* indep cubic: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q4X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q4Dbetag);
			do m = 1 to 5;
				q4mbetag[m, 1] = mbetag[m, 1];
				q4Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q4X, q4Xt);					/* transpose qX */
			call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 2 then do;								/* indep quad: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 4;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 3 then do;								/* indep linear: q = 3 */
			do i = 1 to &n;
				do m = 1 to 3;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 3;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 7 then do;								/* dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);	
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 4 then do;								/* common cubic: q = 5 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 5;
					b3X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b3Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 5;
				b3mbetag[m-2, 1]   = mbetag[m, 1];
			    b3Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b3X, b3Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb3zbeta);	
		end;
		if flg = 5 then do;								/* common quad: q = 4 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 4;
					b2X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 4;
				b2mbetag[m-2, 1]   = mbetag[m, 1];
			    b2Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 6 then do;								/* common linear: q = 3 */
			do i = 1 to &n;								
			  	aX[i, 1] = X[i, 1];
			  	aX[i, 2] = X[i, 2];
			  	do m = 3 to 3;
					b1X[i, m-2] = X[i, m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
		  	ambetag[1,1] = mbetag[1,1];
		  	aDbetag[1,1] = Dbetag[1,1];	
		  	ambetag[2,1] = mbetag[2,1];
		  	aDbetag[2,2] = Dbetag[2,2];	
			do m = 3 to 3;
				b1mbetag[m-2, 1]   = mbetag[m, 1];
			    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 1 or flg = 2 or flg = 3 or flg = 7 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 1 then do;							/* group-specific cubic trend model (q=5)*/
					call mult(q4Xt, Wg, q4XtW);				/* multiply Xt and Wg */
					call mult(q4XtW, q4X, q4XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q4Dbetag,q4XtWX,q4DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q4XtW, Yvec, q4ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q4prbeta,q4ybeta,q4pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q4beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q4DXtWX, q4CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q4CC, q4CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q4CI, q4CI);				/* transpose */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 2) */
					call mult(q4CI, q4beta, q4beta);		/* re-scale beta */
					call addmatrix(q4pbeta,q4beta,q4beta);	/* re-center */
					call mult(q4X, q4beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q4beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q4beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q4beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = q4beta[4,1];					/* 4th output argument is 1-d array of group-specific quad coefficients */
					b3g[k]  = q4beta[5,1];					/* 5th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 2 then do;							/* group-specific quad trend model (q=4)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = q3beta[4,1];					/* 4th output argument is 1-d array of group-specific quad coefficients */
					b3g[k]  = 0;							/* 5th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 3 then do;							/* group-specific linear trend model (q=3)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 3;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k]  = q2beta[3,1];					/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k]  = 0;							/* 4th output argument is 1-d array of group-specific quad coefficients */
					b3g[k]  = 0;							/* 5th output argument is 1-d array of group-specific cubic coefficients */
				end;
				if flg = 7 then do;							/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s2ag[k] = q1beta[2,1];					/* 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
					b1g[k] = 0;								/* 3rd output argument is 1-d array of group-specific linear coefficients */
					b2g[k] = 0;								/* 4th output argument is 1-d array of group-specific quad coefficients */
					b3g[k] = 0;								/* 5th output argument is 1-d array of group-specific cubic coefficients */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmpb1 = 0;
			tmpb2 = 0;
			tmpb3 = 0;
			do k = 1 to &g;
				tmpb1 = tmpb1 + b1g[k]; 		 			/* common coefficient(s) set to average of group-specific coefficients */
				tmpb2 = tmpb2 + b2g[k];
				tmpb3 = tmpb3 + b3g[k];
			end;
			b1 = tmpb1/&g;
			b2 = tmpb2/&g;
			b3 = tmpb3/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 4 or flg = 5 or flg = 6 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 4 then do;								/* common cubic trend model */
				  call mult(b3Xt, Wg, b3XtW);					/* multiply bXt and Wg */
				  call mult(b3XtW, b3X, b3XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
				  call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);/* cumulative matrix sum */
				end;
				if flg = 5 then do;								/* common quad trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 6 then do;								/* common linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 4 then do;									/* common cubic trend model */
				call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 3 to 5;
					b3beta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b3DXtWX, b3CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b3CC, b3CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b3CI, b3CI);						/* transpose */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 2) */
				call mult(b3CI, b3beta, b3beta);				/* re-scale beta */
				call addmatrix(b3pbeta, b3beta, b3beta);		/* re-center */
				call mult(b3X, b3beta, bXbeta);					/* updated vector bX */
				b1 = b3beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b3beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
				b3 = b3beta[3,1];								/* output argument b3 is updated value of common cubic coefficient */
			end;
			if flg = 5 then do;									/* common quad trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 3 to 4;
					b2beta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				b1 = b2beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = b2beta[2,1];								/* output argument b2 is updated value of common quad coefficient */
				b3 = 0;											/* output argument b3 is updated value of common cubic coefficient */
			end;
			if flg = 6 then do;									/* common linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 3 to 3;
					b1beta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				b1 = b1beta[1,1];								/* output argument b1 is updated value of common linear coefficient */
				b2 = 0;											/* output argument b2 is updated value of common quad coefficient */
				b3 = 0;											/* output argument b3 is updated value of common cubic coefficient */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				b1g[k] = b1;
				b2g[k] = b2;
				b3g[k] = b3;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_CP_xptl;

data _null_;
run;

/***********************************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for regression coefficients in the supported trend models for the full trend break option */
/***********************************************************************************************************************/
%macro gibbs_uds_compile_CP_xptf(uvar=, s2uvar=, g=, n=, loc=) / minoperator;

%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR FULL_CUBIC FULL_QUAD FULL_LINEAR 
						  INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
	%put ERROR: No Gibbs sampler was found for the specified model &uvar: Please check!;
	%return;
%end;
%if not(%upcase(&s2uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR FULL_CUBIC FULL_QUAD FULL_LINEAR 
							INDEP_CUBIC INDEP_QUAD INDEP_LINEAR COMMON_CUBIC COMMON_QUAD COMMON_LINEAR DROPPED) %then %do;
	%put ERROR: No Gibbs sampler was found for the segment 2 model &s2uvar: Please check!;
	%return;
%end;
%if (%upcase(%substr(&uvar, 1, 3)) ^= %upcase(%substr(&s2uvar, 1, 3))) or 
	(%upcase(&uvar) = BMA_LINEAR and %upcase(&s2uvar) ^= BMA_LINEAR) or (%upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_CUBIC) or 
	(%upcase(&uvar) = FULL_LINEAR and %upcase(&s2uvar) ^= FULL_LINEAR) or (%upcase(&uvar) = FULL_QUAD and %upcase(&s2uvar) = FULL_CUBIC) or
	(%upcase(&uvar) = INDEP_LINEAR and %upcase(&s2uvar) ^= INDEP_LINEAR) or (%upcase(&uvar) = INDEP_QUAD and %upcase(&s2uvar) = INDEP_CUBIC) or
	(%upcase(&uvar) = COMMON_LINEAR and %upcase(&s2uvar) ^= COMMON_LINEAR) or (%upcase(&uvar) = COMMON_QUAD and %upcase(&s2uvar) = COMMON_CUBIC) 
	%then %do;
		%put ERROR: Model combination &uvar for segment 1 and &s2uvar for segment 2 is not supported: Please check!;
		%return;
	%end;

%local p uloc;

/* eMKF v2.4: dimensionality (needed for UDS set up) updated to allow for two segments */
%let p = 0;
%if %upcase(&uvar) = DROPPED and %upcase(&s2uvar) = DROPPED %then %let p = 2;
%if (%upcase(&uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR) and (%upcase(&s2uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR) %then %let p = 4;
%if (%upcase(&uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD) and (%upcase(&s2uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR) %then %let p = 5;
%if (%upcase(&uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD) and (%upcase(&s2uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD) %then %let p = 6;
%if (%upcase(&uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC) and (%upcase(&s2uvar) in BMA_LINEAR FULL_LINEAR INDEP_LINEAR COMMON_LINEAR) %then %let p = 6;
%if (%upcase(&uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC) and (%upcase(&s2uvar) in BMA_QUAD FULL_QUAD INDEP_QUAD COMMON_QUAD) %then %let p = 7;
%if (%upcase(&uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC) and (%upcase(&s2uvar) in BMA_CUBIC FULL_CUBIC INDEP_CUBIC COMMON_CUBIC) %then %let p = 8;
%let p = %eval(0+&p);

%let uloc = &loc..uds;

%if %upcase(&uvar) = DROPPED and %upcase(&s2uvar) = DROPPED %then %do;
	/************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the dropped-dropped model for full break option  */
	/************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b0_b0(
						  s1ag[*], 			  	/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s2ag, etamnarr;			/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;						
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 							
		      etamnarr[(k-1)*&n+i] = Xbeta[i,1];/* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 2 here */
			s1ag[k] = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s2ag[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific intercepts for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_LINEAR FULL_LINEAR) and (%upcase(&s2uvar) in INDEP_LINEAR FULL_LINEAR) %then %do;
	/******************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific linear-linear trend model for full break option */
	/******************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgl_bgl(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s2ag,s2b1g,etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 4 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s2ag[k]  = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific linear coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_QUAD FULL_QUAD) and (%upcase(&s2uvar) in INDEP_LINEAR FULL_LINEAR) %then %do;
	/****************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific quad-linear trend model for full break option */
	/****************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgq_bgl(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s1b2g,s2ag,s2b1g,etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;	
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 5 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s1b2g[k] = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
			s2ag[k]  = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_QUAD FULL_QUAD) and (%upcase(&s2uvar) in INDEP_QUAD FULL_QUAD) %then %do;
	/**************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific quad-quad trend model for full break option */
	/**************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgq_bgq(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s1b2g,s2ag,s2b1g,s2b2g,etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;	
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 6 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s1b2g[k] = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
			s2ag[k]  = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
			s2b2g[k] = beta[6,1];				/* eMKF v2.4: 6th output argument is 1-d array of group-specific quad coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_CUBIC FULL_CUBIC) and (%upcase(&s2uvar) in INDEP_LINEAR FULL_LINEAR) %then %do;
	/*****************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific cubic-linear trend model for full break option */
	/*****************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgc_bgl(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s2ag,s2b1g,etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 6 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s1b2g[k] = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
			s1b3g[k] = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
			s2ag[k]  = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[6,1];				/* eMKF v2.4: 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_CUBIC FULL_CUBIC) and (%upcase(&s2uvar) in INDEP_QUAD FULL_QUAD) %then %do;
	/***************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific cubic-quad trend model for full break option */
	/***************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgc_bgq(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s2ag,s2b1g,s2b2g,etamnarr; /* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 7 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s1b2g[k] = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
			s1b3g[k] = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
			s2ag[k]  = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[6,1];				/* eMKF v2.4: 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
			s2b2g[k] = beta[7,1];				/* eMKF v2.4: 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if (%upcase(&uvar) in INDEP_CUBIC FULL_CUBIC) and (%upcase(&s2uvar) in INDEP_CUBIC FULL_CUBIC) %then %do;
	/****************************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the group-specific cubic-cubic trend model for full break option */
	/****************************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bgc_bgc(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						  s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						  s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						  s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						  s2b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  mbetag[*,*], 			/* prior mean vector (p x 1) for regression coefficients */
						  Dbetag[*,*], 			/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  X[*,*], 				/* design matrix (n x p) using real times */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s2ag,s2b1g,s2b2g,s2b3g,etamnarr;	/* arguments that are updated after execution */

		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array Xt[&p, &n]   						/nosym;	/* transpose of design matrix */
		array XtW[&p, &n]					  	/nosym; /* matrix multiplication of Xt and Wg */
		array XtWX[&p, &p] 						/nosym; /* precision matrix of WLS regression estimators */
		array DXtWX[&p, &p]					 	/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array prbeta[&p, 1] 	    			/nosym;	/* vector (p x 1) of regression estimates from prior */
		array pbeta[&p, 1] 	    			   	/nosym;	/* vector (p x 1) of regression estimates from pooled posterior */
		array ybeta[&p, 1] 	       				/nosym;	/* vector (p x 1) of regression estimates from WLS */
		array beta[&p, 1] 	       				/nosym;	/* sampled vector (p x 1) of regression coefficients */
		array CC[&p, &p]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array CI[&p, &p] 					  	/nosym;	/* inverse of CC */
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		call transpose(X, Xt);					/* transpose X */
		call mult(Dbetag, mbetag, prbeta);		/* contribution to posterior mean from prior */
		do k = 1 to &g;							/* cycle through each group independently */
		    do i = 1 to &n;
			  Yvec[i,1]= Yarr[(k-1)*&n + i];    /* populate nx1 data vector Yvec */
			  Vg[i,i]=nuarr[k]+Sarr[(k-1)*&n+i];/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;					/* off-diagonal elements are those of AR matrix Vgamma */
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);					/* Wg = Vg^{-1} */
			call mult(Xt, Wg, XtW);				/* multiply Xt and Wg */
			call mult(XtW, X, XtWX);			/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(Dbetag,XtWX, DXtWX); /* posterior precision matrix for beta is Dbetag + XtWX */
			call mult(XtW, Yvec, ybeta);		/* contribution to posterior mean from WLS */
			call addmatrix(prbeta,ybeta,pbeta); /* sum of prior and WLS contributions */
			do m = 1 to &p;
				beta[m,1] = rand('normal');		/* sample from univariate standard normal */
			end;
			call chol(DXtWX, CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(CC, CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 1) */
			call transpose(CI, CI);				/* transpose */
			call mult(CI, pbeta, pbeta);		/* re-scale pbeta (part 2) */
			call mult(CI, beta, beta);			/* re-scale beta */
			call addmatrix(pbeta, beta, beta);	/* re-center */
			call mult(X, beta, Xbeta);			/* updated vector Xb */
			do i = 1 to &n; 								
		      etamnarr[(k-1)*&n+i]= Xbeta[i,1]; /* updated predictions from regression */
			end;
												/* eMKF v2.4: p = 8 here */
			s1ag[k]  = beta[1,1];				/* eMKF v2.4: 1st output argument is 1-d array of group-specific intercepts for segment 1 */
			s1b1g[k] = beta[2,1];				/* eMKF v2.4: 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
			s1b2g[k] = beta[3,1];				/* eMKF v2.4: 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
			s1b3g[k] = beta[4,1];				/* eMKF v2.4: 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
			s2ag[k]  = beta[5,1];				/* eMKF v2.4: 5th output argument is 1-d array of group-specific intercepts for segment 2 */
			s2b1g[k] = beta[6,1];				/* eMKF v2.4: 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
			s2b2g[k] = beta[7,1];				/* eMKF v2.4: 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
			s2b3g[k] = beta[8,1];				/* eMKF v2.4: 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_LINEAR and %upcase(&s2uvar) = COMMON_LINEAR %then %do;
	/****************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common linear-linear model for full break option */
	/****************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1l_b1l(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (2 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-2) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (2 x 2) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-2) x (p-2)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 2) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-2)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag, s1b1, s2ag, s2b1, etamnarr;		/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 2 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient in segment 1 */
		s2b1 = bbeta[2,1];								/* output argument s2b1 is updated value of common linear coefficient in segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_QUAD and %upcase(&s2uvar) = COMMON_LINEAR %then %do;
	/********************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common quad-linear trend model for full break option */
	/********************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1q_b1l(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s1b2, 				/* updated value of common quad coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1,s1b2,s2ag,s2b1,etamnarr;		/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 3 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
		s1b2 = bbeta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
		s2b1 = bbeta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_QUAD and %upcase(&s2uvar) = COMMON_QUAD %then %do;
	/******************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common quad-quad trend model for full break option */
	/******************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1q_b1q(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s1b2, 				/* updated value of common quad coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  s2b2, 				/* updated value of common quad coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1,s1b2,s2ag,s2b1,s2b2,etamnarr;	/* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 4 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
		s1b2 = bbeta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
		s2b1 = bbeta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
		s2b2 = bbeta[4,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_CUBIC and %upcase(&s2uvar) = COMMON_LINEAR %then %do;
	/*********************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common cubic-linear trend model for full break option */
	/*********************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1c_b1l(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s1b2, 				/* updated value of common quad coefficient for segment 1 */
						  s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1,s1b2,s1b3,s2ag,s2b1,etamnarr; /* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 4 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
		s1b2 = bbeta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
		s1b3 = bbeta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
		s2b1 = bbeta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_CUBIC and %upcase(&s2uvar) = COMMON_QUAD %then %do;
	/*******************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common cubic-quad trend model for full break option */
	/*******************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1c_b1q(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s1b2, 				/* updated value of common quad coefficient for segment 1 */
						  s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  s2b2, 				/* updated value of common quad coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1,s1b2,s1b3,s2ag,s2b1,s2b2,etamnarr; /* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 5 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
		s1b2 = bbeta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
		s1b3 = bbeta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
		s2b1 = bbeta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
		s2b2 = bbeta[5,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = COMMON_CUBIC and %upcase(&s2uvar) = COMMON_CUBIC %then %do;
	/********************************************************************************************************************/
	/* eMKF v2.4: Gibbs sampler for regression coefficients in the common cubic-cubic trend model for full break option */
	/********************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_b1c_b1c(
						  s1ag[*], 				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						  s1b1, 				/* updated value of common linear coefficient for segment 1 */
						  s1b2, 				/* updated value of common quad coefficient for segment 1 */
						  s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						  s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						  s2b1, 				/* updated value of common linear coefficient for segment 2 */
						  s2b2, 				/* updated value of common quad coefficient for segment 2 */
						  s2b3, 				/* updated value of common cubic coefficient for segment 2 */
						  etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						  ambetag[*,*], 		/* prior mean vector (1 x 1) for intercepts */
						  bmbetag[*,*], 		/* prior mean vector ((p-1) x 1) for remaining coefficients */
						  aDbetag[*,*], 		/* diagonal matrix (1 x 1) of prior precisions for intercepts */
						  bDbetag[*,*], 		/* diagonal matrix ((p-1) x (p-1)) of prior precisions for remaining coefficients */
						  rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						  nuarr[*],				/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						  rts[*],				/* 1-dimensional array (length n) of real times */
						  aX[*,*], 				/* conformal design submatrix (n x 1) */
						  bX[*,*], 				/* conformal design submatrix (n x (p-1)) */
						  Yarr[*], 				/* 1-dimensional array (length gn) for _y from dataset */
						  Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						  );

		outargs s1ag,s1b1,s1b2,s1b3,s2ag,s2b1,s2b2,s2b3,etamnarr; /* arguments that are updated after execution */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */
		array sumbXtWX[%eval(&p-2),%eval(&p-2)] /nosym;	/* eMKF v2.4: cumulative sum of group-specific precision matrices */
		array sumbzbeta[%eval(&p-2), 1] 	    /nosym;	/* eMKF v2.4: cumulative sum of group-specific vector of regression estimates */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array aXt[2, &n] 						/nosym;	/* eMKF v2.4: transpose of design matrix (intercepts only) */
		array bXt[%eval(&p-2), &n] 				/nosym; /* eMKF v2.4: transpose of design matrix (excl. intercepts) */
		array aXtW[2, &n] 						/nosym;	/* eMKF v2.4: matrix multiplication of Xt and Wg (intercepts only) */
		array bXtW[%eval(&p-2), &n]				/nosym; /* eMKF v2.4: matrix multiplication of Xt and Wg (excl. intercepts) */
		array aXtWX[2, 2] 						/nosym;	/* eMKF v2.4: precision matrix of WLS regression estimators (intercepts only) */
	 	array bXtWX[%eval(&p-2), %eval(&p-2)] 	/nosym; /* eMKF v2.4: precision matrix of WLS regression estimators (excl. intercepts) */
		array aDXtWX[2, 2] 						/nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (intercepts only) */
		array bDXtWX[%eval(&p-2), %eval(&p-2)]  /nosym;	/* eMKF v2.4: Dbetag + XtWX = posterior precision matrix for beta (excl. intercepts) */
		array aprbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from prior */
		array bprbeta[%eval(&p-2), 1]           /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from prior */
		array apbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector (2x1) of intercepts from pooled posterior */
		array bpbeta[%eval(&p-2), 1]            /nosym; /* eMKF v2.4: vector of regression estimates (excl. intercepts) from pooled posterior */
		array azbeta[2, 1]	 					/nosym;	/* eMKF v2.4: vector of intercepts from WLS */
		array bzbeta[%eval(&p-2), 1]	 		/nosym;	/* eMKF v2.4: vector of regression estimates (excl. intercepts) from WLS */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: sampled vector (2x1) of intercepts */
		array bbeta[%eval(&p-2), 1]		 	    /nosym;	/* eMKF v2.4: sampled vector of regression coefficients (excl. intercepts) */
		array aCC[2, 2] 						/nosym;	/* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array bCC[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: holds lower triangular matrix from Cholesky decomposition */
		array aCI[2, 2] 						/nosym;	/* eMKF v2.4: inverse of CC */
		array bCI[%eval(&p-2), %eval(&p-2)]     /nosym; /* eMKF v2.4: inverse of CC */

		/********************************/
		/* Update common coefficient(s) */
		/********************************/
		call zeromatrix(sumbXtWX);						/* initialize cumulative sums to all zeroes */
		call zeromatrix(sumbzbeta);
		call transpose(bX, bXt);						/* transpose bX */
		call mult(bDbetag, bmbetag, bprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
			abeta[1,1] = s1ag[k];						/* eMKF v2.4: group-specific abeta vector segment 1 */
			abeta[2,1] = s2ag[k];						/* eMKF v2.4: group-specific abeta vector segment 2 */
			call mult(aX, abeta, aXbeta);				/* eMKF v2.4: contribution from intercepts */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(bXt, Wg, bXtW);					/* multiply bXt and Wg */
			call mult(bXtW, bX, bXtWX);					/* calculate bXtWX */
			call addmatrix(sumbXtWX, bXtWX, sumbXtWX);	/* cumulative matrix sum */
			call mult(bXtW, Zvec, bzbeta);			 	/* contributions to posterior mean from WLS */
			call addmatrix(sumbzbeta,bzbeta,sumbzbeta);	/* cumulative matrix sum */
		end;
		call addmatrix(bDbetag, sumbXtWX, bDXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(bprbeta, sumbzbeta, bpbeta);		/* sum of prior and the cumulative WLS contributions */
		do m = 3 to &p;									/* eMKF v2.4: p is at least 3 */
			bbeta[m-2,1] = rand('normal');				/* sample from univariate standard normal(s) */
		end;
		call chol(bDXtWX, bCC);							/* eMKF v2.4: Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
		call inv(bCC, bCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 1) */
		call transpose(bCI, bCI);						/* transpose */
		call mult(bCI, bpbeta, bpbeta);					/* re-scale pbeta (part 2) */
		call mult(bCI, bbeta, bbeta);					/* re-scale beta */
		call addmatrix(bpbeta, bbeta, bbeta);			/* re-center */
		call mult(bX, bbeta, bXbeta);					/* contribution to predictions from coefficients other than intercepts (used below) */
														/* eMKF v2.4: p-2 = 6 here */
		s1b1 = bbeta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
		s1b2 = bbeta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
		s1b3 = bbeta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
		s2b1 = bbeta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
		s2b2 = bbeta[5,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
		s2b3 = bbeta[6,1];								/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */

		/************************************************/
		/* Update intercepts and regression predictions */
		/************************************************/
		call transpose(aX, aXt);						/* transpose aX */
		call mult(aDbetag, ambetag, aprbeta);			/* contribution to posterior mean from prior */
		do k = 1 to &g;									/* cycle through each group independently */
		    do i = 1 to &n;						
			  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];/* populate nx1 data vector Zvec = Yvec - bX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */
			call mult(aXt, Wg, aXtW);					/* multiply aXt and Wg */
			call mult(aXtW, aX, aXtWX);					/* calculate aXtWX, the precision matrix from WLS */
			call addmatrix(aDbetag,aXtWX,aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
			call mult(aXtW, Zvec, azbeta);				/* contribution to posterior mean from WLS */
			call addmatrix(aprbeta, azbeta, apbeta); 	/* sum of prior and WLS contributions */
			abeta[1,1] = rand('normal');				/* eMKF v2.4: sample segment 1 intercept from univariate normal */
			abeta[2,1] = rand('normal');				/* eMKF v2.4: sample segment 2 intercept from univariate normal */
			call chol(aDXtWX, aCC);						/* Cholesky decomposition for precision matrix (returns lower triangular) */
			call inv(aCC, aCI);							/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 1) */
			call transpose(aCI, aCI);					/* transpose */
			call mult(aCI, apbeta, apbeta);				/* re-scale pbeta (part 2) */
			call mult(aCI, abeta, abeta);				/* re-scale beta */
			call addmatrix(apbeta, abeta, abeta);		/* re-center */
			s1ag[k] = abeta[1,1];						/* eMKF v2.4: output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
			s2ag[k] = abeta[2,1];						/* eMKF v2.4: output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
			call mult(aX, abeta, aXbeta);				/* contribution to predictions from intercepts */
			do i = 1 to &n; 							/* updated predictions from regression */
		      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; 
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_LINEAR and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/**************************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA linear-linear trend model for full break option */
	/**************************************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine CP_xptf_bmal_bmal(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 22, 33) in the linear-linear case */
						   );

		outargs s1ag,s1b1g,s1b1,s2ag,s2b1g,s2b1,etamnarr; /* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/****************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional linear-linear BMA: p = 4 */
		/****************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/******************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional linear-linear BMA: p = 4  */
		/******************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/**************************************************************************************/
		/* Populate needed array structures depending on the model flags for segments 1 and 2 */	
		/**************************************************************************************/
		if flg = 11 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 33 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 22 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m]  = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
		  		ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 11 or flg = 33 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 3rd output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 4th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 33 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta, q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k] = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1*/
					s2ag[k] = q1beta[2,1];					/* 3rd output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 4th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps2b1 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps2b1 = tmps2b1 + s2b1g[k]; 
			end;
			s1b1 = tmps1b1/&g;
			s2b1 = tmps2b1/&g;
		end;

		/**********************/
		/* Common trend model */
		/**********************/
		if flg = 22 then do;									/* eMKF v2.4: common linear-linear trend model */
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector for segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector for segment 2 */
				call mult(aX, abeta, aXbeta);					/* matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
			    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
			    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
			    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
			    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
			    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */
			end;												/* end cycle through groups */
			call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
			call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
			do m = 1 to 2;
				b1beta[m,1] = rand('normal');					/* sample from univariate standard normal(s) */
			end;
			call chol(b1DXtWX, b1CC);							/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
			call inv(b1CC, b1CI);								/* inverse of lower triangular matrix from Cholesky decomposition */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 1) */
			call transpose(b1CI, b1CI);							/* transpose */
			call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta (part 2) */
			call mult(b1CI, b1beta, b1beta);					/* re-scale beta */
			call addmatrix(b1pbeta, b1beta, b1beta);			/* re-center */
			call mult(b1X, b1beta, bXbeta);						/* updated vector bX */
			s1b1 = b1beta[1,1];									/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
			s2b1 = b1beta[2,1];									/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s2b1g[k] = s2b1;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal for segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal for segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/************************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA quad-linear trend model for full break option */
	/************************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptf_bmaq_bmal(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s1b2, 				/* updated value of common quad coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 21, 32, 42, 53) in the quad-linear case */
						   );

		outargs s1ag,s1b1g,s1b2g,s1b1,s1b2,s2ag,s2b1g,s2b1,etamnarr;	/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/**************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional quad-linear BMA: p = 5 */
		/**************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q3X[&n, 5]						/nosym; /* 5-column version of the design matrix X [quad-linear] */
		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q3mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q3Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q3Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q3XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q3XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q3DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q3prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q3pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q3ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q3beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q3CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q3CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/***************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional quad-linear BMA: p = 5 */
		/***************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [quad-linear] */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b2beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b2CI[3, 3]     					/nosym; /* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 11 then do;							/* indep quad-linear: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 5;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 21 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 53 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 32 then do;							/* common quad-linear: q = 5 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b2X[i, 2*m-1] = X[i, 3*m-1];
					if m = 1 then do;
						b2X[i, 2*m] = X[i, 3*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b2mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
				if m = 1 then do;	
					b2mbetag[2*m, 1]   = mbetag[3*m, 1];
			    	b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 42 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 11 or flg = 21 or flg = 53 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific quad-linear trend model (q=5)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q3beta[4,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q3beta[5,1];					/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 21 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 53 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q1beta[2,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps1b2 = 0;
			tmps2b1 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps1b2 = tmps1b2 + s1b2g[k];
				tmps2b1 = tmps2b1 + s2b1g[k];
			end;
			s1b1 = tmps1b1/&g;
			s1b2 = tmps1b2/&g;
			s2b1 = tmps2b1/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 32 or flg = 42 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 32 then do;							/* common quad-linear trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 42 then do;							/* common linear-linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 32 then do;								/* common quad-linear trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 3;
					b2beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				s1b1 = b2beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b2beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s2b1 = b2beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			end;
			if flg = 42 then do;								/* common linear-linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 2;
					b1beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				s1b1 = b1beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = 0;										/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s2b1 = b1beta[2,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s1b2g[k] = s1b2;
				s2b1g[k] = s2b1;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal -- segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal -- segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_QUAD %then %do;
	/**********************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA quad-quad trend model for full break option */
	/**********************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptf_bmaq_bmaq(
						   s1ag[*], 			/* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s1b2, 				/* updated value of common quad coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   s2b2, 				/* updated value of common quad coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 12, 22, 33, 34, 44, 55) in the quad-quad case */
						   );

		outargs s1ag,s1b1g,s1b2g,s1b1,s1b2,s2ag,s2b1g,s2b2g,s2b1,s2b2,etamnarr;	/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional quad-quad BMA: p = 6 */
		/************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q4X[&n, 6]						/nosym; /* 6-column version of the design matrix X [quad-quad] */
		array q3X[&n, 5]						/nosym; /* 5-column version of the design matrix X [quad-linear] */
		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q4mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q3mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q4Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q3Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q4Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q4XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q4XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q4DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q4prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q3prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q4pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q3pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q4ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q3ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q4beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q3beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q4CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q4CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q3CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/*************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional quad-quad BMA: p = 6 */
		/*************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [quad-quad] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [quad-linear] */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b3beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b3CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b3CI[4, 4]     					/nosym; /* inverse of CC */
		array b2CI[3, 3]     					/nosym; /* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 11 then do;							/* indep quad-quad: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q4X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q4Dbetag);
			do m = 1 to 6;
				q4mbetag[m, 1] = mbetag[m, 1];
				q4Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q4X, q4Xt);					/* transpose qX */
			call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 12 then do;							/* indep quad-linear: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 5;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 22 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 55 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 33 then do;							/* common quad-quad: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b3X[i, 2*m-1] = X[i, 3*m-1];
					b3X[i, 2*m] = X[i, 3*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b3Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b3mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b3Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];	
				b3mbetag[2*m, 1]   = mbetag[3*m, 1];
			    b3Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b3X, b3Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb3zbeta);	
		end;
		if flg = 34 then do;							/* common quad-linear: q = 5 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b2X[i, 2*m-1] = X[i, 3*m-1];
					if m = 1 then do;
						b2X[i, 2*m] = X[i, 3*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b2mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
				if m = 1 then do;	
					b2mbetag[2*m, 1]   = mbetag[3*m, 1];
			    	b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 44 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg = 11 or flg = 12 or flg = 22 or flg = 55 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific quad-quad trend model (q=6)*/
					call mult(q4Xt, Wg, q4XtW);				/* multiply Xt and Wg */
					call mult(q4XtW, q4X, q4XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q4Dbetag,q4XtWX,q4DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q4XtW, Yvec, q4ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q4prbeta,q4ybeta,q4pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q4beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q4DXtWX, q4CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q4CC, q4CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q4CI, q4CI);				/* transpose */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 2) */
					call mult(q4CI, q4beta, q4beta);		/* re-scale beta */
					call addmatrix(q4pbeta,q4beta,q4beta);	/* re-center */
					call mult(q4X, q4beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q4beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q4beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q4beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q4beta[4,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q4beta[5,1];					/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q4beta[6,1];					/* 6th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 12 then do;						/* group-specific quad-linear trend model (q=5)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q3beta[4,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q3beta[5,1];					/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 6th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 22 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 6th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 55 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s2ag[k]  = q1beta[2,1];					/* 4th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 5th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 6th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps1b2 = 0;
			tmps2b1 = 0;
			tmps2b2 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps1b2 = tmps1b2 + s1b2g[k];
				tmps2b1 = tmps2b1 + s2b1g[k];
				tmps2b2 = tmps2b2 + s2b2g[k];
			end;
			s1b1 = tmps1b1/&g;
			s1b2 = tmps1b2/&g;
			s2b1 = tmps2b1/&g;
			s2b2 = tmps2b2/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg = 33 or flg = 34 or flg = 44 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 33 then do;							/* common quad-quad trend model */
				  call mult(b3Xt, Wg, b3XtW);					/* multiply bXt and Wg */
				  call mult(b3XtW, b3X, b3XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
				  call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);/* cumulative matrix sum */
				end;
				if flg = 34 then do;							/* common quad-linear trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 44 then do;							/* common linear-linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 33 then do;								/* common quad-quad trend model */
				call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b3beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b3DXtWX, b3CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b3CC, b3CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b3CI, b3CI);						/* transpose */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 2) */
				call mult(b3CI, b3beta, b3beta);				/* re-scale beta */
				call addmatrix(b3pbeta, b3beta, b3beta);		/* re-center */
				call mult(b3X, b3beta, bXbeta);					/* updated vector bX */
				s1b1 = b3beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b3beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s2b1 = b3beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b3beta[4,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 34 then do;								/* common quad-linear trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 3;
					b2beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				s1b1 = b2beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b2beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s2b1 = b2beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 44 then do;								/* common linear-linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 2;
					b1beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				s1b1 = b1beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = 0;										/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s2b1 = b1beta[2,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s1b2g[k] = s1b2;
				s2b1g[k] = s2b1;
				s2b2g[k] = s2b2;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal -- segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal -- segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/*************************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA cubic-linear trend model for full break option */
	/*************************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptf_bmac_bmal(
						   s1ag[*], 		    /* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						   s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s1b2, 				/* updated value of common quad coefficient for segment 1 */
						   s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 21, 31, 42, 52, 62, 73) in the cubic-linear case */
						   );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s1b1,s1b2,s1b3,s2ag,s2b1g,s2b1,etamnarr; /* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/***************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional cubic-linear BMA: p = 6 */
		/***************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q5X[&n, 6]						/nosym; /* 6-column version of the design matrix X [cubic-linear] */
		array q3X[&n, 5]						/nosym; /* 5-column version of the design matrix X [quad-linear] */
		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q5mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q3mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q5Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q3Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q5Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q5XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q5XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q5DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q5prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q3prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q5pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q3pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q5ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q3ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q5beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q3beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q5CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q5CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q3CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/****************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional cubic-linear BMA: p = 6 */
		/****************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [cubic-linear] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [quad-linear] */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b4beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b4CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b4CI[4, 4]     					/nosym; /* inverse of CC */
		array b2CI[3, 3]     					/nosym; /* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 11 then do;							/* indep cubic-linear: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q5X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q5Dbetag);
			do m = 1 to 6;
				q5mbetag[m, 1] = mbetag[m, 1];
				q5Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q5X, q5Xt);					/* transpose qX */
			call mult(q5Dbetag, q5mbetag, q5prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 21 then do;							/* indep quad-linear: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 5;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 31 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 73 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 42 then do;							/* common cubic-linear: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b4X[i, 3*m-2] 	= X[i, 4*m-2];
					if m = 1 then do;
					  b4X[i, 3*m-1]	= X[i, 4*m-1];
					  b4X[i, 3*m] 	= X[i, 4*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b4Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b4mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b4Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				if m = 1 then do;
				  b4mbetag[3*m-1, 1]  	= mbetag[4*m-1, 1];
				  b4Dbetag[3*m-1,3*m-1]	= Dbetag[4*m-1, 4*m-1];	
				  b4mbetag[3*m, 1]   	= mbetag[4*m, 1];
			      b4Dbetag[3*m, 3*m] 	= Dbetag[4*m, 4*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b4X, b4Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb4zbeta);	
		end;
		if flg = 52 then do;							/* common quad-linear: q = 5 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b2X[i, 2*m-1] = X[i, 3*m-1];
					if m = 1 then do;
						b2X[i, 2*m] = X[i, 3*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b2mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
				if m = 1 then do;	
					b2mbetag[2*m, 1]   = mbetag[3*m, 1];
			    	b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 62 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg=11 or flg=21 or flg=31 or flg=73 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific cubic-linear trend model (q=6)*/
					call mult(q5Xt, Wg, q5XtW);				/* multiply Xt and Wg */
					call mult(q5XtW, q5X, q5XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q5Dbetag,q5XtWX,q5DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q5XtW, Yvec, q5ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q5prbeta,q5ybeta,q5pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q5beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q5DXtWX, q5CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q5CC, q5CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q5CI, q5CI);				/* transpose */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 2) */
					call mult(q5CI, q5beta, q5beta);		/* re-scale beta */
					call addmatrix(q5pbeta,q5beta,q5beta);	/* re-center */
					call mult(q5X, q5beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q5beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q5beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q5beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q5beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q5beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q5beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 21 then do;						/* group-specific quad-linear trend model (q=5)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q3beta[4,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q3beta[5,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 31 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				if flg = 73 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q1beta[2,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps1b2 = 0;
			tmps1b3 = 0;
			tmps2b1 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps1b2 = tmps1b2 + s1b2g[k];
				tmps1b3 = tmps1b3 + s1b3g[k];
				tmps2b1 = tmps2b1 + s2b1g[k];
			end;
			s1b1 = tmps1b1/&g;
			s1b2 = tmps1b2/&g;
			s1b3 = tmps1b3/&g;
			s2b1 = tmps2b1/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg=42 or flg=52 or flg=62 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 42 then do;							/* common cubic-linear trend model */
				  call mult(b4Xt, Wg, b4XtW);					/* multiply bXt and Wg */
				  call mult(b4XtW, b4X, b4XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
				  call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);/* cumulative matrix sum */
				end;
				if flg = 52 then do;							/* common quad-linear trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 62 then do;							/* common linear-linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 42 then do;								/* common cubic-linear trend model */
				call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b4beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b4DXtWX, b4CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b4CC, b4CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b4CI, b4CI);						/* transpose */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 2) */
				call mult(b4CI, b4beta, b4beta);				/* re-scale beta */
				call addmatrix(b4pbeta, b4beta, b4beta);		/* re-center */
				call mult(b4X, b4beta, bXbeta);					/* updated vector bX */
				s1b1 = b4beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b4beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b4beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b4beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			end;
			if flg = 52 then do;								/* common quad-linear trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 3;
					b2beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				s1b1 = b2beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b2beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b2beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			end;
			if flg = 62 then do;								/* common linear-linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 2;
					b1beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				s1b1 = b1beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = 0;										/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b1beta[2,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s1b2g[k] = s1b2;
				s1b3g[k] = s1b3;
				s2b1g[k] = s2b1;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal -- segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal -- segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_QUAD %then %do;
	/***********************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA cubic-quad trend model for full break option */
	/***********************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptf_bmac_bmaq(
						   s1ag[*], 		    /* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						   s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s1b2, 				/* updated value of common quad coefficient for segment 1 */
						   s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   s2b2, 				/* updated value of common quad coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 12, 21, 22, 32, 43, 44, 53, 54, 64, 75) in the cubic-quad case */
						   );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s1b1,s1b2,s1b3,s2ag,s2b1g,s2b2g,s2b1,s2b2,etamnarr; /* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/*************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional cubic-quad BMA: p = 7 */
		/*************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q6X[&n, 7]						/nosym; /* 7-column version of the design matrix X [cubic-quad] */
		array q5X[&n, 6]						/nosym; /* 6-column version of the design matrix X [cubic-linear] */
		array q4X[&n, 6]						/nosym; /* 6-column version of the design matrix X [quad-quad] */
		array q3X[&n, 5]						/nosym; /* 5-column version of the design matrix X [quad-linear] */
		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q6mbetag[7, 1]					/nosym; /* 7-dimensional version of mbetag */
		array q5mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q4mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q3mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q6Dbetag[7, 7]					/nosym; /* 7-dimensional version of Dbetag */
		array q5Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q4Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q3Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q6Xt[7, &n]   					/nosym;	/* transpose of design matrix */
		array q5Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q4Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q6XtW[7, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q5XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q4XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q6XtWX[7, 7] 						/nosym; /* precision matrix of WLS regression estimators */
		array q5XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q4XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q6DXtWX[7, 7]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q5DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q4DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q6prbeta[7, 1] 	    			/nosym;	/* vector (7 x 1) of regression estimates from prior */
		array q5prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q4prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q3prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q6pbeta[7, 1] 	    			/nosym;	/* vector (7 x 1) of regression estimates from pooled posterior */
		array q5pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q4pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q3pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q6ybeta[7, 1] 	       			/nosym;	/* vector (7 x 1) of regression estimates from WLS */
		array q5ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q4ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q3ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q6beta[7, 1] 	       				/nosym;	/* sampled vector (7 x 1) of regression coefficients */
		array q5beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q4beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q3beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q6CC[7, 7]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q5CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q4CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q6CI[7, 7] 					  	/nosym;	/* inverse of CC */
		array q5CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q4CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q3CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/**************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional cubic-quad BMA: p = 7 */
		/**************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b5mbetag[5, 1] 					/nosym;	/* prior mean vector (5 x 1) for remaining coefficients [cubic-quad] */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [cubic-linear] */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [quad-quad] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [quad-linear] */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b5Dbetag[5, 5] 					/nosym;	/* diagonal matrix (5 x 5) of prior precisions for remaining coefficients */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b5X[&n, 5]						/nosym; /* 5-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb5XtWX[5, 5] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb5zbeta[5, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b5Xt[5, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b5DXtWX[5, 5]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b5prbeta[5, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b5pbeta[5, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b5zbeta[5, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b5beta[5, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b4beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b3beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b5CC[5, 5]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b4CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b3CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b5CI[5, 5]     					/nosym; /* inverse of CC */
		array b4CI[4, 4]     					/nosym; /* inverse of CC */
		array b3CI[4, 4]     					/nosym; /* inverse of CC */
		array b2CI[3, 3]     					/nosym; /* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 11 then do;							/* indep cubic-quad: q = 7 */
			do i = 1 to &n;
				do m = 1 to 7;
					q6X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q6Dbetag);
			do m = 1 to 7;
				q6mbetag[m, 1] = mbetag[m, 1];
				q6Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q6X, q6Xt);					/* transpose qX */
			call mult(q6Dbetag, q6mbetag, q6prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 12 then do;							/* indep cubic-linear: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q5X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q5Dbetag);
			do m = 1 to 6;
				q5mbetag[m, 1] = mbetag[m, 1];
				q5Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q5X, q5Xt);					/* transpose qX */
			call mult(q5Dbetag, q5mbetag, q5prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 21 then do;							/* indep quad-quad: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q4X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q4Dbetag);
			do m = 1 to 6;
				q4mbetag[m, 1] = mbetag[m, 1];
				q4Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q4X, q4Xt);					/* transpose qX */
			call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 22 then do;							/* indep quad-linear: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 5;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 32 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 75 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 43 then do;							/* common cubic-quad: q = 7 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b5X[i, 3*m-2] 	= X[i, 4*m-2];
					b5X[i, 3*m-1] 	= X[i, 4*m-1];
					if m = 1 then do;
						b5X[i, 3*m] = X[i, 4*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b5Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b5mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b5Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				b5mbetag[3*m-1, 1]   	= mbetag[4*m-1, 1];
			    b5Dbetag[3*m-1, 3*m-1] 	= Dbetag[4*m-1, 4*m-1];	
				if m = 1 then do;
					b5mbetag[3*m, 1]   	= mbetag[4*m, 1];
			    	b5Dbetag[3*m, 3*m] 	= Dbetag[4*m, 4*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b5X, b5Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b5Dbetag, b5mbetag, b5prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb5XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb5zbeta);	
		end;
		if flg = 44 then do;							/* common cubic-linear: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b4X[i, 3*m-2] 	= X[i, 4*m-2];
					if m = 1 then do;
					  b4X[i, 3*m-1]	= X[i, 4*m-1];
					  b4X[i, 3*m] 	= X[i, 4*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b4Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b4mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b4Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				if m = 1 then do;
				  b4mbetag[3*m-1, 1]  	= mbetag[4*m-1, 1];
				  b4Dbetag[3*m-1,3*m-1]	= Dbetag[4*m-1, 4*m-1];	
				  b4mbetag[3*m, 1]   	= mbetag[4*m, 1];
			      b4Dbetag[3*m, 3*m] 	= Dbetag[4*m, 4*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b4X, b4Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb4zbeta);	
		end;
		if flg = 53 then do;							/* common quad-quad: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b3X[i, 2*m-1] = X[i, 3*m-1];
					b3X[i, 2*m] = X[i, 3*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b3Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b3mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b3Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];	
				b3mbetag[2*m, 1]   = mbetag[3*m, 1];
			    b3Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b3X, b3Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb3zbeta);	
		end;
		if flg = 54 then do;							/* common quad-linear: q = 5 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b2X[i, 2*m-1] = X[i, 3*m-1];
					if m = 1 then do;
						b2X[i, 2*m] = X[i, 3*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b2mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
				if m = 1 then do;	
					b2mbetag[2*m, 1]   = mbetag[3*m, 1];
			    	b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 64 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg=11 or flg=12 or flg=21 or flg=22 or flg=32 or flg=75 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific cubic-quad trend model (q=7)*/
					call mult(q6Xt, Wg, q6XtW);				/* multiply Xt and Wg */
					call mult(q6XtW, q6X, q6XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q6Dbetag,q6XtWX,q6DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q6XtW, Yvec, q6ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q6prbeta,q6ybeta,q6pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 7;
						q6beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q6DXtWX, q6CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q6CC, q6CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q6CI, q6pbeta, q6pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q6CI, q6CI);				/* transpose */
					call mult(q6CI, q6pbeta, q6pbeta);		/* re-scale pbeta (part 2) */
					call mult(q6CI, q6beta, q6beta);		/* re-scale beta */
					call addmatrix(q6pbeta,q6beta,q6beta);	/* re-center */
					call mult(q6X, q6beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q6beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q6beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q6beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q6beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q6beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q6beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q6beta[7,1];					/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 12 then do;						/* group-specific cubic-linear trend model (q=6)*/
					call mult(q5Xt, Wg, q5XtW);				/* multiply Xt and Wg */
					call mult(q5XtW, q5X, q5XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q5Dbetag,q5XtWX,q5DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q5XtW, Yvec, q5ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q5prbeta,q5ybeta,q5pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q5beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q5DXtWX, q5CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q5CC, q5CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q5CI, q5CI);				/* transpose */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 2) */
					call mult(q5CI, q5beta, q5beta);		/* re-scale beta */
					call addmatrix(q5pbeta,q5beta,q5beta);	/* re-center */
					call mult(q5X, q5beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q5beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q5beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q5beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q5beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q5beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q5beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 21 then do;						/* group-specific quad-quad trend model (q=6)*/
					call mult(q4Xt, Wg, q4XtW);				/* multiply Xt and Wg */
					call mult(q4XtW, q4X, q4XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q4Dbetag,q4XtWX,q4DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q4XtW, Yvec, q4ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q4prbeta,q4ybeta,q4pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q4beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q4DXtWX, q4CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q4CC, q4CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q4CI, q4CI);				/* transpose */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 2) */
					call mult(q4CI, q4beta, q4beta);		/* re-scale beta */
					call addmatrix(q4pbeta,q4beta,q4beta);	/* re-center */
					call mult(q4X, q4beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q4beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q4beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q4beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q4beta[4,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q4beta[5,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q4beta[6,1];					/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 22 then do;						/* group-specific quad-linear trend model (q=5)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q3beta[4,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q3beta[5,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 32 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				if flg = 75 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q1beta[2,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps1b2 = 0;
			tmps1b3 = 0;
			tmps2b1 = 0;
			tmps2b2 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps1b2 = tmps1b2 + s1b2g[k];
				tmps1b3 = tmps1b3 + s1b3g[k];
				tmps2b1 = tmps2b1 + s2b1g[k];
				tmps2b2 = tmps2b2 + s2b2g[k];
			end;
			s1b1 = tmps1b1/&g;
			s1b2 = tmps1b2/&g;
			s1b3 = tmps1b3/&g;
			s2b1 = tmps2b1/&g;
			s2b2 = tmps2b2/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg=43 or flg=44 or flg=53 or flg=54 or flg=64 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 43 then do;							/* common cubic-quad trend model */
				  call mult(b5Xt, Wg, b5XtW);					/* multiply bXt and Wg */
				  call mult(b5XtW, b5X, b5XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb5XtWX, b5XtWX, sumb5XtWX);	/* cumulative matrix sum */
				  call mult(b5XtW, Zvec, b5zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb5zbeta,b5zbeta,sumb5zbeta);/* cumulative matrix sum */
				end;
				if flg = 44 then do;							/* common cubic-linear trend model */
				  call mult(b4Xt, Wg, b4XtW);					/* multiply bXt and Wg */
				  call mult(b4XtW, b4X, b4XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
				  call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);/* cumulative matrix sum */
				end;
				if flg = 53 then do;							/* common quad-quad trend model */
				  call mult(b3Xt, Wg, b3XtW);					/* multiply bXt and Wg */
				  call mult(b3XtW, b3X, b3XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
				  call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);/* cumulative matrix sum */
				end;
				if flg = 54 then do;							/* common quad-linear trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 64 then do;							/* common linear-linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 43 then do;								/* common cubic-quad trend model */
				call addmatrix(b5Dbetag, sumb5XtWX, b5DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b5prbeta, sumb5zbeta, b5pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 5;
					b5beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b5DXtWX, b5CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b5CC, b5CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b5CI, b5pbeta, b5pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b5CI, b5CI);						/* transpose */
				call mult(b5CI, b5pbeta, b5pbeta);				/* re-scale pbeta (part 2) */
				call mult(b5CI, b5beta, b5beta);				/* re-scale beta */
				call addmatrix(b5pbeta, b5beta, b5beta);		/* re-center */
				call mult(b5X, b5beta, bXbeta);					/* updated vector bX */
				s1b1 = b5beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b5beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b5beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b5beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b5beta[5,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 44 then do;								/* common cubic-linear trend model */
				call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b4beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b4DXtWX, b4CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b4CC, b4CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b4CI, b4CI);						/* transpose */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 2) */
				call mult(b4CI, b4beta, b4beta);				/* re-scale beta */
				call addmatrix(b4pbeta, b4beta, b4beta);		/* re-center */
				call mult(b4X, b4beta, bXbeta);					/* updated vector bX */
				s1b1 = b4beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b4beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b4beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b4beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 53 then do;								/* common quad-quad trend model */
				call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b3beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b3DXtWX, b3CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b3CC, b3CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b3CI, b3CI);						/* transpose */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 2) */
				call mult(b3CI, b3beta, b3beta);				/* re-scale beta */
				call addmatrix(b3pbeta, b3beta, b3beta);		/* re-center */
				call mult(b3X, b3beta, bXbeta);					/* updated vector bX */
				s1b1 = b3beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b3beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b3beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b3beta[4,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 54 then do;								/* common quad-linear trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 3;
					b2beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				s1b1 = b2beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b2beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b2beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			if flg = 64 then do;								/* common linear-linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 2;
					b1beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				s1b1 = b1beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = 0;										/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b1beta[2,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s1b2g[k] = s1b2;
				s1b3g[k] = s1b3;
				s2b1g[k] = s2b1;
				s2b2g[k] = s2b2;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal -- segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal -- segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_CUBIC %then %do;
	/************************************************************************************************************/
	/* eMKF: Gibbs sampler for regression coefficients in the BMA cubic-cubic trend model for full break option */
	/************************************************************************************************************/
	proc fcmp outlib=&uloc;		

		subroutine CP_xptf_bmac_bmac(
						   s1ag[*], 		    /* 1-dimensional array (length g) of updated values of intercepts by group for segment 1 */
						   s1b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 1 */
						   s1b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 1 */
						   s1b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 1 */
						   s1b1, 				/* updated value of common linear coefficient for segment 1 */
						   s1b2, 				/* updated value of common quad coefficient for segment 1 */
						   s1b3, 				/* updated value of common cubic coefficient for segment 1 */
						   s2ag[*],				/* 1-dimensional array (length g) of updated values of intercepts by group for segment 2 */
						   s2b1g[*], 			/* 1-dimensional array (length g) of updated values of linear coefficients by group for segment 2 */
						   s2b2g[*], 			/* 1-dimensional array (length g) of updated values of quad coefficients by group for segment 2 */
						   s2b3g[*], 			/* 1-dimensional array (length g) of updated values of cubic coefficients by group for segment 2 */
						   s2b1, 				/* updated value of common linear coefficient for segment 2 */
						   s2b2, 				/* updated value of common quad coefficient for segment 2 */
						   s2b3, 				/* updated value of common cubic coefficient for segment 2 */
						   etamnarr[*],			/* 1-dimensional array (length gn) of updated values of regression predictions */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*],				/* 1-dimensional array (length gn) for _var from dataset */
						   flg					/* model flag (11, 12, 13, 22, 23, 33, 44, 45, 46, 55, 56, 66, 77) in the cubic-cubic case */
						   );

		outargs s1ag,s1b1g,s1b2g,s1b3g,s1b1,s1b2,s1b3,s2ag,s2b1g,s2b2g,s2b3g,s2b1,s2b2,s2b3,etamnarr; /* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array Yvec[&n, 1]						/nosym; /* vector (nx1) for use in calculations */
		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		/**************************************************************************************************/
		/* Array structures for allowed indep trend models in the full dimensional cubic-cubic BMA: p = 8 */
		/**************************************************************************************************/
		array Xbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array q7X[&n, 8]						/nosym; /* 8-column version of the design matrix X [cubic-cubic] */
		array q6X[&n, 7]						/nosym; /* 7-column version of the design matrix X [cubic-quad] */
		array q5X[&n, 6]						/nosym; /* 6-column version of the design matrix X [cubic-linear] */
		array q4X[&n, 6]						/nosym; /* 6-column version of the design matrix X [quad-quad] */
		array q3X[&n, 5]						/nosym; /* 5-column version of the design matrix X [quad-linear] */
		array q2X[&n, 4]						/nosym; /* 4-column version of the design matrix X [linear-linear] */
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [dropped-dropped] */

		array q7mbetag[8, 1]					/nosym; /* 8-dimensional version of mbetag */
		array q6mbetag[7, 1]					/nosym; /* 7-dimensional version of mbetag */
		array q5mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q4mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */
		array q3mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q2mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q7Dbetag[8, 8]					/nosym; /* 8-dimensional version of Dbetag */
		array q6Dbetag[7, 7]					/nosym; /* 7-dimensional version of Dbetag */
		array q5Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q4Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */
		array q3Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q2Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q7Xt[8, &n]   					/nosym;	/* transpose of design matrix */
		array q6Xt[7, &n]   					/nosym;	/* transpose of design matrix */
		array q5Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q4Xt[6, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q7XtW[8, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q6XtW[7, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q5XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q4XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q7XtWX[8, 8] 						/nosym; /* precision matrix of WLS regression estimators */
		array q6XtWX[7, 7] 						/nosym; /* precision matrix of WLS regression estimators */
		array q5XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q4XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q7DXtWX[8, 8]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q6DXtWX[7, 7]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q5DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q4DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q7prbeta[8, 1] 	    			/nosym;	/* vector (8 x 1) of regression estimates from prior */
		array q6prbeta[7, 1] 	    			/nosym;	/* vector (7 x 1) of regression estimates from prior */
		array q5prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q4prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */
		array q3prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q2prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q7pbeta[8, 1] 	    			/nosym;	/* vector (8 x 1) of regression estimates from pooled posterior */
		array q6pbeta[7, 1] 	    			/nosym;	/* vector (7 x 1) of regression estimates from pooled posterior */
		array q5pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q4pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */
		array q3pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q2pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q7ybeta[8, 1] 	       			/nosym;	/* vector (8 x 1) of regression estimates from WLS */
		array q6ybeta[7, 1] 	       			/nosym;	/* vector (7 x 1) of regression estimates from WLS */
		array q5ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q4ybeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */
		array q3ybeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q2ybeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q1ybeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q7beta[8, 1] 	       				/nosym;	/* sampled vector (8 x 1) of regression coefficients */
		array q6beta[7, 1] 	       				/nosym;	/* sampled vector (7 x 1) of regression coefficients */
		array q5beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q4beta[6, 1] 	       				/nosym;	/* sampled vector (6 x 1) of regression coefficients */
		array q3beta[5, 1] 	       				/nosym;	/* sampled vector (5 x 1) of regression coefficients */
		array q2beta[4, 1] 	       				/nosym;	/* sampled vector (4 x 1) of regression coefficients */
		array q1beta[2, 1] 	       				/nosym;	/* sampled vector (2 x 1) of regression coefficients */

		array q7CC[8, 8]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q6CC[7, 7]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q5CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q4CC[6, 6]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q3CC[5, 5]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q2CC[4, 4]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array q1CC[2, 2]   						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */

		array q7CI[8, 8] 					  	/nosym;	/* inverse of CC */
		array q6CI[7, 7] 					  	/nosym;	/* inverse of CC */
		array q5CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q4CI[6, 6] 					  	/nosym;	/* inverse of CC */
		array q3CI[5, 5] 					  	/nosym;	/* inverse of CC */
		array q2CI[4, 4] 					  	/nosym;	/* inverse of CC */
		array q1CI[2, 2] 					  	/nosym;	/* inverse of CC */

		/***************************************************************************************************/
		/* Array structures for allowed common trend models in the full dimensional cubic-cubic BMA: p = 8 */
		/***************************************************************************************************/
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array bXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */

		array ambetag[2, 1]						/nosym; /* prior mean vector (2 x 1) for intercepts */
		array b6mbetag[6, 1] 					/nosym;	/* prior mean vector (6 x 1) for remaining coefficients [cubic-cubic] */
		array b5mbetag[5, 1] 					/nosym;	/* prior mean vector (5 x 1) for remaining coefficients [cubic-quad] */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [cubic-linear] */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for remaining coefficients [quad-quad] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for remaining coefficients [quad-linear] */
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for remaining coefficients [linear-linear] */

		array aDbetag[2, 2] 					/nosym; /* diagonal matrix (2 x 2) of prior precisions for intercepts */
		array b6Dbetag[6, 6] 					/nosym;	/* diagonal matrix (6 x 6) of prior precisions for remaining coefficients */
		array b5Dbetag[5, 5] 					/nosym;	/* diagonal matrix (5 x 5) of prior precisions for remaining coefficients */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for remaining coefficients */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for remaining coefficients */
		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for remaining coefficients */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array b6X[&n, 6]						/nosym; /* 6-dimensional conformal design submatrix X */
		array b5X[&n, 5]						/nosym; /* 5-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb6XtWX[6, 6] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb5XtWX[5, 5] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb6zbeta[6, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb5zbeta[5, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array aXt[2, &n] 						/nosym;	/* transpose of design matrix (intercept only) */
		array b6Xt[6, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b5Xt[5, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array aXtW[2, &n] 						/nosym;	/* matrix multiplication of Xt and Wg (intercept only) */
		array b6XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

		array aXtWX[2, 2] 						/nosym;	/* precision matrix of WLS regression estimators (intercept only) */
	 	array b6XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array aDXtWX[2, 2] 						/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (intercept only) */
		array b6DXtWX[6, 6]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b5DXtWX[5, 5]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array aprbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from prior */
		array b6prbeta[6, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b5prbeta[5, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array apbeta[2, 1]	 					/nosym;	/* vector (2x1) of intercepts from pooled posterior */
		array b6pbeta[6, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b5pbeta[5, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array azbeta[2, 1]	 					/nosym;	/* vector of intercepts from WLS */
		array b6zbeta[6, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b5zbeta[5, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array abeta[2, 1] 						/nosym;	/* sampled vector (2x1) of intercepts */
		array b6beta[6, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b5beta[5, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b4beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b3beta[4, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b2beta[3, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */
		array b1beta[2, 1]		 	    		/nosym;	/* sampled vector of regression coefficients (excl. intercepts) */

		array aCC[2, 2] 						/nosym;	/* holds lower triangular matrix from Cholesky decomposition */
		array b6CC[6, 6]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b5CC[5, 5]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b4CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b3CC[4, 4]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b2CC[3, 3]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */
		array b1CC[2, 2]     					/nosym; /* holds lower triangular matrix from Cholesky decomposition */

		array aCI[2, 2] 						/nosym;	/* inverse of CC */
		array b6CI[6, 6]     					/nosym; /* inverse of CC */
		array b5CI[5, 5]     					/nosym; /* inverse of CC */
		array b4CI[4, 4]     					/nosym; /* inverse of CC */
		array b3CI[4, 4]     					/nosym; /* inverse of CC */
		array b2CI[3, 3]     					/nosym; /* inverse of CC */
		array b1CI[2, 2]     					/nosym; /* inverse of CC */

		/****************************************************************/
		/* Populate needed array structures depending on the model flag */	
		/****************************************************************/
		if flg = 11 then do;							/* indep cubic-cubic: q = 8 */
			do i = 1 to &n;
				do m = 1 to 8;
					q7X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q7Dbetag);
			do m = 1 to 8;
				q7mbetag[m, 1] = mbetag[m, 1];
				q7Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q7X, q7Xt);					/* transpose qX */
			call mult(q7Dbetag, q7mbetag, q7prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 12 then do;							/* indep cubic-quad: q = 7 */
			do i = 1 to &n;
				do m = 1 to 7;
					q6X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q6Dbetag);
			do m = 1 to 7;
				q6mbetag[m, 1] = mbetag[m, 1];
				q6Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q6X, q6Xt);					/* transpose qX */
			call mult(q6Dbetag, q6mbetag, q6prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 13 then do;							/* indep cubic-linear: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q5X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q5Dbetag);
			do m = 1 to 6;
				q5mbetag[m, 1] = mbetag[m, 1];
				q5Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q5X, q5Xt);					/* transpose qX */
			call mult(q5Dbetag, q5mbetag, q5prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 22 then do;							/* indep quad-quad: q = 6 */
			do i = 1 to &n;
				do m = 1 to 6;
					q4X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q4Dbetag);
			do m = 1 to 6;
				q4mbetag[m, 1] = mbetag[m, 1];
				q4Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q4X, q4Xt);					/* transpose qX */
			call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 23 then do;							/* indep quad-linear: q = 5 */
			do i = 1 to &n;
				do m = 1 to 5;
					q3X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q3Dbetag);
			do m = 1 to 5;
				q3mbetag[m, 1] = mbetag[m, 1];
				q3Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q3X, q3Xt);					/* transpose qX */
			call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 33 then do;							/* indep linear-linear: q = 4 */
			do i = 1 to &n;
				do m = 1 to 4;
					q2X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q2Dbetag);
			do m = 1 to 4;
				q2mbetag[m, 1] = mbetag[m, 1];
				q2Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q2X, q2Xt);					/* transpose qX */
			call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 77 then do;							/* dropped-dropped: q = 2 */
			do i = 1 to &n;
				do m = 1 to 2;
					q1X[i, m] = X[i, m];
				end;
			end;
			call zeromatrix(q1Dbetag);
			do m = 1 to 2;
				q1mbetag[m, 1] = mbetag[m, 1];
				q1Dbetag[m, m] = Dbetag[m, m];
			end;
			call transpose(q1X, q1Xt);					/* transpose qX */
			call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */
		end;
		if flg = 44 then do;							/* common cubic-cubic: q = 8 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b6X[i, 3*m-2] 	= X[i, 4*m-2];
					b6X[i, 3*m-1] 	= X[i, 4*m-1];
					b6X[i, 3*m] 	= X[i, 4*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b6Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b6mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b6Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				b6mbetag[3*m-1, 1]   	= mbetag[4*m-1, 1];
			    b6Dbetag[3*m-1, 3*m-1] 	= Dbetag[4*m-1, 4*m-1];	
				b6mbetag[3*m, 1]   		= mbetag[4*m, 1];
			    b6Dbetag[3*m, 3*m] 		= Dbetag[4*m, 4*m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b6X, b6Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b6Dbetag, b6mbetag, b6prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb6XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb6zbeta);	
		end;
		if flg = 45 then do;							/* common cubic-quad: q = 7 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b5X[i, 3*m-2] 	= X[i, 4*m-2];
					b5X[i, 3*m-1] 	= X[i, 4*m-1];
					if m = 1 then do;
						b5X[i, 3*m] = X[i, 4*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b5Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b5mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b5Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				b5mbetag[3*m-1, 1]   	= mbetag[4*m-1, 1];
			    b5Dbetag[3*m-1, 3*m-1] 	= Dbetag[4*m-1, 4*m-1];	
				if m = 1 then do;
					b5mbetag[3*m, 1]   	= mbetag[4*m, 1];
			    	b5Dbetag[3*m, 3*m] 	= Dbetag[4*m, 4*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b5X, b5Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b5Dbetag, b5mbetag, b5prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb5XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb5zbeta);	
		end;
		if flg = 46 then do;							/* common cubic-linear: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] 		= X[i, 4*m-3];
					b4X[i, 3*m-2] 	= X[i, 4*m-2];
					if m = 1 then do;
					  b4X[i, 3*m-1]	= X[i, 4*m-1];
					  b4X[i, 3*m] 	= X[i, 4*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b4Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] 			= mbetag[4*m-3,1];
		  		aDbetag[m,m] 			= Dbetag[4*m-3, 4*m-3];	
				b4mbetag[3*m-2, 1]   	= mbetag[4*m-2, 1];
			    b4Dbetag[3*m-2, 3*m-2] 	= Dbetag[4*m-2, 4*m-2];	
				if m = 1 then do;
				  b4mbetag[3*m-1, 1]  	= mbetag[4*m-1, 1];
				  b4Dbetag[3*m-1,3*m-1]	= Dbetag[4*m-1, 4*m-1];	
				  b4mbetag[3*m, 1]   	= mbetag[4*m, 1];
			      b4Dbetag[3*m, 3*m] 	= Dbetag[4*m, 4*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b4X, b4Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb4zbeta);	
		end;
		if flg = 55 then do;							/* common quad-quad: q = 6 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b3X[i, 2*m-1] = X[i, 3*m-1];
					b3X[i, 2*m] = X[i, 3*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b3Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b3mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b3Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];	
				b3mbetag[2*m, 1]   = mbetag[3*m, 1];
			    b3Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b3X, b3Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb3zbeta);	
		end;
		if flg = 56 then do;							/* common quad-linear: q = 5 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 3*m-2];
					b2X[i, 2*m-1] = X[i, 3*m-1];
					if m = 1 then do;
						b2X[i, 2*m] = X[i, 3*m];
					end;
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b2Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[3*m-2,1];
		  		aDbetag[m,m] = Dbetag[3*m-2,3*m-2];	
				b2mbetag[2*m-1, 1]   = mbetag[3*m-1, 1];
			    b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
				if m = 1 then do;	
					b2mbetag[2*m, 1]   = mbetag[3*m, 1];
			    	b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];	
				end;
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b2X, b2Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb2zbeta);	
		end;
		if flg = 66 then do;							/* common linear-linear: q = 4 */
			do i = 1 to &n;								
			  	do m = 1 to 2;
					aX[i, m] = X[i, 2*m-1];
					b1X[i, m] = X[i, 2*m];
			  	end;
		  	end;
			call zeromatrix(aDbetag);
			call zeromatrix(b1Dbetag); 
			do m = 1 to 2;
				ambetag[m,1] = mbetag[2*m-1,1];
		  		aDbetag[m,m] = Dbetag[2*m-1,2*m-1];	
				b1mbetag[m, 1] = mbetag[2*m, 1];
			    b1Dbetag[m, m] = Dbetag[2*m, 2*m];
			end;
			call transpose(aX, aXt);					/* transpose aX */
			call transpose(b1X, b1Xt);					/* transpose bX */
			call mult(aDbetag, ambetag, aprbeta);		/* contribution to posterior mean from prior */
			call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
			call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
			call zeromatrix(sumb1zbeta);	
		end;

		/*******************************/
		/* Group-specific trend models */
		/*******************************/
		if flg=11 or flg=12 or flg=13 or flg=22 or flg=23 or flg=33 or flg=77 then do;
			/**********************************/
			/* Update regression coefficients */
			/**********************************/
			do k = 1 to &g;									/* cycle through each group independently */
			    do i = 1 to &n;								
					Yvec[i,1] = Yarr[(k-1)*&n + i]; 		/* populate nx1 data vector Yvec */
				    Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
				    do j = i+1 to &n;
					    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
					    Vg[j,i] = Vg[i,j];
				    end; 
			  	end; 
				call inv(Vg, Wg);							/* Wg = Vg^{-1} */
				if flg = 11 then do;						/* group-specific cubic-cubic trend model (q=8)*/
					call mult(q7Xt, Wg, q7XtW);				/* multiply Xt and Wg */
					call mult(q7XtW, q7X, q7XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q7Dbetag,q7XtWX,q7DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q7XtW, Yvec, q7ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q7prbeta,q7ybeta,q7pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 8;
						q7beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q7DXtWX, q7CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q7CC, q7CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q7CI, q7pbeta, q7pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q7CI, q7CI);				/* transpose */
					call mult(q7CI, q7pbeta, q7pbeta);		/* re-scale pbeta (part 2) */
					call mult(q7CI, q7beta, q7beta);		/* re-scale beta */
					call addmatrix(q7pbeta,q7beta,q7beta);	/* re-center */
					call mult(q7X, q7beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q7beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q7beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q7beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q7beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q7beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q7beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q7beta[7,1];					/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = q7beta[8,1];					/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 12 then do;						/* group-specific cubic-quad trend model (q=7)*/
					call mult(q6Xt, Wg, q6XtW);				/* multiply Xt and Wg */
					call mult(q6XtW, q6X, q6XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q6Dbetag,q6XtWX,q6DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q6XtW, Yvec, q6ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q6prbeta,q6ybeta,q6pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 7;
						q6beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q6DXtWX, q6CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q6CC, q6CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q6CI, q6pbeta, q6pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q6CI, q6CI);				/* transpose */
					call mult(q6CI, q6pbeta, q6pbeta);		/* re-scale pbeta (part 2) */
					call mult(q6CI, q6beta, q6beta);		/* re-scale beta */
					call addmatrix(q6pbeta,q6beta,q6beta);	/* re-center */
					call mult(q6X, q6beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q6beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q6beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q6beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q6beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q6beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q6beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q6beta[7,1];					/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 13 then do;						/* group-specific cubic-linear trend model (q=6)*/
					call mult(q5Xt, Wg, q5XtW);				/* multiply Xt and Wg */
					call mult(q5XtW, q5X, q5XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q5Dbetag,q5XtWX,q5DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q5XtW, Yvec, q5ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q5prbeta,q5ybeta,q5pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q5beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q5DXtWX, q5CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q5CC, q5CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q5CI, q5CI);				/* transpose */
					call mult(q5CI, q5pbeta, q5pbeta);		/* re-scale pbeta (part 2) */
					call mult(q5CI, q5beta, q5beta);		/* re-scale beta */
					call addmatrix(q5pbeta,q5beta,q5beta);	/* re-center */
					call mult(q5X, q5beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q5beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q5beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q5beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = q5beta[4,1];					/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q5beta[5,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q5beta[6,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 22 then do;						/* group-specific quad-quad trend model (q=6)*/
					call mult(q4Xt, Wg, q4XtW);				/* multiply Xt and Wg */
					call mult(q4XtW, q4X, q4XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q4Dbetag,q4XtWX,q4DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q4XtW, Yvec, q4ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q4prbeta,q4ybeta,q4pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 6;
						q4beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q4DXtWX, q4CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q4CC, q4CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q4CI, q4CI);				/* transpose */
					call mult(q4CI, q4pbeta, q4pbeta);		/* re-scale pbeta (part 2) */
					call mult(q4CI, q4beta, q4beta);		/* re-scale beta */
					call addmatrix(q4pbeta,q4beta,q4beta);	/* re-center */
					call mult(q4X, q4beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q4beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q4beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q4beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q4beta[4,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q4beta[5,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = q4beta[6,1];					/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 23 then do;						/* group-specific quad-linear trend model (q=5)*/
					call mult(q3Xt, Wg, q3XtW);				/* multiply Xt and Wg */
					call mult(q3XtW, q3X, q3XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q3Dbetag,q3XtWX,q3DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q3XtW, Yvec, q3ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q3prbeta,q3ybeta,q3pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 5;
						q3beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q3DXtWX, q3CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q3CC, q3CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q3CI, q3CI);				/* transpose */
					call mult(q3CI, q3pbeta, q3pbeta);		/* re-scale pbeta (part 2) */
					call mult(q3CI, q3beta, q3beta);		/* re-scale beta */
					call addmatrix(q3pbeta,q3beta,q3beta);	/* re-center */
					call mult(q3X, q3beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q3beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q3beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = q3beta[3,1];					/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q3beta[4,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q3beta[5,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 33 then do;						/* group-specific linear-linear trend model (q=4)*/
					call mult(q2Xt, Wg, q2XtW);				/* multiply Xt and Wg */
					call mult(q2XtW, q2X, q2XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q2Dbetag,q2XtWX,q2DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q2XtW, Yvec, q2ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q2prbeta,q2ybeta,q2pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 4;
						q2beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q2DXtWX, q2CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q2CC, q2CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q2CI, q2CI);				/* transpose */
					call mult(q2CI, q2pbeta, q2pbeta);		/* re-scale pbeta (part 2) */
					call mult(q2CI, q2beta, q2beta);		/* re-scale beta */
					call addmatrix(q2pbeta,q2beta,q2beta);	/* re-center */
					call mult(q2X, q2beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q2beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = q2beta[2,1];					/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q2beta[3,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = q2beta[4,1];					/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				if flg = 77 then do;						/* group-specific intercept-only model (q=2)*/
					call mult(q1Xt, Wg, q1XtW);				/* multiply Xt and Wg */
					call mult(q1XtW, q1X, q1XtWX);			/* calculate XtWX, the precision matrix from WLS */
					call addmatrix(q1Dbetag,q1XtWX,q1DXtWX);/* posterior precision matrix for beta is qDbetag + XtWX */
					call mult(q1XtW, Yvec, q1ybeta);		/* contribution to posterior mean from WLS */
					call addmatrix(q1prbeta,q1ybeta,q1pbeta);/* sum of prior and WLS contributions */
					do m = 1 to 2;
						q1beta[m,1] = rand('normal');		/* sample from univariate standard normal */
					end;
					call chol(q1DXtWX, q1CC);				/* Cholesky decomposition for precision matrix (returns lower triangular) */
					call inv(q1CC, q1CI);					/* inverse of lower triangular matrix from Cholesky decomposition */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 1) */
					call transpose(q1CI, q1CI);				/* transpose */
					call mult(q1CI, q1pbeta, q1pbeta);		/* re-scale pbeta (part 2) */
					call mult(q1CI, q1beta, q1beta);		/* re-scale beta */
					call addmatrix(q1pbeta,q1beta,q1beta);	/* re-center */
					call mult(q1X, q1beta, Xbeta);			/* updated vector Xb */
					s1ag[k]  = q1beta[1,1];					/* 1st output argument is 1-d array of group-specific intercepts for segment 1 */
					s1b1g[k] = 0;							/* 2nd output argument is 1-d array of group-specific linear coefficients for segment 1 */
					s1b2g[k] = 0;							/* 3rd output argument is 1-d array of group-specific quad coefficients for segment 1 */
					s1b3g[k] = 0;							/* 4th output argument is 1-d array of group-specific cubic coefficients for segment 1 */
					s2ag[k]  = q1beta[2,1];					/* 5th output argument is 1-d array of group-specific intercepts for segment 2 */
					s2b1g[k] = 0;							/* 6th output argument is 1-d array of group-specific linear coefficients for segment 2 */
					s2b2g[k] = 0;							/* 7th output argument is 1-d array of group-specific quad coefficients for segment 2 */
					s2b3g[k] = 0;							/* 8th output argument is 1-d array of group-specific cubic coefficients for segment 2 */
				end;
				do i = 1 to &n; 								
			     	etamnarr[(k-1)*&n+i]= Xbeta[i,1]; 		/* updated predictions from regression */
				end;
			end;
			tmps1b1 = 0;
			tmps1b2 = 0;
			tmps1b3 = 0;
			tmps2b1 = 0;
			tmps2b2 = 0;
			tmps2b3 = 0;
			do k = 1 to &g;
				tmps1b1 = tmps1b1 + s1b1g[k]; 		 		/* common coefficient(s) set to average of group-specific coefficients */
				tmps1b2 = tmps1b2 + s1b2g[k];
				tmps1b3 = tmps1b3 + s1b3g[k];
				tmps2b1 = tmps2b1 + s2b1g[k];
				tmps2b2 = tmps2b2 + s2b2g[k];
				tmps2b3 = tmps2b3 + s2b3g[k];
			end;
			s1b1 = tmps1b1/&g;
			s1b2 = tmps1b2/&g;
			s1b3 = tmps1b3/&g;
			s2b1 = tmps2b1/&g;
			s2b2 = tmps2b2/&g;
			s2b3 = tmps2b3/&g;
		end;

		/***********************/
		/* Common trend models */
		/***********************/
		if flg=44 or flg=45 or flg=46 or flg=55 or flg=56 or flg=66 then do;
			/********************************/
			/* Update common coefficient(s) */
			/********************************/
			do k = 1 to &g;										/* cycle through each group independently */
				abeta[1,1] = s1ag[k];							/* group-specific abeta vector -- segment 1 */
				abeta[2,1] = s2ag[k];							/* group-specific abeta vector -- segment 2 */
				call mult(aX, abeta, aXbeta);					/* 2-column matrix of intercepts s1a s2a */
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - aXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - aX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				if flg = 44 then do;							/* common cubic-cubic trend model */
				  call mult(b6Xt, Wg, b6XtW);					/* multiply bXt and Wg */
				  call mult(b6XtW, b6X, b6XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb6XtWX, b6XtWX, sumb6XtWX);	/* cumulative matrix sum */
				  call mult(b6XtW, Zvec, b6zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb6zbeta,b6zbeta,sumb6zbeta);/* cumulative matrix sum */
				end;
				if flg = 45 then do;							/* common cubic-quad trend model */
				  call mult(b5Xt, Wg, b5XtW);					/* multiply bXt and Wg */
				  call mult(b5XtW, b5X, b5XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb5XtWX, b5XtWX, sumb5XtWX);	/* cumulative matrix sum */
				  call mult(b5XtW, Zvec, b5zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb5zbeta,b5zbeta,sumb5zbeta);/* cumulative matrix sum */
				end;
				if flg = 46 then do;							/* common cubic-linear trend model */
				  call mult(b4Xt, Wg, b4XtW);					/* multiply bXt and Wg */
				  call mult(b4XtW, b4X, b4XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
				  call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);/* cumulative matrix sum */
				end;
				if flg = 55 then do;							/* common quad-quad trend model */
				  call mult(b3Xt, Wg, b3XtW);					/* multiply bXt and Wg */
				  call mult(b3XtW, b3X, b3XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
				  call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);/* cumulative matrix sum */
				end;
				if flg = 56 then do;							/* common quad-linear trend model */
				  call mult(b2Xt, Wg, b2XtW);					/* multiply bXt and Wg */
				  call mult(b2XtW, b2X, b2XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
				  call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);/* cumulative matrix sum */
				end;
				if flg = 66 then do;							/* common linear-linear trend model */
				  call mult(b1Xt, Wg, b1XtW);					/* multiply bXt and Wg */
				  call mult(b1XtW, b1X, b1XtWX);				/* calculate bXtWX */
				  call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
				  call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
				  call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);/* cumulative matrix sum */
				end;
			end;												/* end cycle through groups */
			if flg = 44 then do;								/* common cubic-cubic trend model */
				call addmatrix(b6Dbetag, sumb6XtWX, b6DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b6prbeta, sumb6zbeta, b6pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 6;
					b6beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b6DXtWX, b6CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b6CC, b6CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b6CI, b6pbeta, b6pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b6CI, b6CI);						/* transpose */
				call mult(b6CI, b6pbeta, b6pbeta);				/* re-scale pbeta (part 2) */
				call mult(b6CI, b6beta, b6beta);				/* re-scale beta */
				call addmatrix(b6pbeta, b6beta, b6beta);		/* re-center */
				call mult(b6X, b6beta, bXbeta);					/* updated vector bX */
				s1b1 = b6beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b6beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b6beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b6beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b6beta[5,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = b6beta[6,1];								/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			if flg = 45 then do;								/* common cubic-quad trend model */
				call addmatrix(b5Dbetag, sumb5XtWX, b5DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b5prbeta, sumb5zbeta, b5pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 5;
					b5beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b5DXtWX, b5CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b5CC, b5CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b5CI, b5pbeta, b5pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b5CI, b5CI);						/* transpose */
				call mult(b5CI, b5pbeta, b5pbeta);				/* re-scale pbeta (part 2) */
				call mult(b5CI, b5beta, b5beta);				/* re-scale beta */
				call addmatrix(b5pbeta, b5beta, b5beta);		/* re-center */
				call mult(b5X, b5beta, bXbeta);					/* updated vector bX */
				s1b1 = b5beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b5beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b5beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b5beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b5beta[5,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = 0;										/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			if flg = 46 then do;								/* common cubic-linear trend model */
				call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b4beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b4DXtWX, b4CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b4CC, b4CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b4CI, b4CI);						/* transpose */
				call mult(b4CI, b4pbeta, b4pbeta);				/* re-scale pbeta (part 2) */
				call mult(b4CI, b4beta, b4beta);				/* re-scale beta */
				call addmatrix(b4pbeta, b4beta, b4beta);		/* re-center */
				call mult(b4X, b4beta, bXbeta);					/* updated vector bX */
				s1b1 = b4beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b4beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = b4beta[3,1];								/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b4beta[4,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = 0;										/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			if flg = 55 then do;								/* common quad-quad trend model */
				call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 4;
					b3beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b3DXtWX, b3CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b3CC, b3CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b3CI, b3CI);						/* transpose */
				call mult(b3CI, b3pbeta, b3pbeta);				/* re-scale pbeta (part 2) */
				call mult(b3CI, b3beta, b3beta);				/* re-scale beta */
				call addmatrix(b3pbeta, b3beta, b3beta);		/* re-center */
				call mult(b3X, b3beta, bXbeta);					/* updated vector bX */
				s1b1 = b3beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b3beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b3beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = b3beta[4,1];								/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = 0;										/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			if flg = 56 then do;								/* common quad-linear trend model */
				call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 3;
					b2beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b2DXtWX, b2CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b2CC, b2CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b2CI, b2CI);						/* transpose */
				call mult(b2CI, b2pbeta, b2pbeta);				/* re-scale pbeta (part 2) */
				call mult(b2CI, b2beta, b2beta);				/* re-scale beta */
				call addmatrix(b2pbeta, b2beta, b2beta);		/* re-center */
				call mult(b2X, b2beta, bXbeta);					/* updated vector bX */
				s1b1 = b2beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = b2beta[2,1];								/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b2beta[3,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = 0;										/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			if flg = 66 then do;								/* common linear-linear trend model */
				call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 	/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
				call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);	/* sum of prior and the cumulative WLS contributions */
				do m = 1 to 2;
					b1beta[m,1] = rand('normal');				/* sample from univariate standard normal(s) */
				end;
				call chol(b1DXtWX, b1CC);						/* Cholesky decomposition for (p-2)x(p-2) precision matrix (returns lower triangular) */
				call inv(b1CC, b1CI);							/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 1) */
				call transpose(b1CI, b1CI);						/* transpose */
				call mult(b1CI, b1pbeta, b1pbeta);				/* re-scale pbeta (part 2) */
				call mult(b1CI, b1beta, b1beta);				/* re-scale beta */
				call addmatrix(b1pbeta, b1beta, b1beta);		/* re-center */
				call mult(b1X, b1beta, bXbeta);					/* updated vector bX */
				s1b1 = b1beta[1,1];								/* output argument s1b1 is updated value of common linear coefficient for segment 1 */
				s1b2 = 0;										/* output argument s1b2 is updated value of common quad coefficient for segment 1 */
				s1b3 = 0;										/* output argument s1b3 is updated value of common cubic coefficient for segment 1 */
				s2b1 = b1beta[2,1];								/* output argument s2b1 is updated value of common linear coefficient for segment 2 */
				s2b2 = 0;										/* output argument s2b2 is updated value of common quad coefficient for segment 2 */
				s2b3 = 0;										/* output argument s2b3 is updated value of common cubic coefficient for segment 2 */
			end;
			do k = 1 to &g;										/* arrays of group-specific coefficient also updated to reflect common value */
				s1b1g[k] = s1b1;
				s1b2g[k] = s1b2;
				s1b3g[k] = s1b3;
				s2b1g[k] = s2b1;
				s2b2g[k] = s2b2;
				s2b3g[k] = s2b3;
			end;
			/************************************************/
			/* Update intercepts and regression predictions */
			/************************************************/
			do k = 1 to &g;
			    do i = 1 to &n;						
				  Zvec[i,1]= Yarr[(k-1)*&n+i] - bXbeta[i,1];	/* populate nx1 data vector Zvec = Yvec - bX */
				  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  	/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
				end; 
				do i = 1 to &n-1;
				  do j = i+1 to &n;
					Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
					Vg[j,i] = Vg[i,j];
				  end; 
			  	end; 
				call inv(Vg, Wg);								/* Wg = Vg^{-1} */
				call mult(aXt, Wg, aXtW);						/* multiply aXt and Wg */
				call mult(aXtW, aX, aXtWX);						/* calculate aXtWX, the precision matrix from WLS */
				call addmatrix(aDbetag, aXtWX, aDXtWX); 		/* posterior precision matrix is aDbetag + XtWX */
				call mult(aXtW, Zvec, azbeta);					/* contribution to posterior mean from WLS */
				call addmatrix(aprbeta, azbeta, apbeta); 		/* sum of prior and WLS contributions */
				abeta[1,1] = rand('normal');					/* sample intercept from univariate normal -- segment 1 */
				abeta[2,1] = rand('normal');					/* sample intercept from univariate normal -- segment 2 */
				call chol(aDXtWX, aCC);							/* Cholesky decomposition for precision matrix (returns lower triangular) */
				call inv(aCC, aCI);								/* inverse of lower triangular matrix from Cholesky decomposition */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 1) */
				call transpose(aCI, aCI);						/* transpose */
				call mult(aCI, apbeta, apbeta);					/* re-scale pbeta (part 2) */
				call mult(aCI, abeta, abeta);					/* re-scale beta */
				call addmatrix(apbeta, abeta, abeta);			/* re-center */
				s1ag[k] = abeta[1,1];							/* output argument s1a is 1-dimensional array of group-specific intercepts for segment 1 */
				s2ag[k] = abeta[2,1];							/* output argument s2a is 1-dimensional array of group-specific intercepts for segment 2 */
				call mult(aX, abeta, aXbeta);					/* vector of intercepts a */
				do i = 1 to &n; 								
			      etamnarr[(k-1)*&n+i] = aXbeta[i,1] + bXbeta[i,1]; /* updated predictions from regression */
				end;
			end;
		end;

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_CP_xptf;

data _null_;
run;


/**********************************************************************/
/* eMKF: Gibbs samplers for model flags in the supported trend models */
/**********************************************************************/
%macro gibbs_uds_compile_FP(uvar=, g=, n=, loc=) / minoperator; /* eMKF v2.4 streamlining: added minoperator keyword */

/* eMKF: return if no applicable model is indicated */
%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
	/* eMKF v2.4 streamlining: piped error to log file only for internal/utility macros */
	%put ERROR: No Gibbs sampler for model flag was found for the specified Bayesian model averaging &uvar: Please check!;
	%return;
%end;

%local fp uloc;

/* eMKF v2.4 streamlining: directly calculate dimensionality of wts[*] vector instead of via model dimension p */
/* 			Model dimension p does not need to be specified explicitly, as it is subsumed in matrix operations */
%let fp = 0;
%if %upcase(&uvar) = BMA_LINEAR %then %let fp = 3;
%if %upcase(&uvar) = BMA_QUAD   %then %let fp = 5;
%if %upcase(&uvar) = BMA_CUBIC  %then %let fp = 7;
%let fp = %eval(0+&fp);

%let uloc = &loc..uds;

%if %upcase(&uvar) = BMA_LINEAR %then %do;
	/********************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA linear trend model */
	/********************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_bmal(flg,					/* model flag , with integer values 1 through 3 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   ag[*],				/* 1-dimensional array of intercepts to subtract off from y's */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[1, 1] 						/nosym;	/* vector (1x1) of intercepts */

		/******************************************/
		/* Array structures for indep trend model */
		/******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */

		/*******************************************/
		/* Array structures for common trend model */
		/*******************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/
		
		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		end;

		/*****************************************/
		/* indep linear with no intercept: q = 1 */
		/*****************************************/
		do i = 1 to &n;
			do m = 2 to 2;
				q1X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 2 to 2;
			q1mbetag[m-1, 1]   = mbetag[m, 1];
			q1Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/******************************************/
		/* common linear with no intercept: q = 1 */
		/******************************************/
		do i = 1 to &n;								
		  	do m = 2 to 2;
				b1X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 2 to 2;
			b1mbetag[m-1, 1]   = mbetag[m, 1];
		    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* eMKF v2.4 note: fp = 3 here */
		pwts[3] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/*************************************************************/
			/* group-specific linear trend model with no intercept (q=1) */
			/*************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[1] = pwts[1] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[2] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[2] = pwts[2] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[2] = pwts[2] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[2] = pwts[2] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[2] = pwts[2] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* eMKF v2.4 note: fp = 3 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3]);
		
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD %then %do;
	/********************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA quad trend model */
	/********************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_bmaq(flg,					/* model flag , with integer values 1 through 5 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   ag[*],				/* 1-dimensional array of intercepts to subtract off from y's */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[1, 1] 						/nosym;	/* vector (1x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep quad] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */
		array q2tmbetag[1, 2]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 2] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */
		array q2zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */
		array q2CI[2, 2] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [common quad] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */
		array b2tmbetag[1, 2] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */
		array b2tpbeta[1, 2]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */
		array b2CI[2, 2]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		end;

		/***************************************/
		/* indep quad with no intercept: q = 2 */
		/***************************************/
		do i = 1 to &n;
			do m = 2 to 3;
				q2X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 2 to 3;
			q2mbetag[m-1, 1]   = mbetag[m, 1];
			q2Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* indep linear with no intercept: q = 1 */
		/*****************************************/
		do i = 1 to &n;
			do m = 2 to 2;
				q1X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 2 to 2;
			q1mbetag[m-1, 1]   = mbetag[m, 1];
			q1Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/****************************************/
		/* common quad with no intercept: q = 2 */
		/****************************************/
		do i = 1 to &n;								
		  	do m = 2 to 3;
				b2X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 2 to 3;
			b2mbetag[m-1, 1]   = mbetag[m, 1];
		    b2Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/******************************************/
		/* common linear with no intercept: q = 1 */
		/******************************************/
		do i = 1 to &n;								
		  	do m = 2 to 2;
				b1X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 2 to 2;
			b1mbetag[m-1, 1]   = mbetag[m, 1];
		    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* eMKF v2.4 note: fp = 5 here */
		pwts[5] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific quad trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[2] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/***********************************************************/
			/* group-specific quad trend model with no intercept (q=2) */
			/***********************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[1] = pwts[1] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*************************************************************/
			/* group-specific linear trend model with no intercept (q=1) */
			/*************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[2] = pwts[2] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[3] = 0;									/* common quad trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[3] = pwts[3] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[3] = pwts[3] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[4] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/**********************************************/
			/* common quad trend model with no intercepts */
			/**********************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/**********************************************/
		/* common quad trend model with no intercepts */
		/**********************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[3] = pwts[3] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[3] = pwts[3] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[4] = pwts[4] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* eMKF v2.4 note: fp = 5 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5]);	
		
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC %then %do;
	/********************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA cubic trend model  */
	/********************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_bmac(flg,					/* model flag , with integer values 1 through 7 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   ag[*],				/* 1-dimensional array of intercepts to subtract off from y's */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 1]							/nosym; /* 1-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[1, 1] 						/nosym;	/* vector (1x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep quad] */
		array q3X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep cubic] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q3mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */
		array q2tmbetag[1, 2]					/nosym; /* transpose */
		array q3tmbetag[1, 3]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q3Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[3, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q3prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q3pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q3tpbeta[1, 3] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */
		array q2zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q3zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */
		array q2CI[2, 2] 					  	/nosym;	/* inverse */
		array q3CI[3, 3] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q3exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [common quad] */
		array b3mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) [common cubic] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */
		array b2tmbetag[1, 2] 					/nosym;	/* transpose */
		array b3tmbetag[1, 3] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b3Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b3X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */
		array b2tpbeta[1, 2]            		/nosym; /* transpose */
		array b3tpbeta[1, 3]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */
		array b2CI[2, 2]     					/nosym; /* inverse */
		array b3CI[3, 3]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */
		array b3exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		end;

		/****************************************/
		/* indep cubic with no intercept: q = 3 */
		/****************************************/
		do i = 1 to &n;
			do m = 2 to 4;
				q3X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q3Dbetag);
		do m = 2 to 4;
			q3mbetag[m-1, 1]   = mbetag[m, 1];
			q3Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q3X, q3Xt);					/* transpose qX */
		call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */

		/***************************************/
		/* indep quad with no intercept: q = 2 */
		/***************************************/
		do i = 1 to &n;
			do m = 2 to 3;
				q2X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 2 to 3;
			q2mbetag[m-1, 1]   = mbetag[m, 1];
			q2Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* indep linear with no intercept: q = 1 */
		/*****************************************/
		do i = 1 to &n;
			do m = 2 to 2;
				q1X[i, m-1] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 2 to 2;
			q1mbetag[m-1, 1]   = mbetag[m, 1];
			q1Dbetag[m-1, m-1] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* common cubic with no intercept: q = 3 */
		/*****************************************/
		do i = 1 to &n;								
		  	do m = 2 to 4;
				b3X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b3Dbetag); 
		do m = 2 to 4;
			b3mbetag[m-1, 1]   = mbetag[m, 1];
		    b3Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b3X, b3Xt);					/* transpose bX */
		call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb3zbeta);	

		/****************************************/
		/* common quad with no intercept: q = 2 */
		/****************************************/
		do i = 1 to &n;								
		  	do m = 2 to 3;
				b2X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 2 to 3;
			b2mbetag[m-1, 1]   = mbetag[m, 1];
		    b2Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/******************************************/
		/* common linear with no intercept: q = 1 */
		/******************************************/
		do i = 1 to &n;								
		  	do m = 2 to 2;
				b1X[i, m-1] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 2 to 2;
			b1mbetag[m-1, 1]   = mbetag[m, 1];
		    b1Dbetag[m-1, m-1] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* eMKF v2.4 note: fp = 7 here */
		pwts[7] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific cubic trend model */
		call transpose(q3mbetag, q3tmbetag);
		call mult(q3tmbetag, q3prbeta, q3exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q3exp[1,1];			/* log scale */
		call det(q3Dbetag, q3wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q3wts);			/* log scale */

		pwts[2] = 0;									/* group-specific quad trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[3] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/************************************************************/
			/* group-specific cubic trend model with no intercept (q=3) */
			/************************************************************/
			call mult(q3Xt, Wg, q3XtW);					/* multiply Xt and Wg */
			call mult(q3XtW, q3X, q3XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q3Dbetag, q3XtWX, q3DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q3XtW, Zvec, q3zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q3prbeta, q3zbeta, q3pbeta);	/* sum of prior and WLS contributions */
			call transpose(q3pbeta, q3tpbeta);			/* transpose */
			call inv(q3DXtWX, q3CI);					/* inverse of posterior precision matrix */
			call mult(q3CI, q3pbeta, q3pbeta);			/* re-scale pbeta */
			call mult(q3tpbeta, q3pbeta, q3exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q3exp[1,1];			/* log scale */
			call det(q3DXtWX, q3wts);
			pwts[1] = pwts[1] - 0.5*log(q3wts); 		/* determinant for normalizing constant */

			/***********************************************************/
			/* group-specific quad trend model with no intercept (q=2) */
			/***********************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[2] = pwts[2] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*************************************************************/
			/* group-specific linear trend model with no intercept (q=1) */
			/*************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[3] = pwts[3] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[4] = 0;									/* common cubic trend model */
		call transpose(b3mbetag, b3tmbetag);
		call mult(b3tmbetag, b3prbeta, b3exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b3exp[1,1];				/* log scale */
		call det(b3Dbetag, b3wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b3wts);				/* log scale */		
	
		pwts[5] = 0;									/* common quad trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[5] = pwts[5] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[5] = pwts[5] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[6] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[6] = pwts[6] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[6] = pwts[6] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = ag[k];							/* group-specific abeta vector */
			call mult(aX, abeta, aXbeta);				/* vector of intercepts a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - a */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/***********************************************/
			/* common cubic trend model with no intercepts */
			/***********************************************/
		    call mult(b3Xt, Wg, b3XtW);						/* multiply bXt and Wg */
		    call mult(b3XtW, b3X, b3XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
		    call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);	/* cumulative matrix sum */

			/**********************************************/
			/* common quad trend model with no intercepts */
			/**********************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/***********************************************/
		/* common cubic trend model with no intercepts */
		/***********************************************/
		call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b3pbeta, b3tpbeta);					/* transpose */
		call inv(b3DXtWX, b3CI);							/* inverse of posterior precision matrix  */
		call mult(b3CI, b3pbeta, b3pbeta);					/* re-scale pbeta */
		call mult(b3tpbeta, b3pbeta, b3exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b3exp[1,1];					/* log scale */
		call det(b3DXtWX, b3wts);
		pwts[4] = pwts[4] - 0.5*log(b3wts); 				/* determinant for normalizing constant */

		/**********************************************/
		/* common quad trend model with no intercepts */
		/**********************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[5] = pwts[5] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[5] = pwts[5] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[6] = pwts[6] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[6] = pwts[6] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;							/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* eMKF v2.4 note: fp = 7 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5], qwts[6], qwts[7]);
		
		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_FP;

data _null_;
run;

/*****************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for model flags in the supported trend models for level-shift scenarios */
/*****************************************************************************************************/
%macro gibbs_uds_compile_FP_xptl(uvar=, g=, n=, loc=) / minoperator;

/* eMKF: return if no applicable model is indicated */
%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
	%put ERROR: No Gibbs sampler for model flag was found for the specified Bayesian model averaging &uvar: Please check!;
	%return;
%end;

%local fp uloc;

/* eMKF v2.4: calculate dimensionality of wts[*] vector for UDS setup */
%let fp = 0;
%if %upcase(&uvar) = BMA_LINEAR %then %let fp = 3;
%if %upcase(&uvar) = BMA_QUAD   %then %let fp = 5;
%if %upcase(&uvar) = BMA_CUBIC  %then %let fp = 7;
%let fp = %eval(0+&fp);

%let uloc = &loc..uds;

%if %upcase(&uvar) = BMA_LINEAR %then %do;
	/*************************************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA linear trend model with level shift */
	/*************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptl_bmal(
						   flg,					/* model flag, with values 1 through 3 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* vector (2x1) of intercepts */

		/******************************************/
		/* Array structures for indep trend model */
		/******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */

		/*******************************************/
		/* Array structures for common trend model */
		/*******************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		  	aX[i, 2] = X[i, 2];
		end;

		/******************************************/
		/* indep linear with no intercepts: q = 1 */
		/******************************************/
		do i = 1 to &n;
			do m = 3 to 3;
				q1X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 3 to 3;
			q1mbetag[m-2, 1]   = mbetag[m, 1];
			q1Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/*******************************************/
		/* common linear with no intercepts: q = 1 */
		/*******************************************/
		do i = 1 to &n;								
		  	do m = 3 to 3;
				b1X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 3 to 3;
			b1mbetag[m-2, 1]   = mbetag[m, 1];
		    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 3 here */
		pwts[3] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/**************************************************************/
			/* group-specific linear trend model with no intercepts (q=1) */
			/**************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[1] = pwts[1] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[2] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[2] = pwts[2] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[2] = pwts[2] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[2] = pwts[2] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[2] = pwts[2] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;								/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 3 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3]);
		
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD %then %do;
	/***********************************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA quad trend model with level shift */
	/***********************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptl_bmaq(
						   flg,					/* model flag , with values 1 through 5 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep quad] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */
		array q2tmbetag[1, 2]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 2] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */
		array q2zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */
		array q2CI[2, 2] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [common quad] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */
		array b2tmbetag[1, 2] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */
		array b2tpbeta[1, 2]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */
		array b2CI[2, 2]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		  	aX[i, 2] = X[i, 2];
		end;

		/***************************************/
		/* indep quad with no intercept: q = 2 */
		/***************************************/
		do i = 1 to &n;
			do m = 3 to 4;
				q2X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 3 to 4;
			q2mbetag[m-2, 1]   = mbetag[m, 1];
			q2Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* indep linear with no intercept: q = 1 */
		/*****************************************/
		do i = 1 to &n;
			do m = 3 to 3;
				q1X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 3 to 3;
			q1mbetag[m-2, 1]   = mbetag[m, 1];
			q1Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/****************************************/
		/* common quad with no intercept: q = 2 */
		/****************************************/
		do i = 1 to &n;								
		  	do m = 3 to 4;
				b2X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 3 to 4;
			b2mbetag[m-2, 1]   = mbetag[m, 1];
		    b2Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/******************************************/
		/* common linear with no intercept: q = 1 */
		/******************************************/
		do i = 1 to &n;								
		  	do m = 3 to 3;
				b1X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 3 to 3;
			b1mbetag[m-2, 1]   = mbetag[m, 1];
		    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 5 here */
		pwts[5] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific quad trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[2] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/***********************************************************/
			/* group-specific quad trend model with no intercept (q=2) */
			/***********************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[1] = pwts[1] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*************************************************************/
			/* group-specific linear trend model with no intercept (q=1) */
			/*************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[2] = pwts[2] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[3] = 0;									/* common quad trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[3] = pwts[3] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[3] = pwts[3] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[4] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/**********************************************/
			/* common quad trend model with no intercepts */
			/**********************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/**********************************************/
		/* common quad trend model with no intercepts */
		/**********************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[3] = pwts[3] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[3] = pwts[3] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[4] = pwts[4] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 5 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5]);
		
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC %then %do;
	/************************************************************************************/
	/* eMKF: Gibbs sampler for model flag in the BMA cubic trend model with level shift */
	/************************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptl_bmac(
						   flg,					/* model flag , with values 1 through 7 */
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's in segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg;							/* argument that is updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 1]						/nosym; /* 1-column version of the design matrix X [indep linear] */
		array q2X[&n, 2]						/nosym; /* 2-column version of the design matrix X [indep quad] */
		array q3X[&n, 3]						/nosym; /* 3-column version of the design matrix X [indep cubic] */

		array q1mbetag[1, 1]					/nosym; /* 1-dimensional version of mbetag */
		array q2mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q3mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */

		array q1tmbetag[1, 1]					/nosym; /* transpose */
		array q2tmbetag[1, 2]					/nosym; /* transpose */
		array q3tmbetag[1, 3]					/nosym; /* transpose */

		array q1Dbetag[1, 1]					/nosym; /* 1-dimensional version of Dbetag */
		array q2Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q3Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */

		array q1Xt[1, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[3, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[1, 1]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from prior */
		array q2prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q3prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */

		array q1pbeta[1, 1] 	    			/nosym;	/* vector (1 x 1) of regression estimates from pooled posterior */
		array q2pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q3pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 1] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q3tpbeta[1, 3] 	    			/nosym;	/* transpose */

		array q1zbeta[1, 1] 	       			/nosym;	/* vector (1 x 1) of regression estimates from WLS */
		array q2zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q3zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */

		array q1CI[1, 1] 					  	/nosym;	/* inverse */
		array q2CI[2, 2] 					  	/nosym;	/* inverse */
		array q3CI[3, 3] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q3exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[1, 1] 					/nosym;	/* prior mean vector (1 x 1) for coefficients (excl. intercept) [common linear] */
		array b2mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [common quad] */
		array b3mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) [common cubic] */

		array b1tmbetag[1, 1] 					/nosym;	/* transpose */
		array b2tmbetag[1, 2] 					/nosym;	/* transpose */
		array b3tmbetag[1, 3] 					/nosym;	/* transpose */

		array b1Dbetag[1, 1] 					/nosym;	/* diagonal matrix (1 x 1) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b3Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 1]						/nosym; /* 1-dimensional conformal design submatrix X */
		array b2X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b3X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */

		array sumb1XtWX[1, 1] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[1, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[1, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[1, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[1, 1] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[1, 1]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[1, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[1, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 1]            		/nosym; /* transpose */
		array b2tpbeta[1, 2]            		/nosym; /* transpose */
		array b3tpbeta[1, 3]            		/nosym; /* transpose */

		array b1zbeta[1, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[1, 1]     					/nosym; /* inverse */
		array b2CI[2, 2]     					/nosym; /* inverse */
		array b3CI[3, 3]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */
		array b3exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
		  	aX[i, 1] = X[i, 1]; 					/* intercepts */
		  	aX[i, 2] = X[i, 2];
		end;

		/****************************************/
		/* indep cubic with no intercept: q = 3 */
		/****************************************/
		do i = 1 to &n;
			do m = 3 to 5;
				q3X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q3Dbetag);
		do m = 3 to 5;
			q3mbetag[m-2, 1]   = mbetag[m, 1];
			q3Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q3X, q3Xt);					/* transpose qX */
		call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */

		/***************************************/
		/* indep quad with no intercept: q = 2 */
		/***************************************/
		do i = 1 to &n;
			do m = 3 to 4;
				q2X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 3 to 4;
			q2mbetag[m-2, 1]   = mbetag[m, 1];
			q2Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* indep linear with no intercept: q = 1 */
		/*****************************************/
		do i = 1 to &n;
			do m = 3 to 3;
				q1X[i, m-2] = X[i, m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 3 to 3;
			q1mbetag[m-2, 1]   = mbetag[m, 1];
			q1Dbetag[m-2, m-2] = Dbetag[m, m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/*****************************************/
		/* common cubic with no intercept: q = 3 */
		/*****************************************/
		do i = 1 to &n;								
		  	do m = 3 to 5;
				b3X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b3Dbetag); 
		do m = 3 to 5;
			b3mbetag[m-2, 1]   = mbetag[m, 1];
		    b3Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b3X, b3Xt);					/* transpose bX */
		call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb3zbeta);	

		/****************************************/
		/* common quad with no intercept: q = 2 */
		/****************************************/
		do i = 1 to &n;								
		  	do m = 3 to 4;
				b2X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 3 to 4;
			b2mbetag[m-2, 1]   = mbetag[m, 1];
		    b2Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/******************************************/
		/* common linear with no intercept: q = 1 */
		/******************************************/
		do i = 1 to &n;								
		  	do m = 3 to 3;
				b1X[i, m-2] = X[i, m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 3 to 3;
			b1mbetag[m-2, 1]   = mbetag[m, 1];
		    b1Dbetag[m-2, m-2] = Dbetag[m, m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 7 here */
		pwts[7] = 0;									/* no contribution from marginal for group-specific intercept-only model */

		pwts[1] = 0;									/* group-specific cubic trend model */
		call transpose(q3mbetag, q3tmbetag);
		call mult(q3tmbetag, q3prbeta, q3exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q3exp[1,1];			/* log scale */
		call det(q3Dbetag, q3wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q3wts);			/* log scale */

		pwts[2] = 0;									/* group-specific quad trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[3] = 0;									/* group-specific linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/************************************************************/
			/* group-specific cubic trend model with no intercept (q=3) */
			/************************************************************/
			call mult(q3Xt, Wg, q3XtW);					/* multiply Xt and Wg */
			call mult(q3XtW, q3X, q3XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q3Dbetag, q3XtWX, q3DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q3XtW, Zvec, q3zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q3prbeta, q3zbeta, q3pbeta);	/* sum of prior and WLS contributions */
			call transpose(q3pbeta, q3tpbeta);			/* transpose */
			call inv(q3DXtWX, q3CI);					/* inverse of posterior precision matrix */
			call mult(q3CI, q3pbeta, q3pbeta);			/* re-scale pbeta */
			call mult(q3tpbeta, q3pbeta, q3exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q3exp[1,1];			/* log scale */
			call det(q3DXtWX, q3wts);
			pwts[1] = pwts[1] - 0.5*log(q3wts); 		/* determinant for normalizing constant */

			/***********************************************************/
			/* group-specific quad trend model with no intercept (q=2) */
			/***********************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[2] = pwts[2] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*************************************************************/
			/* group-specific linear trend model with no intercept (q=1) */
			/*************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[3] = pwts[3] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[4] = 0;									/* common cubic trend model */
		call transpose(b3mbetag, b3tmbetag);
		call mult(b3tmbetag, b3prbeta, b3exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b3exp[1,1];				/* log scale */
		call det(b3Dbetag, b3wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b3wts);				/* log scale */		
	
		pwts[5] = 0;									/* common quad trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[5] = pwts[5] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[5] = pwts[5] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[6] = 0;									/* common linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[6] = pwts[6] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[6] = pwts[6] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector -- segment 1 */
			abeta[2,1] = s2ag[k];						/* group-specific abeta vector -- segment 2 */
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/***********************************************/
			/* common cubic trend model with no intercepts */
			/***********************************************/
		    call mult(b3Xt, Wg, b3XtW);						/* multiply bXt and Wg */
		    call mult(b3XtW, b3X, b3XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
		    call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);	/* cumulative matrix sum */

			/**********************************************/
			/* common quad trend model with no intercepts */
			/**********************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/************************************************/
			/* common linear trend model with no intercepts */
			/************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/***********************************************/
		/* common cubic trend model with no intercepts */
		/***********************************************/
		call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b3pbeta, b3tpbeta);					/* transpose */
		call inv(b3DXtWX, b3CI);							/* inverse of posterior precision matrix  */
		call mult(b3CI, b3pbeta, b3pbeta);					/* re-scale pbeta */
		call mult(b3tpbeta, b3pbeta, b3exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b3exp[1,1];					/* log scale */
		call det(b3DXtWX, b3wts);
		pwts[4] = pwts[4] - 0.5*log(b3wts); 				/* determinant for normalizing constant */

		/**********************************************/
		/* common quad trend model with no intercepts */
		/**********************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[5] = pwts[5] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[5] = pwts[5] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/************************************************/
		/* common linear trend model with no intercepts */
		/************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[6] = pwts[6] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[6] = pwts[6] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;								/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 7 here */
		flg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5], qwts[6], qwts[7]);
		
		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_FP_xptl;

data _null_;
run;

/**********************************************************************************************************/
/* eMKF v2.4: Gibbs samplers for model flags in the supported trend models for full trend break scenarios */
/**********************************************************************************************************/
%macro gibbs_uds_compile_FP_xptf(uvar=, s2uvar=, g=, n=, loc=) / minoperator;

/* eMKF: return if no applicable model is indicated */
%if not(%upcase(&uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
	%put ERROR: No Gibbs sampler for model flag was found for the segment 1 Bayesian model average &uvar: Please check!;
	%return;
%end;
%if not(%upcase(&s2uvar) in BMA_CUBIC BMA_QUAD BMA_LINEAR) %then %do;
	%put ERROR: No Gibbs sampler for model flag was found for the segment 2 Bayesian model average &uvar: Please check!;
	%return;
%end;
%if (%upcase(&uvar) = BMA_LINEAR and %upcase(&s2uvar) ^= BMA_LINEAR) or (%upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_CUBIC) %then %do;
	%put ERROR: Model combination &uvar for segment 1 and &s2uvar for segment 2 is not supported: Please check!;
	%return;
%end;

%local fp uloc;

/* eMKF v2.4: calculate dimensionality of wts[*] vector for UDS set up */
%let fp = 0;
%if %upcase(&uvar) = BMA_LINEAR and %upcase(&s2uvar) = BMA_LINEAR %then %let fp = 3; 
%if %upcase(&uvar) = BMA_QUAD   and %upcase(&s2uvar) = BMA_LINEAR %then %let fp = 5; 
%if %upcase(&uvar) = BMA_QUAD   and %upcase(&s2uvar) = BMA_QUAD   %then %let fp = 7; 
%if %upcase(&uvar) = BMA_CUBIC  and %upcase(&s2uvar) = BMA_LINEAR %then %let fp = 7; 
%if %upcase(&uvar) = BMA_CUBIC  and %upcase(&s2uvar) = BMA_QUAD   %then %let fp = 11; 
%if %upcase(&uvar) = BMA_CUBIC  and %upcase(&s2uvar) = BMA_CUBIC  %then %let fp = 13;
%let fp = %eval(0+&fp);

%let uloc = &loc..uds;

%if %upcase(&uvar) = BMA_LINEAR and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/****************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA linear-linear trend model */
	/****************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmal_bmal(
						   iflg,				/* internal flag for linear-linear case, with values 1, 2, 3 */
						   flg,					/* model flag for linear-linear case, with values 11, 22, 33 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************************/
		/* Array structures for indep trend model combinations */
		/*******************************************************/
		array q1X[&n, 2]						/nosym; /* eMKF v2.4: 2-column version of the design matrix X [linear-linear] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************************/
		/* Array structures for common trend model combinations */
		/********************************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [linear-linear] */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */

		array b1exp[1, 1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 2*m-1];				/* intercepts */
			end;
		end;

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 2*m];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[2*m, 1];
			q1Dbetag[m, m] = Dbetag[2*m, 2*m];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
		  	do m = 1 to 2;
				b1X[i, m] = X[i, 2*m];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[2*m, 1];
		    b1Dbetag[m, m] = Dbetag[2*m, 2*m];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 3 here */
		pwts[3] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/***************************************************************/
			/* group-specific linear-linear trend model with no intercepts */
			/***************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[1] = pwts[1] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[2] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[2] = pwts[2] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[2] = pwts[2] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[2] = pwts[2] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[2] = pwts[2] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 3 here */
		iflg = rand('table', qwts[1], qwts[2], qwts[3]);	

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 22;
			else do;
				if iflg = 3 then flg = 33;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);
		
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/**************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA quad-linear trend model */
	/**************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmaq_bmal(
						   iflg,				/* internal flag for quad-linear case, with values 1, 2, 3, 4, 5 */
						   flg,					/* model flag for quad-linear case, with values 11, 21, 32, 42, 53 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 2]						/nosym; /* eMKF v2.4: 2-column version of the design matrix X [linear-linear] */
		array q2X[&n, 3]						/nosym; /* eMKF v2.4: 3-column version of the design matrix X [quad-linear] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */
		array q2tmbetag[1, 3]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 3] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q2zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */
		array q2CI[3, 3] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [linear-linear] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) [quad-linear] */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */
		array b2tmbetag[1, 3] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */
		array b2tpbeta[1, 3]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */
		array b2CI[3, 3]     					/nosym; /* inverse */

		array b1exp[1, 1]						/nosym; /* holds quadratic form */
		array b2exp[1, 1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 3*m-2];				/* intercepts */
			end;
		end;

		/***********************************************/
		/* indep quad-linear with no intercepts: q = 3 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q2X[i, 2*m-1] = X[i, 3*m-1];
				if m=1 then q2X[i, 2*m] = X[i, 3*m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 1 to 2;
			q2mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			q2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			if m=1 then do;
				q2mbetag[2*m, 1]   = mbetag[3*m, 1];
				q2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];
			end;
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 3*m-1];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[3*m-1, 1];
			q1Dbetag[m, m] = Dbetag[3*m-1, 3*m-1];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/************************************************/
		/* common quad-linear with no intercepts: q = 3 */
		/************************************************/
		do i = 1 to &n;								
			do m = 1 to 2;
				b2X[i, 2*m-1] = X[i, 3*m-1];
				if m=1 then b2X[i, 2*m] = X[i, 3*m];
			end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 1 to 2;
			b2mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			if m=1 then do;
				b2mbetag[2*m, 1]   = mbetag[3*m, 1];
				b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];
			end;
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
			do m = 1 to 2;
				b1X[i, m] = X[i, 3*m-1];
			end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[3*m-1, 1];
			b1Dbetag[m, m] = Dbetag[3*m-1, 3*m-1];
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 5 here */
		pwts[5] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific quad-linear trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[2] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];	
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/*******************************************************************/
			/* group-specific quad-linear trend model with no intercepts (q=3) */
			/*******************************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[1] = pwts[1] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*********************************************************************/
			/* group-specific linear-linear trend model with no intercepts (q=2) */
			/*********************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[2] = pwts[2] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[3] = 0;									/* common quad-linear trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[3] = pwts[3] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[3] = pwts[3] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[4] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/*****************************************************/
			/* common quad-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/*****************************************************/
		/* common quad-linear trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[3] = pwts[3] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[3] = pwts[3] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[4] = pwts[4] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;

															/* fp = 5 here */
		iflg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5]);

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 21;
			else do;
				if iflg = 3 then flg = 32;
				else do;
					if iflg = 4 then flg = 42;
					else do;
						if iflg = 5 then flg = 53;
					end;
				end;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);
	
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_QUAD and %upcase(&s2uvar) = BMA_QUAD %then %do;
	/************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA quad-quad trend model */
	/************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmaq_bmaq(
						   iflg,				/* internal flag for quad-quad case, with values 1, 2, 3, 4, 5, 6, 7 */
						   flg,					/* model flag for quad-quad case, with values 11, 12, 22, 33, 34, 44, 55 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 2]						/nosym; /* eMKF v2.4: 2-column version of the design matrix X [linear-linear] */
		array q2X[&n, 3]						/nosym; /* eMKF v2.4: 3-column version of the design matrix X [quad-linear] */
		array q3X[&n, 4]						/nosym; /* eMKF v2.4: 4-column version of the design matrix X [quad-quad] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q3mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */
		array q2tmbetag[1, 3]					/nosym; /* transpose */
		array q3tmbetag[1, 4]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q3Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[4, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q3prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q3pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 3] 	    			/nosym;	/* transpose */
		array q3tpbeta[1, 4] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q2zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q3zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */
		array q2CI[3, 3] 					  	/nosym;	/* inverse */
		array q3CI[4, 4] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q3exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) [linear-linear] */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) [quad-linear] */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) [quad-quad] */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */
		array b2tmbetag[1, 3] 					/nosym;	/* transpose */
		array b3tmbetag[1, 4] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */
		array b2tpbeta[1, 3]            		/nosym; /* transpose */
		array b3tpbeta[1, 4]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */
		array b2CI[3, 3]     					/nosym; /* inverse */
		array b3CI[4, 4]     					/nosym; /* inverse */

		array b1exp[1, 1]						/nosym; /* holds quadratic form */
		array b2exp[1, 1]						/nosym; /* holds quadratic form */
		array b3exp[1, 1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 3*m-2];				/* intercepts */
			end;
		end;

		/*********************************************/
		/* indep quad-quad with no intercepts: q = 4 */
		/*********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q3X[i, 2*m-1] = X[i, 3*m-1];
				q3X[i, 2*m]   = X[i, 3*m];
			end;
		end;
		call zeromatrix(q3Dbetag);
		do m = 1 to 2;
			q3mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			q3Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			q3mbetag[2*m, 1]       = mbetag[3*m, 1];
			q3Dbetag[2*m, 2*m]     = Dbetag[3*m, 3*m];
		end;
		call transpose(q3X, q3Xt);					/* transpose qX */
		call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */

		/***********************************************/
		/* indep quad-linear with no intercepts: q = 3 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q2X[i, 2*m-1] = X[i, 3*m-1];
				if m=1 then q2X[i, 2*m] = X[i, 3*m];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 1 to 2;
			q2mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			q2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			if m=1 then do;
				q2mbetag[2*m, 1]   = mbetag[3*m, 1];
				q2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];
			end;
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 3*m-1];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[3*m-1, 1];
			q1Dbetag[m, m] = Dbetag[3*m-1, 3*m-1];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/**********************************************/
		/* common quad-quad with no intercepts: q = 4 */
		/**********************************************/
		do i = 1 to &n;								
			do m = 1 to 2;
				b3X[i, 2*m-1] = X[i, 3*m-1];
				b3X[i, 2*m]   = X[i, 3*m];
			end;
	  	end;
		call zeromatrix(b3Dbetag); 
		do m = 1 to 2;
			b3mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			b3Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			b3mbetag[2*m, 1]       = mbetag[3*m, 1];
			b3Dbetag[2*m, 2*m]     = Dbetag[3*m, 3*m];
		end;
		call transpose(b3X, b3Xt);					/* transpose bX */
		call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb3zbeta);	

		/************************************************/
		/* common quad-linear with no intercepts: q = 3 */
		/************************************************/
		do i = 1 to &n;								
			do m = 1 to 2;
				b2X[i, 2*m-1] = X[i, 3*m-1];
				if m=1 then b2X[i, 2*m] = X[i, 3*m];
			end;
	  	end;
		call zeromatrix(b2Dbetag); 
		do m = 1 to 2;
			b2mbetag[2*m-1, 1]     = mbetag[3*m-1, 1];
			b2Dbetag[2*m-1, 2*m-1] = Dbetag[3*m-1, 3*m-1];
			if m=1 then do;
				b2mbetag[2*m, 1]   = mbetag[3*m, 1];
				b2Dbetag[2*m, 2*m] = Dbetag[3*m, 3*m];
			end;
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
			do m = 1 to 2;
				b1X[i, m] = X[i, 3*m-1];
			end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[3*m-1, 1];
			b1Dbetag[m, m] = Dbetag[3*m-1, 3*m-1];
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/
														/* fp = 7 here */
		pwts[7] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific quad-quad trend model */
		call transpose(q3mbetag, q3tmbetag);
		call mult(q3tmbetag, q3prbeta, q3exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q3exp[1,1];			/* log scale */
		call det(q3Dbetag, q3wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q3wts);			/* log scale */

		pwts[2] = 0;									/* group-specific quad-linear trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[3] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];	
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/*****************************************************************/
			/* group-specific quad-quad trend model with no intercepts (q=4) */
			/*****************************************************************/
			call mult(q3Xt, Wg, q3XtW);					/* multiply Xt and Wg */
			call mult(q3XtW, q3X, q3XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q3Dbetag, q3XtWX, q3DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q3XtW, Zvec, q3zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q3prbeta, q3zbeta, q3pbeta);	/* sum of prior and WLS contributions */
			call transpose(q3pbeta, q3tpbeta);			/* transpose */
			call inv(q3DXtWX, q3CI);					/* inverse of posterior precision matrix */
			call mult(q3CI, q3pbeta, q3pbeta);			/* re-scale pbeta */
			call mult(q3tpbeta, q3pbeta, q3exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q3exp[1,1];			/* log scale */
			call det(q3DXtWX, q3wts);
			pwts[1] = pwts[1] - 0.5*log(q3wts); 		/* determinant for normalizing constant */

			/*******************************************************************/
			/* group-specific quad-linear trend model with no intercepts (q=3) */
			/*******************************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[2] = pwts[2] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*********************************************************************/
			/* group-specific linear-linear trend model with no intercepts (q=2) */
			/*********************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[3] = pwts[3] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[4] = 0;									/* common quad-quad trend model */
		call transpose(b3mbetag, b3tmbetag);
		call mult(b3tmbetag, b3prbeta, b3exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b3exp[1,1];				/* log scale */
		call det(b3Dbetag, b3wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b3wts);				/* log scale */		

		pwts[5] = 0;									/* common quad-linear trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[5] = pwts[5] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[5] = pwts[5] + 0.5*log(b2wts);				/* log scale */		
	
		pwts[6] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[6] = pwts[6] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[6] = pwts[6] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/***************************************************/
			/* common quad-quad trend model with no intercepts */
			/***************************************************/
		    call mult(b3Xt, Wg, b3XtW);						/* multiply bXt and Wg */
		    call mult(b3XtW, b3X, b3XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
		    call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common quad-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/***************************************************/
		/* common quad-quad trend model with no intercepts */
		/***************************************************/
		call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b3pbeta, b3tpbeta);					/* transpose */
		call inv(b3DXtWX, b3CI);							/* inverse of posterior precision matrix  */
		call mult(b3CI, b3pbeta, b3pbeta);					/* re-scale pbeta */
		call mult(b3tpbeta, b3pbeta, b3exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b3exp[1,1];					/* log scale */
		call det(b3DXtWX, b3wts);
		pwts[4] = pwts[4] - 0.5*log(b3wts); 				/* determinant for normalizing constant */

		/*****************************************************/
		/* common quad-linear trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[5] = pwts[5] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[5] = pwts[5] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[6] = pwts[6] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[6] = pwts[6] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;

															/* fp = 7 here */
		iflg = rand('table', qwts[1], qwts[2], qwts[3], qwts[4], qwts[5], qwts[6], qwts[7]);

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 12;
			else do;
				if iflg = 3 then flg = 22;
				else do;
					if iflg = 4 then flg = 33;
					else do;
						if iflg = 5 then flg = 34;
						else do;
							if iflg = 6 then flg = 44;
							else do;
								if iflg = 7 then flg = 55;
							end;
						end;
					end;
				end;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);
	
		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_LINEAR %then %do;
	/****************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA cubic-linear trend model  */
	/****************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmac_bmal(
						   iflg,				/* internal flag for cubic-linear case, with values 1, 2, 3, 4, 5, 6, 7 */
						   flg,					/* model flag for cubic-linear case, with values 11, 21, 31, 42, 52, 62, 73 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [linear-linear] */
		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [quad-linear] */
		array q4X[&n, 4]						/nosym; /* 4-column version of the design matrix X [cubic-linear] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q4mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */
		array q2tmbetag[1, 3]					/nosym; /* transpose */
		array q4tmbetag[1, 4]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q4Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q4Xt[4, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q4DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q4prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q4pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 3] 	    			/nosym;	/* transpose */
		array q4tpbeta[1, 4] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q2zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q4zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */
		array q2CI[3, 3] 					  	/nosym;	/* inverse */
		array q4CI[4, 4] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q4exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */
		array b2tmbetag[1, 3] 					/nosym;	/* transpose */
		array b4tmbetag[1, 4] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */
		array b2tpbeta[1, 3]            		/nosym; /* transpose */
		array b4tpbeta[1, 4]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */
		array b2CI[3, 3]     					/nosym; /* inverse */
		array b4CI[4, 4]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */
		array b4exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 4*m-3];				/* intercepts */
			end;
		end;

		/************************************************/
		/* indep cubic-linear with no intercepts: q = 4 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					q4X[i, 3*m-1] = X[i, 4*m-1];
					q4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(q4Dbetag);
		do m = 1 to 2;
			q4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				q4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				q4mbetag[3*m, 1]       = mbetag[4*m, 1];
				q4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(q4X, q4Xt);					/* transpose qX */
		call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */

		/***********************************************/
		/* indep quad-linear with no intercepts: q = 3 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then q2X[i, 2*m] = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 1 to 2;
			q2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			q2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				q2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 4*m-2];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[4*m-2, 1];
			q1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* common cubic-linear with no intercepts: q = 4 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					b4X[i, 3*m-1] = X[i, 4*m-1];
					b4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(b4Dbetag);
		do m = 1 to 2;
			b4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				b4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				b4mbetag[3*m, 1]   	   = mbetag[4*m, 1];
				b4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(b4X, b4Xt);					/* transpose bX */
		call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb4zbeta);	

		/************************************************/
		/* common quad-linear with no intercepts: q = 3 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then b2X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(b2Dbetag);
		do m = 1 to 2;
			b2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			b2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				b2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
		  	do m = 1 to 2;
				b1X[i, m] = X[i, 4*m-2];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[4*m-2, 1];
		    b1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/

		pwts[7] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific cubic-linear trend model */
		call transpose(q4mbetag, q4tmbetag);
		call mult(q4tmbetag, q4prbeta, q4exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q4exp[1,1];			/* log scale */
		call det(q4Dbetag, q4wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q4wts);			/* log scale */

		pwts[2] = 0;									/* group-specific quad-linear trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[3] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/********************************************************************/
			/* group-specific cubic-linear trend model with no intercepts (q=4) */
			/********************************************************************/
			call mult(q4Xt, Wg, q4XtW);					/* multiply Xt and Wg */
			call mult(q4XtW, q4X, q4XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q4Dbetag, q4XtWX, q4DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q4XtW, Zvec, q4zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q4prbeta, q4zbeta, q4pbeta);	/* sum of prior and WLS contributions */
			call transpose(q4pbeta, q4tpbeta);			/* transpose */
			call inv(q4DXtWX, q4CI);					/* inverse of posterior precision matrix */
			call mult(q4CI, q4pbeta, q4pbeta);			/* re-scale pbeta */
			call mult(q4tpbeta, q4pbeta, q4exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q4exp[1,1];			/* log scale */
			call det(q4DXtWX, q4wts);
			pwts[1] = pwts[1] - 0.5*log(q4wts); 		/* determinant for normalizing constant */

			/*******************************************************************/
			/* group-specific quad-linear trend model with no intercepts (q=3) */
			/*******************************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[2] = pwts[2] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*********************************************************************/
			/* group-specific linear-linear trend model with no intercepts (q=2) */
			/*********************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[3] = pwts[3] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[4] = 0;									/* common cubic-linear trend model */
		call transpose(b4mbetag, b4tmbetag);
		call mult(b4tmbetag, b4prbeta, b4exp);			/* exponent from normal pdf */
		pwts[4] = pwts[4] - 0.5*b4exp[1,1];				/* log scale */
		call det(b4Dbetag, b4wts);						/* determinant of prior precision matrix */
		pwts[4] = pwts[4] + 0.5*log(b4wts);				/* log scale */		

		pwts[5] = 0;									/* common quad-linear trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[5] = pwts[5] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[5] = pwts[5] + 0.5*log(b2wts);				/* log scale */		

		pwts[6] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[6] = pwts[6] - 0.5*b1exp[1,1];				/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[6] = pwts[6] + 0.5*log(b1wts);				/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-colum matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/*****************************************************/
			/* common cubic-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b4Xt, Wg, b4XtW);						/* multiply bXt and Wg */
		    call mult(b4XtW, b4X, b4XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
		    call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common quad-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/******************************************************/
		/* common cubic-linear trend model with no intercepts */
		/******************************************************/
		call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b4pbeta, b4tpbeta);					/* transpose */
		call inv(b4DXtWX, b4CI);							/* inverse of posterior precision matrix  */
		call mult(b4CI, b4pbeta, b4pbeta);					/* re-scale pbeta */
		call mult(b4tpbeta, b4pbeta, b4exp);				/* exponent from normal pdf */
		pwts[4] = pwts[4] + 0.5*b4exp[1,1];					/* log scale */
		call det(b4DXtWX, b4wts);
		pwts[4] = pwts[4] - 0.5*log(b4wts); 				/* determinant for normalizing constant */

		/*****************************************************/
		/* common quad-linear trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[5] = pwts[5] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[5] = pwts[5] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[6] = pwts[6] + 0.5*b1exp[1,1];					/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[6] = pwts[6] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 7 here */
		iflg = rand('table',qwts[1],qwts[2],qwts[3],qwts[4],qwts[5],qwts[6],qwts[7]);

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 21;
			else do;
				if iflg = 3 then flg = 31;
				else do;
					if iflg = 4 then flg = 42;
					else do;
						if iflg = 5 then flg = 52;
						else do;
							if iflg = 6 then flg = 62;
							else do;
								if iflg = 7 then flg = 73;
							end;
						end;
					end;
				end;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_QUAD %then %do;
	/**************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA cubic-quad trend model  */
	/**************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmac_bmaq(
						   iflg,				/* internal flag for cubic-quad case, with values 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 */
						   flg,					/* model flag for cubic-quad case, with values 11, 12, 21, 22, 32, 43, 44, 53, 54, 64, 75 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [linear-linear] */
		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [quad-linear] */
		array q3X[&n, 4]						/nosym; /* 4-column version of the design matrix X [quad-quad] */
		array q4X[&n, 4]						/nosym; /* 4-column version of the design matrix X [cubic-linear] */
		array q5X[&n, 5]						/nosym; /* 5-column version of the design matrix X [cubic-quad] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q3mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q4mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q5mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */
		array q2tmbetag[1, 3]					/nosym; /* transpose */
		array q3tmbetag[1, 4]					/nosym; /* transpose */
		array q4tmbetag[1, 4]					/nosym; /* transpose */
		array q5tmbetag[1, 5]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q3Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q4Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q5Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q4Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q5Xt[5, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q4DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q5DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q3prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q4prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q5prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q3pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q4pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q5pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 3] 	    			/nosym;	/* transpose */
		array q3tpbeta[1, 4] 	    			/nosym;	/* transpose */
		array q4tpbeta[1, 4] 	    			/nosym;	/* transpose */
		array q5tpbeta[1, 5] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q2zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q3zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q4zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q5zbeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */
		array q2CI[3, 3] 					  	/nosym;	/* inverse */
		array q3CI[4, 4] 					  	/nosym;	/* inverse */
		array q4CI[4, 4] 					  	/nosym;	/* inverse */
		array q5CI[5, 5] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q3exp[1, 1]						/nosym; /* holds quadratic form */
		array q4exp[1, 1]						/nosym; /* holds quadratic form */
		array q5exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) */
		array b5mbetag[5, 1] 					/nosym;	/* prior mean vector (5 x 1) for coefficients (excl. intercept) */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */
		array b2tmbetag[1, 3] 					/nosym;	/* transpose */
		array b3tmbetag[1, 4] 					/nosym;	/* transpose */
		array b4tmbetag[1, 4] 					/nosym;	/* transpose */
		array b5tmbetag[1, 5] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */
		array b5Dbetag[5, 5] 					/nosym;	/* diagonal matrix (5 x 5) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b5X[&n, 5]						/nosym; /* 5-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb5XtWX[5, 5] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb5zbeta[5, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b5Xt[5, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b5DXtWX[5, 5]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b5prbeta[5, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b5pbeta[5, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */
		array b2tpbeta[1, 3]            		/nosym; /* transpose */
		array b3tpbeta[1, 4]            		/nosym; /* transpose */
		array b4tpbeta[1, 4]            		/nosym; /* transpose */
		array b5tpbeta[1, 5]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b5zbeta[5, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */
		array b2CI[3, 3]     					/nosym; /* inverse */
		array b3CI[4, 4]     					/nosym; /* inverse */
		array b4CI[4, 4]     					/nosym; /* inverse */
		array b5CI[5, 5]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */
		array b3exp[1,1]						/nosym; /* holds quadratic form */
		array b4exp[1,1]						/nosym; /* holds quadratic form */
		array b5exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 4*m-3];				/* intercepts */
			end;
		end;

		/**********************************************/
		/* indep cubic-quad with no intercepts: q = 5 */
		/**********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q5X[i, 3*m-2] = X[i, 4*m-2];
				q5X[i, 3*m-1] = X[i, 4*m-1];
				if m=1 then q5X[i, 3*m] = X[i, 4*m];
			end;
		end;
		call zeromatrix(q5Dbetag);
		do m = 1 to 2;
			q5mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q5Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			q5mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			q5Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			if m=1 then do;
				q5mbetag[3*m, 1]   = mbetag[4*m, 1];
				q5Dbetag[3*m, 3*m] = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(q5X, q5Xt);					/* transpose qX */
		call mult(q5Dbetag, q5mbetag, q5prbeta);	/* contribution to posterior mean from prior */

		/************************************************/
		/* indep cubic-linear with no intercepts: q = 4 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					q4X[i, 3*m-1] = X[i, 4*m-1];
					q4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(q4Dbetag);
		do m = 1 to 2;
			q4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				q4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				q4mbetag[3*m, 1]       = mbetag[4*m, 1];
				q4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(q4X, q4Xt);					/* transpose qX */
		call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */

		/*********************************************/
		/* indep quad-quad with no intercepts: q = 4 */
		/*********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q3X[i, 2*m-1] = X[i, 4*m-2];
				q3X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(q3Dbetag);
		do m = 1 to 2;
			q3mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			q3Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			q3mbetag[2*m, 1]       = mbetag[4*m-1, 1];
			q3Dbetag[2*m, 2*m]     = Dbetag[4*m-1, 4*m-1];
		end;
		call transpose(q3X, q3Xt);					/* transpose qX */
		call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */

		/***********************************************/
		/* indep quad-linear with no intercepts: q = 3 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then q2X[i, 2*m] = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 1 to 2;
			q2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			q2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				q2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 4*m-2];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[4*m-2, 1];
			q1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/***********************************************/
		/* common cubic-quad with no intercepts: q = 5 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b5X[i, 3*m-2] = X[i, 4*m-2];
				b5X[i, 3*m-1] = X[i, 4*m-1];
				if m=1 then b5X[i, 3*m] = X[i, 4*m];
			end;
		end;
		call zeromatrix(b5Dbetag);
		do m = 1 to 2;
			b5mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b5Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			b5mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			b5Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			if m=1 then do;
				b5mbetag[3*m, 1]   = mbetag[4*m, 1];
				b5Dbetag[3*m, 3*m] = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(b5X, b5Xt);					/* transpose bX */
		call mult(b5Dbetag, b5mbetag, b5prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb5XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb5zbeta);	

		/*************************************************/
		/* common cubic-linear with no intercepts: q = 4 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					b4X[i, 3*m-1] = X[i, 4*m-1];
					b4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(b4Dbetag);
		do m = 1 to 2;
			b4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				b4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				b4mbetag[3*m, 1]   	   = mbetag[4*m, 1];
				b4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(b4X, b4Xt);					/* transpose bX */
		call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb4zbeta);	

		/**********************************************/
		/* common quad-quad with no intercepts: q = 4 */
		/**********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b3X[i, 2*m-1] = X[i, 4*m-2];
				b3X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(b3Dbetag);
		do m = 1 to 2;
			b3mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			b3Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			b3mbetag[2*m, 1]       = mbetag[4*m-1, 1];
			b3Dbetag[2*m, 2*m]     = Dbetag[4*m-1, 4*m-1];
		end;
		call transpose(b3X, b3Xt);					/* transpose bX */
		call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb3zbeta);	

		/************************************************/
		/* common quad-linear with no intercepts: q = 3 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then b2X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(b2Dbetag);
		do m = 1 to 2;
			b2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			b2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				b2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
		  	do m = 1 to 2;
				b1X[i, m] = X[i, 4*m-2];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[4*m-2, 1];
		    b1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/

		pwts[11] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific cubic-quad trend model */
		call transpose(q5mbetag, q5tmbetag);
		call mult(q5tmbetag, q5prbeta, q5exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q5exp[1,1];			/* log scale */
		call det(q5Dbetag, q5wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q5wts);			/* log scale */

		pwts[2] = 0;									/* group-specific cubic-linear trend model */
		call transpose(q4mbetag, q4tmbetag);
		call mult(q4tmbetag, q4prbeta, q4exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q4exp[1,1];			/* log scale */
		call det(q4Dbetag, q4wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q4wts);			/* log scale */

		pwts[3] = 0;									/* group-specific quad-quad trend model */
		call transpose(q3mbetag, q3tmbetag);
		call mult(q3tmbetag, q3prbeta, q3exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q3exp[1,1];			/* log scale */
		call det(q3Dbetag, q3wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q3wts);			/* log scale */

		pwts[4] = 0;									/* group-specific quad-linear trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[4] = pwts[4] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[4] = pwts[4] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[5] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[5] = pwts[5] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[5] = pwts[5] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/******************************************************************/
			/* group-specific cubic-quad trend model with no intercepts (q=5) */
			/******************************************************************/
			call mult(q5Xt, Wg, q5XtW);					/* multiply Xt and Wg */
			call mult(q5XtW, q5X, q5XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q5Dbetag, q5XtWX, q5DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q5XtW, Zvec, q5zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q5prbeta, q5zbeta, q5pbeta);	/* sum of prior and WLS contributions */
			call transpose(q5pbeta, q5tpbeta);			/* transpose */
			call inv(q5DXtWX, q5CI);					/* inverse of posterior precision matrix */
			call mult(q5CI, q5pbeta, q5pbeta);			/* re-scale pbeta */
			call mult(q5tpbeta, q5pbeta, q5exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q5exp[1,1];			/* log scale */
			call det(q5DXtWX, q5wts);
			pwts[1] = pwts[1] - 0.5*log(q5wts); 		/* determinant for normalizing constant */

			/********************************************************************/
			/* group-specific cubic-linear trend model with no intercepts (q=4) */
			/********************************************************************/
			call mult(q4Xt, Wg, q4XtW);					/* multiply Xt and Wg */
			call mult(q4XtW, q4X, q4XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q4Dbetag, q4XtWX, q4DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q4XtW, Zvec, q4zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q4prbeta, q4zbeta, q4pbeta);	/* sum of prior and WLS contributions */
			call transpose(q4pbeta, q4tpbeta);			/* transpose */
			call inv(q4DXtWX, q4CI);					/* inverse of posterior precision matrix */
			call mult(q4CI, q4pbeta, q4pbeta);			/* re-scale pbeta */
			call mult(q4tpbeta, q4pbeta, q4exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q4exp[1,1];			/* log scale */
			call det(q4DXtWX, q4wts);
			pwts[2] = pwts[2] - 0.5*log(q4wts); 		/* determinant for normalizing constant */

			/*****************************************************************/
			/* group-specific quad-quad trend model with no intercepts (q=4) */
			/*****************************************************************/
			call mult(q3Xt, Wg, q3XtW);					/* multiply Xt and Wg */
			call mult(q3XtW, q3X, q3XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q3Dbetag, q3XtWX, q3DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q3XtW, Zvec, q3zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q3prbeta, q3zbeta, q3pbeta);	/* sum of prior and WLS contributions */
			call transpose(q3pbeta, q3tpbeta);			/* transpose */
			call inv(q3DXtWX, q3CI);					/* inverse of posterior precision matrix */
			call mult(q3CI, q3pbeta, q3pbeta);			/* re-scale pbeta */
			call mult(q3tpbeta, q3pbeta, q3exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q3exp[1,1];			/* log scale */
			call det(q3DXtWX, q3wts);
			pwts[3] = pwts[3] - 0.5*log(q3wts); 		/* determinant for normalizing constant */

			/*******************************************************************/
			/* group-specific quad-linear trend model with no intercepts (q=3) */
			/*******************************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[4] = pwts[4] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[4] = pwts[4] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*********************************************************************/
			/* group-specific linear-linear trend model with no intercepts (q=2) */
			/*********************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[5] = pwts[5] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[5] = pwts[5] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[6] = 0;									/* common cubic-quad trend model */
		call transpose(b5mbetag, b5tmbetag);
		call mult(b5tmbetag, b5prbeta, b5exp);			/* exponent from normal pdf */
		pwts[6] = pwts[6] - 0.5*b5exp[1,1];				/* log scale */
		call det(b5Dbetag, b5wts);						/* determinant of prior precision matrix */
		pwts[6] = pwts[6] + 0.5*log(b5wts);				/* log scale */		

		pwts[7] = 0;									/* common cubic-linear trend model */
		call transpose(b4mbetag, b4tmbetag);
		call mult(b4tmbetag, b4prbeta, b4exp);			/* exponent from normal pdf */
		pwts[7] = pwts[7] - 0.5*b4exp[1,1];				/* log scale */
		call det(b4Dbetag, b4wts);						/* determinant of prior precision matrix */
		pwts[7] = pwts[7] + 0.5*log(b4wts);				/* log scale */		

		pwts[8] = 0;									/* common quad-quad trend model */
		call transpose(b3mbetag, b3tmbetag);
		call mult(b3tmbetag, b3prbeta, b3exp);			/* exponent from normal pdf */
		pwts[8] = pwts[8] - 0.5*b3exp[1,1];				/* log scale */
		call det(b3Dbetag, b3wts);						/* determinant of prior precision matrix */
		pwts[8] = pwts[8] + 0.5*log(b3wts);				/* log scale */		

		pwts[9] = 0;									/* common quad-linear trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[9] = pwts[9] - 0.5*b2exp[1,1];				/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[9] = pwts[9] + 0.5*log(b2wts);				/* log scale */		

		pwts[10] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[10] = pwts[10] - 0.5*b1exp[1,1];			/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[10] = pwts[10] + 0.5*log(b1wts);			/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-colum matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/*****************************************************/
			/* common cubic-quad trend model with no intercepts */
			/*****************************************************/
		    call mult(b5Xt, Wg, b5XtW);						/* multiply bXt and Wg */
		    call mult(b5XtW, b5X, b5XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb5XtWX, b5XtWX, sumb5XtWX);	/* cumulative matrix sum */
		    call mult(b5XtW, Zvec, b5zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb5zbeta,b5zbeta,sumb5zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common cubic-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b4Xt, Wg, b4XtW);						/* multiply bXt and Wg */
		    call mult(b4XtW, b4X, b4XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
		    call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);	/* cumulative matrix sum */

			/***************************************************/
			/* common quad-quad trend model with no intercepts */
			/***************************************************/
		    call mult(b3Xt, Wg, b3XtW);						/* multiply bXt and Wg */
		    call mult(b3XtW, b3X, b3XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
		    call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common quad-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/****************************************************/
		/* common cubic-quad trend model with no intercepts */
		/****************************************************/
		call addmatrix(b5Dbetag, sumb5XtWX, b5DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b5prbeta, sumb5zbeta, b5pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b5pbeta, b5tpbeta);					/* transpose */
		call inv(b5DXtWX, b5CI);							/* inverse of posterior precision matrix  */
		call mult(b5CI, b5pbeta, b5pbeta);					/* re-scale pbeta */
		call mult(b5tpbeta, b5pbeta, b5exp);				/* exponent from normal pdf */
		pwts[6] = pwts[6] + 0.5*b5exp[1,1];					/* log scale */
		call det(b5DXtWX, b5wts);
		pwts[6] = pwts[6] - 0.5*log(b5wts); 				/* determinant for normalizing constant */

		/******************************************************/
		/* common cubic-linear trend model with no intercepts */
		/******************************************************/
		call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b4pbeta, b4tpbeta);					/* transpose */
		call inv(b4DXtWX, b4CI);							/* inverse of posterior precision matrix  */
		call mult(b4CI, b4pbeta, b4pbeta);					/* re-scale pbeta */
		call mult(b4tpbeta, b4pbeta, b4exp);				/* exponent from normal pdf */
		pwts[7] = pwts[7] + 0.5*b4exp[1,1];					/* log scale */
		call det(b4DXtWX, b4wts);
		pwts[7] = pwts[7] - 0.5*log(b4wts); 				/* determinant for normalizing constant */

		/***************************************************/
		/* common quad-quad trend model with no intercepts */
		/***************************************************/
		call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b3pbeta, b3tpbeta);					/* transpose */
		call inv(b3DXtWX, b3CI);							/* inverse of posterior precision matrix  */
		call mult(b3CI, b3pbeta, b3pbeta);					/* re-scale pbeta */
		call mult(b3tpbeta, b3pbeta, b3exp);				/* exponent from normal pdf */
		pwts[8] = pwts[8] + 0.5*b3exp[1,1];					/* log scale */
		call det(b3DXtWX, b3wts);
		pwts[8] = pwts[8] - 0.5*log(b3wts); 				/* determinant for normalizing constant */

		/*****************************************************/
		/* common quad-linear trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[9] = pwts[9] + 0.5*b2exp[1,1];					/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[9] = pwts[9] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[10] = pwts[10] + 0.5*b1exp[1,1];				/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[10] = pwts[10] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 11 here */
		iflg = rand('table',qwts[1],qwts[2],qwts[3],qwts[4],qwts[5],qwts[6],qwts[7],qwts[8],qwts[9],qwts[10],qwts[11]);

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 12;
			else do;
				if iflg = 3 then flg = 21;
				else do;
					if iflg = 4 then flg = 22;
					else do;
						if iflg = 5 then flg = 32;
						else do;
							if iflg = 6 then flg = 43;
							else do;
								if iflg = 7 then flg = 44;
								else do;
									if iflg = 8 then flg = 53;
									else do;
										if iflg = 9 then flg = 54;
										else do;
											if iflg = 10 then flg = 64;
											else do;
												if iflg = 11 then flg = 75;
											end;
										end;
									end;
								end;
							end;
						end;
					end;
				end;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);

		endsub;
	run;
	quit;

%end;

%if %upcase(&uvar) = BMA_CUBIC and %upcase(&s2uvar) = BMA_CUBIC %then %do;
	/***************************************************************************/
	/* eMKF: Gibbs sampler for model flags in the BMA cubic-cubic trend model  */
	/***************************************************************************/
	proc fcmp outlib=&uloc; 			

		subroutine FP_xptf_bmac_bmac(
						   iflg,				/* internal flag for cubic-cubic case, with values 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 */
						   flg,					/* model flag for cubic-cubic case, with values 11, 12, 13, 22, 23, 33, 44, 45, 46, 55, 56, 66, 77 */
						   s1flg,
						   s2flg,
						   wts[*],				/* 1-dimensional array (length fp) of prior model probabilities */
						   s1ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 1 */
						   s2ag[*],				/* 1-dimensional array of intercepts to subtract off from y's for segment 2 */
						   mbetag[*,*], 		/* prior mean vector (p x 1) for regression coefficients */
						   Dbetag[*,*], 		/* diagonal matrix (p x p) of prior precisions for regression coefficients */
						   rhoarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances rho */
						   nuarr[*],			/* 1-dimensional array (length g) of current values of group-specific AR variances nu */
						   rts[*],				/* 1-dimensional array (length n) of real times */
						   X[*,*], 				/* design matrix (n x p) using real times */
						   Yarr[*], 			/* 1-dimensional array (length gn) for _y from dataset */
						   Sarr[*]				/* 1-dimensional array (length gn) for _var from dataset */
						   );

		outargs flg, s1flg, s2flg, iflg;				/* arguments that are updated after execution */

		/****************************/
		/* General array structures */
		/****************************/
		array pwts[&fp]							/nosym; /* holds posterior weights for model flags */
		array qwts[&fp]							/nosym; /* holds posterior weights for model flags */

		array Zvec[&n, 1]		 				/nosym;	/* de-trended group-specific observations */
		array Vg[&n, &n]  						/nosym;	/* Vgamma + sampling variances */
		array Wg[&n, &n]   						/nosym;	/* (Vgamma + sampling variances)^{-1} */

		array aX[&n, 2]							/nosym; /* eMKF v2.4: 2-dimensional conformal design submatrix X */
		array aXbeta[&n, 1]						/nosym;	/* holds matrix multiplication */
		array abeta[2, 1] 						/nosym;	/* eMKF v2.4: vector (2x1) of intercepts */

		/*******************************************/
		/* Array structures for indep trend models */
		/*******************************************/
		array q1X[&n, 2]						/nosym; /* 2-column version of the design matrix X [linear-linear] */
		array q2X[&n, 3]						/nosym; /* 3-column version of the design matrix X [quad-linear] */
		array q3X[&n, 4]						/nosym; /* 4-column version of the design matrix X [quad-quad] */
		array q4X[&n, 4]						/nosym; /* 4-column version of the design matrix X [cubic-linear] */
		array q5X[&n, 5]						/nosym; /* 5-column version of the design matrix X [cubic-quad] */
		array q6X[&n, 6]						/nosym; /* 6-column version of the design matrix X [cubic-cubic] */

		array q1mbetag[2, 1]					/nosym; /* 2-dimensional version of mbetag */
		array q2mbetag[3, 1]					/nosym; /* 3-dimensional version of mbetag */
		array q3mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q4mbetag[4, 1]					/nosym; /* 4-dimensional version of mbetag */
		array q5mbetag[5, 1]					/nosym; /* 5-dimensional version of mbetag */
		array q6mbetag[6, 1]					/nosym; /* 6-dimensional version of mbetag */

		array q1tmbetag[1, 2]					/nosym; /* transpose */
		array q2tmbetag[1, 3]					/nosym; /* transpose */
		array q3tmbetag[1, 4]					/nosym; /* transpose */
		array q4tmbetag[1, 4]					/nosym; /* transpose */
		array q5tmbetag[1, 5]					/nosym; /* transpose */
		array q6tmbetag[1, 6]					/nosym; /* transpose */

		array q1Dbetag[2, 2]					/nosym; /* 2-dimensional version of Dbetag */
		array q2Dbetag[3, 3]					/nosym; /* 3-dimensional version of Dbetag */
		array q3Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q4Dbetag[4, 4]					/nosym; /* 4-dimensional version of Dbetag */
		array q5Dbetag[5, 5]					/nosym; /* 5-dimensional version of Dbetag */
		array q6Dbetag[6, 6]					/nosym; /* 6-dimensional version of Dbetag */

		array q1Xt[2, &n]   					/nosym;	/* transpose of design matrix */
		array q2Xt[3, &n]   					/nosym;	/* transpose of design matrix */
		array q3Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q4Xt[4, &n]   					/nosym;	/* transpose of design matrix */
		array q5Xt[5, &n]   					/nosym;	/* transpose of design matrix */
		array q6Xt[6, &n]   					/nosym;	/* transpose of design matrix */

		array q1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg */
		array q6XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg */

		array q1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators */
		array q2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators */
		array q3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators */
		array q5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators */
		array q6XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators */

		array q1DXtWX[2, 2]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q2DXtWX[3, 3]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q3DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q4DXtWX[4, 4]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q5DXtWX[5, 5]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */
		array q6DXtWX[6, 6]						/nosym; /* Dbetag + XtWX = posterior precision matrix for beta */

		array q1prbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from prior */
		array q2prbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from prior */
		array q3prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q4prbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from prior */
		array q5prbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from prior */
		array q6prbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from prior */

		array q1pbeta[2, 1] 	    			/nosym;	/* vector (2 x 1) of regression estimates from pooled posterior */
		array q2pbeta[3, 1] 	    			/nosym;	/* vector (3 x 1) of regression estimates from pooled posterior */
		array q3pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q4pbeta[4, 1] 	    			/nosym;	/* vector (4 x 1) of regression estimates from pooled posterior */
		array q5pbeta[5, 1] 	    			/nosym;	/* vector (5 x 1) of regression estimates from pooled posterior */
		array q6pbeta[6, 1] 	    			/nosym;	/* vector (6 x 1) of regression estimates from pooled posterior */

		array q1tpbeta[1, 2] 	    			/nosym;	/* transpose */
		array q2tpbeta[1, 3] 	    			/nosym;	/* transpose */
		array q3tpbeta[1, 4] 	    			/nosym;	/* transpose */
		array q4tpbeta[1, 4] 	    			/nosym;	/* transpose */
		array q5tpbeta[1, 5] 	    			/nosym;	/* transpose */
		array q6tpbeta[1, 6] 	    			/nosym;	/* transpose */

		array q1zbeta[2, 1] 	       			/nosym;	/* vector (2 x 1) of regression estimates from WLS */
		array q2zbeta[3, 1] 	       			/nosym;	/* vector (3 x 1) of regression estimates from WLS */
		array q3zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q4zbeta[4, 1] 	       			/nosym;	/* vector (4 x 1) of regression estimates from WLS */
		array q5zbeta[5, 1] 	       			/nosym;	/* vector (5 x 1) of regression estimates from WLS */
		array q6zbeta[6, 1] 	       			/nosym;	/* vector (6 x 1) of regression estimates from WLS */

		array q1CI[2, 2] 					  	/nosym;	/* inverse */
		array q2CI[3, 3] 					  	/nosym;	/* inverse */
		array q3CI[4, 4] 					  	/nosym;	/* inverse */
		array q4CI[4, 4] 					  	/nosym;	/* inverse */
		array q5CI[5, 5] 					  	/nosym;	/* inverse */
		array q6CI[6, 6] 					  	/nosym;	/* inverse */

		array q1exp[1, 1]						/nosym; /* holds quadratic form */
		array q2exp[1, 1]						/nosym; /* holds quadratic form */
		array q3exp[1, 1]						/nosym; /* holds quadratic form */
		array q4exp[1, 1]						/nosym; /* holds quadratic form */
		array q5exp[1, 1]						/nosym; /* holds quadratic form */
		array q6exp[1, 1]						/nosym; /* holds quadratic form */

		/********************************************/
		/* Array structures for common trend models */
		/********************************************/
		array b1mbetag[2, 1] 					/nosym;	/* prior mean vector (2 x 1) for coefficients (excl. intercept) */
		array b2mbetag[3, 1] 					/nosym;	/* prior mean vector (3 x 1) for coefficients (excl. intercept) */
		array b3mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) */
		array b4mbetag[4, 1] 					/nosym;	/* prior mean vector (4 x 1) for coefficients (excl. intercept) */
		array b5mbetag[5, 1] 					/nosym;	/* prior mean vector (5 x 1) for coefficients (excl. intercept) */
		array b6mbetag[6, 1] 					/nosym;	/* prior mean vector (6 x 1) for coefficients (excl. intercept) */

		array b1tmbetag[1, 2] 					/nosym;	/* transpose */
		array b2tmbetag[1, 3] 					/nosym;	/* transpose */
		array b3tmbetag[1, 4] 					/nosym;	/* transpose */
		array b4tmbetag[1, 4] 					/nosym;	/* transpose */
		array b5tmbetag[1, 5] 					/nosym;	/* transpose */
		array b6tmbetag[1, 6] 					/nosym;	/* transpose */

		array b1Dbetag[2, 2] 					/nosym;	/* diagonal matrix (2 x 2) of prior precisions for coefficients (excl. intercept) */
		array b2Dbetag[3, 3] 					/nosym;	/* diagonal matrix (3 x 3) of prior precisions for coefficients (excl. intercept) */
		array b3Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */
		array b4Dbetag[4, 4] 					/nosym;	/* diagonal matrix (4 x 4) of prior precisions for coefficients (excl. intercept) */
		array b5Dbetag[5, 5] 					/nosym;	/* diagonal matrix (5 x 5) of prior precisions for coefficients (excl. intercept) */
		array b6Dbetag[6, 6] 					/nosym;	/* diagonal matrix (6 x 6) of prior precisions for coefficients (excl. intercept) */

		array b1X[&n, 2]						/nosym; /* 2-dimensional conformal design submatrix X */
		array b2X[&n, 3]						/nosym; /* 3-dimensional conformal design submatrix X */
		array b3X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b4X[&n, 4]						/nosym; /* 4-dimensional conformal design submatrix X */
		array b5X[&n, 5]						/nosym; /* 5-dimensional conformal design submatrix X */
		array b6X[&n, 6]						/nosym; /* 6-dimensional conformal design submatrix X */

		array sumb1XtWX[2, 2] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb2XtWX[3, 3] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb3XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb4XtWX[4, 4] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb5XtWX[5, 5] 					/nosym;	/* cumulative sum of group-specific precision matrices */
		array sumb6XtWX[6, 6] 					/nosym;	/* cumulative sum of group-specific precision matrices */

		array sumb1zbeta[2, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb2zbeta[3, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb3zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb4zbeta[4, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb5zbeta[5, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */
		array sumb6zbeta[6, 1] 	    			/nosym;	/* cumulative sum of group-specific vector of regression estimates */

		array b1Xt[2, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b2Xt[3, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b3Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b4Xt[4, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b5Xt[5, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */
		array b6Xt[6, &n] 						/nosym; /* transpose of design matrix (excl. intercept) */

		array b1XtW[2, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b2XtW[3, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b3XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b4XtW[4, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b5XtW[5, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */
		array b6XtW[6, &n]						/nosym; /* matrix multiplication of Xt and Wg (excl. intercept) */

	 	array b1XtWX[2, 2] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b2XtWX[3, 3] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b3XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b4XtWX[4, 4] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b5XtWX[5, 5] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */
	 	array b6XtWX[6, 6] 						/nosym; /* precision matrix of WLS regression estimators (excl. intercept) */

		array b1DXtWX[2, 2]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b2DXtWX[3, 3]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b3DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b4DXtWX[4, 4]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b5DXtWX[5, 5]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */
		array b6DXtWX[6, 6]  					/nosym;	/* Dbetag + XtWX = posterior precision matrix for beta (excl. intercept) */

		array b1prbeta[2, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b2prbeta[3, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b3prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b4prbeta[4, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b5prbeta[5, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */
		array b6prbeta[6, 1]            		/nosym; /* vector of regression estimates (excl. intercept) from prior */

		array b1pbeta[2, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b2pbeta[3, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b3pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b4pbeta[4, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b5pbeta[5, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */
		array b6pbeta[6, 1]            			/nosym; /* vector of regression estimates (excl. intercept) from pooled posterior */

		array b1tpbeta[1, 2]            		/nosym; /* transpose */
		array b2tpbeta[1, 3]            		/nosym; /* transpose */
		array b3tpbeta[1, 4]            		/nosym; /* transpose */
		array b4tpbeta[1, 4]            		/nosym; /* transpose */
		array b5tpbeta[1, 5]            		/nosym; /* transpose */
		array b6tpbeta[1, 6]            		/nosym; /* transpose */

		array b1zbeta[2, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b2zbeta[3, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b3zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b4zbeta[4, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b5zbeta[5, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */
		array b6zbeta[6, 1]	 					/nosym;	/* vector of regression estimates (excl. intercepts) from WLS */

		array b1CI[2, 2]     					/nosym; /* inverse */
		array b2CI[3, 3]     					/nosym; /* inverse */
		array b3CI[4, 4]     					/nosym; /* inverse */
		array b4CI[4, 4]     					/nosym; /* inverse */
		array b5CI[5, 5]     					/nosym; /* inverse */
		array b6CI[6, 6]     					/nosym; /* inverse */

		array b1exp[1,1]						/nosym; /* holds quadratic form */
		array b2exp[1,1]						/nosym; /* holds quadratic form */
		array b3exp[1,1]						/nosym; /* holds quadratic form */
		array b4exp[1,1]						/nosym; /* holds quadratic form */
		array b5exp[1,1]						/nosym; /* holds quadratic form */
		array b6exp[1,1]						/nosym; /* holds quadratic form */

		/*******************************************************************/
		/* Populate required array structures for each possible model flag */	
		/*******************************************************************/

		do i = 1 to &n;
			do m = 1 to 2;
		  		aX[i, m] = X[i, 4*m-3];				/* intercepts */
			end;
		end;

		/***********************************************/
		/* indep cubic-cubic with no intercepts: q = 6 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q6X[i, 3*m-2] = X[i, 4*m-2];
				q6X[i, 3*m-1] = X[i, 4*m-1];
				q6X[i, 3*m]   = X[i, 4*m];
			end;
		end;
		call zeromatrix(q6Dbetag);
		do m = 1 to 2;
			q6mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q6Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			q6mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			q6Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			q6mbetag[3*m, 1]       = mbetag[4*m, 1];
			q6Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
		end;
		call transpose(q6X, q6Xt);					/* transpose qX */
		call mult(q6Dbetag, q6mbetag, q6prbeta);	/* contribution to posterior mean from prior */

		/**********************************************/
		/* indep cubic-quad with no intercepts: q = 5 */
		/**********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q5X[i, 3*m-2] = X[i, 4*m-2];
				q5X[i, 3*m-1] = X[i, 4*m-1];
				if m=1 then q5X[i, 3*m] = X[i, 4*m];
			end;
		end;
		call zeromatrix(q5Dbetag);
		do m = 1 to 2;
			q5mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q5Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			q5mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			q5Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			if m=1 then do;
				q5mbetag[3*m, 1]   = mbetag[4*m, 1];
				q5Dbetag[3*m, 3*m] = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(q5X, q5Xt);					/* transpose qX */
		call mult(q5Dbetag, q5mbetag, q5prbeta);	/* contribution to posterior mean from prior */

		/************************************************/
		/* indep cubic-linear with no intercepts: q = 4 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					q4X[i, 3*m-1] = X[i, 4*m-1];
					q4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(q4Dbetag);
		do m = 1 to 2;
			q4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			q4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				q4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				q4mbetag[3*m, 1]       = mbetag[4*m, 1];
				q4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(q4X, q4Xt);					/* transpose qX */
		call mult(q4Dbetag, q4mbetag, q4prbeta);	/* contribution to posterior mean from prior */

		/*********************************************/
		/* indep quad-quad with no intercepts: q = 4 */
		/*********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q3X[i, 2*m-1] = X[i, 4*m-2];
				q3X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(q3Dbetag);
		do m = 1 to 2;
			q3mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			q3Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			q3mbetag[2*m, 1]       = mbetag[4*m-1, 1];
			q3Dbetag[2*m, 2*m]     = Dbetag[4*m-1, 4*m-1];
		end;
		call transpose(q3X, q3Xt);					/* transpose qX */
		call mult(q3Dbetag, q3mbetag, q3prbeta);	/* contribution to posterior mean from prior */

		/***********************************************/
		/* indep quad-linear with no intercepts: q = 3 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then q2X[i, 2*m] = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(q2Dbetag);
		do m = 1 to 2;
			q2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			q2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				q2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				q2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(q2X, q2Xt);					/* transpose qX */
		call mult(q2Dbetag, q2mbetag, q2prbeta);	/* contribution to posterior mean from prior */

		/*************************************************/
		/* indep linear-linear with no intercepts: q = 2 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				q1X[i, m] = X[i, 4*m-2];
			end;
		end;
		call zeromatrix(q1Dbetag);
		do m = 1 to 2;
			q1mbetag[m, 1] = mbetag[4*m-2, 1];
			q1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];
		end;
		call transpose(q1X, q1Xt);					/* transpose qX */
		call mult(q1Dbetag, q1mbetag, q1prbeta);	/* contribution to posterior mean from prior */

		/************************************************/
		/* common cubic-cubic with no intercepts: q = 6 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b6X[i, 3*m-2] = X[i, 4*m-2];
				b6X[i, 3*m-1] = X[i, 4*m-1];
				b6X[i, 3*m]   = X[i, 4*m];
			end;
		end;
		call zeromatrix(b6Dbetag);
		do m = 1 to 2;
			b6mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b6Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			b6mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			b6Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			b6mbetag[3*m, 1]       = mbetag[4*m, 1];
			b6Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
		end;
		call transpose(b6X, b6Xt);					/* transpose bX */
		call mult(b6Dbetag, b6mbetag, b6prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb6XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb6zbeta);	

		/***********************************************/
		/* common cubic-quad with no intercepts: q = 5 */
		/***********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b5X[i, 3*m-2] = X[i, 4*m-2];
				b5X[i, 3*m-1] = X[i, 4*m-1];
				if m=1 then b5X[i, 3*m] = X[i, 4*m];
			end;
		end;
		call zeromatrix(b5Dbetag);
		do m = 1 to 2;
			b5mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b5Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			b5mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
			b5Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
			if m=1 then do;
				b5mbetag[3*m, 1]   = mbetag[4*m, 1];
				b5Dbetag[3*m, 3*m] = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(b5X, b5Xt);					/* transpose bX */
		call mult(b5Dbetag, b5mbetag, b5prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb5XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb5zbeta);	

		/*************************************************/
		/* common cubic-linear with no intercepts: q = 4 */
		/*************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b4X[i, 3*m-2] = X[i, 4*m-2];
				if m=1 then do;
					b4X[i, 3*m-1] = X[i, 4*m-1];
					b4X[i, 3*m]   = X[i, 4*m];
				end;
			end;
		end;
		call zeromatrix(b4Dbetag);
		do m = 1 to 2;
			b4mbetag[3*m-2, 1]     = mbetag[4*m-2, 1];
			b4Dbetag[3*m-2, 3*m-2] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b4mbetag[3*m-1, 1]     = mbetag[4*m-1, 1];
				b4Dbetag[3*m-1, 3*m-1] = Dbetag[4*m-1, 4*m-1];
				b4mbetag[3*m, 1]   	   = mbetag[4*m, 1];
				b4Dbetag[3*m, 3*m]     = Dbetag[4*m, 4*m];
			end;
		end;
		call transpose(b4X, b4Xt);					/* transpose bX */
		call mult(b4Dbetag, b4mbetag, b4prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb4XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb4zbeta);	

		/**********************************************/
		/* common quad-quad with no intercepts: q = 4 */
		/**********************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b3X[i, 2*m-1] = X[i, 4*m-2];
				b3X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(b3Dbetag);
		do m = 1 to 2;
			b3mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			b3Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			b3mbetag[2*m, 1]       = mbetag[4*m-1, 1];
			b3Dbetag[2*m, 2*m]     = Dbetag[4*m-1, 4*m-1];
		end;
		call transpose(b3X, b3Xt);					/* transpose bX */
		call mult(b3Dbetag, b3mbetag, b3prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb3XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb3zbeta);	

		/************************************************/
		/* common quad-linear with no intercepts: q = 3 */
		/************************************************/
		do i = 1 to &n;
			do m = 1 to 2;
				b2X[i, 2*m-1] = X[i, 4*m-2];
				if m=1 then b2X[i, 2*m]   = X[i, 4*m-1];
			end;
		end;
		call zeromatrix(b2Dbetag);
		do m = 1 to 2;
			b2mbetag[2*m-1, 1]     = mbetag[4*m-2, 1];
			b2Dbetag[2*m-1, 2*m-1] = Dbetag[4*m-2, 4*m-2];
			if m=1 then do;
				b2mbetag[2*m, 1]   = mbetag[4*m-1, 1];
				b2Dbetag[2*m, 2*m] = Dbetag[4*m-1, 4*m-1];
			end;
		end;
		call transpose(b2X, b2Xt);					/* transpose bX */
		call mult(b2Dbetag, b2mbetag, b2prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb2XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb2zbeta);	

		/**************************************************/
		/* common linear-linear with no intercepts: q = 2 */
		/**************************************************/
		do i = 1 to &n;								
		  	do m = 1 to 2;
				b1X[i, m] = X[i, 4*m-2];
		  	end;
	  	end;
		call zeromatrix(b1Dbetag); 
		do m = 1 to 2;
			b1mbetag[m, 1] = mbetag[4*m-2, 1];
		    b1Dbetag[m, m] = Dbetag[4*m-2, 4*m-2];	
		end;
		call transpose(b1X, b1Xt);					/* transpose bX */
		call mult(b1Dbetag, b1mbetag, b1prbeta);	/* contribution to posterior mean from prior */
		call zeromatrix(sumb1XtWX);					/* initialize applicable cumulative sums to all zeroes */
		call zeromatrix(sumb1zbeta);	

		/**************************************************/
		/* Group-specific trend models with no intercepts */
		/**************************************************/

		pwts[13] = 0;									/* no contribution from marginal for dropped-dropped model */

		pwts[1] = 0;									/* group-specific cubic-cubic trend model */
		call transpose(q6mbetag, q6tmbetag);
		call mult(q6tmbetag, q6prbeta, q6exp);			/* exponent from normal pdf features &g times */
		pwts[1] = pwts[1] - 0.5*&g*q6exp[1,1];			/* log scale */
		call det(q6Dbetag, q6wts);						/* determinant of prior precision matrix features &g times */
		pwts[1] = pwts[1] + 0.5*&g*log(q6wts);			/* log scale */

		pwts[2] = 0;									/* group-specific cubic-quad trend model */
		call transpose(q5mbetag, q5tmbetag);
		call mult(q5tmbetag, q5prbeta, q5exp);			/* exponent from normal pdf features &g times */
		pwts[2] = pwts[2] - 0.5*&g*q5exp[1,1];			/* log scale */
		call det(q5Dbetag, q5wts);						/* determinant of prior precision matrix features &g times */
		pwts[2] = pwts[2] + 0.5*&g*log(q5wts);			/* log scale */

		pwts[3] = 0;									/* group-specific cubic-linear trend model */
		call transpose(q4mbetag, q4tmbetag);
		call mult(q4tmbetag, q4prbeta, q4exp);			/* exponent from normal pdf features &g times */
		pwts[3] = pwts[3] - 0.5*&g*q4exp[1,1];			/* log scale */
		call det(q4Dbetag, q4wts);						/* determinant of prior precision matrix features &g times */
		pwts[3] = pwts[3] + 0.5*&g*log(q4wts);			/* log scale */

		pwts[4] = 0;									/* group-specific quad-quad trend model */
		call transpose(q3mbetag, q3tmbetag);
		call mult(q3tmbetag, q3prbeta, q3exp);			/* exponent from normal pdf features &g times */
		pwts[4] = pwts[4] - 0.5*&g*q3exp[1,1];			/* log scale */
		call det(q3Dbetag, q3wts);						/* determinant of prior precision matrix features &g times */
		pwts[4] = pwts[4] + 0.5*&g*log(q3wts);			/* log scale */

		pwts[5] = 0;									/* group-specific quad-linear trend model */
		call transpose(q2mbetag, q2tmbetag);
		call mult(q2tmbetag, q2prbeta, q2exp);			/* exponent from normal pdf features &g times */
		pwts[5] = pwts[5] - 0.5*&g*q2exp[1,1];			/* log scale */
		call det(q2Dbetag, q2wts);						/* determinant of prior precision matrix features &g times */
		pwts[5] = pwts[5] + 0.5*&g*log(q2wts);			/* log scale */

		pwts[6] = 0;									/* group-specific linear-linear trend model */
		call transpose(q1mbetag, q1tmbetag);
		call mult(q1tmbetag, q1prbeta, q1exp);			/* exponent from normal pdf features &g times */
		pwts[6] = pwts[6] - 0.5*&g*q1exp[1,1];			/* log scale */
		call det(q1Dbetag, q1wts);						/* determinant of prior precision matrix features &g times */
		pwts[6] = pwts[6] + 0.5*&g*log(q1wts);			/* log scale */
	
		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-column matrix of intercepts s1a s2a */
		    do i = 1 to &n;								
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i]= nuarr[k]+Sarr[(k-1)*&n+i]; 		/* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;							/* off-diagonal elements are those of AR matrix Vgamma */
			    do j = i+1 to &n;
				    Vg[i,j] = (rhoarr[k]**(rts[j]-rts[i]))*nuarr[k];
				    Vg[j,i] = Vg[i,j];
			    end; 
		  	end; 
			call inv(Vg, Wg);							/* Wg = Vg^{-1} */

			/*******************************************************************/
			/* group-specific cubic-cubic trend model with no intercepts (q=6) */
			/*******************************************************************/
			call mult(q6Xt, Wg, q6XtW);					/* multiply Xt and Wg */
			call mult(q6XtW, q6X, q6XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q6Dbetag, q6XtWX, q6DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q6XtW, Zvec, q6zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q6prbeta, q6zbeta, q6pbeta);	/* sum of prior and WLS contributions */
			call transpose(q6pbeta, q6tpbeta);			/* transpose */
			call inv(q6DXtWX, q6CI);					/* inverse of posterior precision matrix */
			call mult(q6CI, q6pbeta, q6pbeta);			/* re-scale pbeta */
			call mult(q6tpbeta, q6pbeta, q6exp);		/* exponent from normal pdf */
			pwts[1] = pwts[1] + 0.5*q6exp[1,1];			/* log scale */
			call det(q6DXtWX, q6wts);
			pwts[1] = pwts[1] - 0.5*log(q6wts); 		/* determinant for normalizing constant */

			/******************************************************************/
			/* group-specific cubic-quad trend model with no intercepts (q=5) */
			/******************************************************************/
			call mult(q5Xt, Wg, q5XtW);					/* multiply Xt and Wg */
			call mult(q5XtW, q5X, q5XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q5Dbetag, q5XtWX, q5DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q5XtW, Zvec, q5zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q5prbeta, q5zbeta, q5pbeta);	/* sum of prior and WLS contributions */
			call transpose(q5pbeta, q5tpbeta);			/* transpose */
			call inv(q5DXtWX, q5CI);					/* inverse of posterior precision matrix */
			call mult(q5CI, q5pbeta, q5pbeta);			/* re-scale pbeta */
			call mult(q5tpbeta, q5pbeta, q5exp);		/* exponent from normal pdf */
			pwts[2] = pwts[2] + 0.5*q5exp[1,1];			/* log scale */
			call det(q5DXtWX, q5wts);
			pwts[2] = pwts[2] - 0.5*log(q5wts); 		/* determinant for normalizing constant */

			/********************************************************************/
			/* group-specific cubic-linear trend model with no intercepts (q=4) */
			/********************************************************************/
			call mult(q4Xt, Wg, q4XtW);					/* multiply Xt and Wg */
			call mult(q4XtW, q4X, q4XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q4Dbetag, q4XtWX, q4DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q4XtW, Zvec, q4zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q4prbeta, q4zbeta, q4pbeta);	/* sum of prior and WLS contributions */
			call transpose(q4pbeta, q4tpbeta);			/* transpose */
			call inv(q4DXtWX, q4CI);					/* inverse of posterior precision matrix */
			call mult(q4CI, q4pbeta, q4pbeta);			/* re-scale pbeta */
			call mult(q4tpbeta, q4pbeta, q4exp);		/* exponent from normal pdf */
			pwts[3] = pwts[3] + 0.5*q4exp[1,1];			/* log scale */
			call det(q4DXtWX, q4wts);
			pwts[3] = pwts[3] - 0.5*log(q4wts); 		/* determinant for normalizing constant */

			/*****************************************************************/
			/* group-specific quad-quad trend model with no intercepts (q=4) */
			/*****************************************************************/
			call mult(q3Xt, Wg, q3XtW);					/* multiply Xt and Wg */
			call mult(q3XtW, q3X, q3XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q3Dbetag, q3XtWX, q3DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q3XtW, Zvec, q3zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q3prbeta, q3zbeta, q3pbeta);	/* sum of prior and WLS contributions */
			call transpose(q3pbeta, q3tpbeta);			/* transpose */
			call inv(q3DXtWX, q3CI);					/* inverse of posterior precision matrix */
			call mult(q3CI, q3pbeta, q3pbeta);			/* re-scale pbeta */
			call mult(q3tpbeta, q3pbeta, q3exp);		/* exponent from normal pdf */
			pwts[4] = pwts[4] + 0.5*q3exp[1,1];			/* log scale */
			call det(q3DXtWX, q3wts);
			pwts[4] = pwts[4] - 0.5*log(q3wts); 		/* determinant for normalizing constant */

			/*******************************************************************/
			/* group-specific quad-linear trend model with no intercepts (q=3) */
			/*******************************************************************/
			call mult(q2Xt, Wg, q2XtW);					/* multiply Xt and Wg */
			call mult(q2XtW, q2X, q2XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q2Dbetag, q2XtWX, q2DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q2XtW, Zvec, q2zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q2prbeta, q2zbeta, q2pbeta);	/* sum of prior and WLS contributions */
			call transpose(q2pbeta, q2tpbeta);			/* transpose */
			call inv(q2DXtWX, q2CI);					/* inverse of posterior precision matrix */
			call mult(q2CI, q2pbeta, q2pbeta);			/* re-scale pbeta */
			call mult(q2tpbeta, q2pbeta, q2exp);		/* exponent from normal pdf */
			pwts[5] = pwts[5] + 0.5*q2exp[1,1];			/* log scale */
			call det(q2DXtWX, q2wts);
			pwts[5] = pwts[5] - 0.5*log(q2wts); 		/* determinant for normalizing constant */

			/*********************************************************************/
			/* group-specific linear-linear trend model with no intercepts (q=2) */
			/*********************************************************************/
			call mult(q1Xt, Wg, q1XtW);					/* multiply Xt and Wg */
			call mult(q1XtW, q1X, q1XtWX);				/* calculate XtWX, the precision matrix from WLS */
			call addmatrix(q1Dbetag, q1XtWX, q1DXtWX);	/* posterior precision matrix for beta is qDbetag + XtWX */
			call mult(q1XtW, Zvec, q1zbeta);			/* contribution to posterior mean from WLS */
			call addmatrix(q1prbeta, q1zbeta, q1pbeta);	/* sum of prior and WLS contributions */
			call transpose(q1pbeta, q1tpbeta);			/* transpose */
			call inv(q1DXtWX, q1CI);					/* inverse of posterior precision matrix */
			call mult(q1CI, q1pbeta, q1pbeta);			/* re-scale pbeta */
			call mult(q1tpbeta, q1pbeta, q1exp);		/* exponent from normal pdf */
			pwts[6] = pwts[6] + 0.5*q1exp[1,1];			/* log scale */
			call det(q1DXtWX, q1wts);
			pwts[6] = pwts[6] - 0.5*log(q1wts); 		/* determinant for normalizing constant */

		end;

		/******************************************/
		/* Common trend models with no intercepts */
		/******************************************/

		pwts[7] = 0;									/* common cubic-cubic trend model */
		call transpose(b6mbetag, b6tmbetag);
		call mult(b6tmbetag, b6prbeta, b6exp);			/* exponent from normal pdf */
		pwts[7] = pwts[7] - 0.5*b6exp[1,1];				/* log scale */
		call det(b6Dbetag, b6wts);						/* determinant of prior precision matrix */
		pwts[7] = pwts[7] + 0.5*log(b6wts);				/* log scale */		
	
		pwts[8] = 0;									/* common cubic-quad trend model */
		call transpose(b5mbetag, b5tmbetag);
		call mult(b5tmbetag, b5prbeta, b5exp);			/* exponent from normal pdf */
		pwts[8] = pwts[8] - 0.5*b5exp[1,1];				/* log scale */
		call det(b5Dbetag, b5wts);						/* determinant of prior precision matrix */
		pwts[8] = pwts[8] + 0.5*log(b5wts);				/* log scale */		

		pwts[9] = 0;									/* common cubic-linear trend model */
		call transpose(b4mbetag, b4tmbetag);
		call mult(b4tmbetag, b4prbeta, b4exp);			/* exponent from normal pdf */
		pwts[9] = pwts[9] - 0.5*b4exp[1,1];				/* log scale */
		call det(b4Dbetag, b4wts);						/* determinant of prior precision matrix */
		pwts[9] = pwts[9] + 0.5*log(b4wts);				/* log scale */		

		pwts[10] = 0;									/* common quad-quad trend model */
		call transpose(b3mbetag, b3tmbetag);
		call mult(b3tmbetag, b3prbeta, b3exp);			/* exponent from normal pdf */
		pwts[10] = pwts[10] - 0.5*b3exp[1,1];			/* log scale */
		call det(b3Dbetag, b3wts);						/* determinant of prior precision matrix */
		pwts[10] = pwts[10] + 0.5*log(b3wts);			/* log scale */		

		pwts[11] = 0;									/* common quad-linear trend model */
		call transpose(b2mbetag, b2tmbetag);
		call mult(b2tmbetag, b2prbeta, b2exp);			/* exponent from normal pdf */
		pwts[11] = pwts[11] - 0.5*b2exp[1,1];			/* log scale */
		call det(b2Dbetag, b2wts);						/* determinant of prior precision matrix */
		pwts[11] = pwts[11] + 0.5*log(b2wts);			/* log scale */		

		pwts[12] = 0;									/* common linear-linear trend model */
		call transpose(b1mbetag, b1tmbetag);
		call mult(b1tmbetag, b1prbeta, b1exp);			/* exponent from normal pdf */
		pwts[12] = pwts[12] - 0.5*b1exp[1,1];			/* log scale */
		call det(b1Dbetag, b1wts);						/* determinant of prior precision matrix */
		pwts[12] = pwts[12] + 0.5*log(b1wts);			/* log scale */				

		do k = 1 to &g;									/* cycle through each group independently */

			abeta[1,1] = s1ag[k];						/* group-specific abeta vector */
			abeta[2,1] = s2ag[k];
			call mult(aX, abeta, aXbeta);				/* 2-colum matrix of intercepts s1a s2a */
		    do i = 1 to &n;						
			  Zvec[i,1]=Yarr[(k-1)*&n+i] - aXbeta[i,1]; /* populate nx1 data vector Zvec = Yvec - aX */
			  Vg[i,i] = nuarr[k] + Sarr[(k-1)*&n + i];  /* Vg = sum of Vgamma and the diagonal matrix of sampling variances */
			end; 
			do i = 1 to &n-1;
			  do j = i+1 to &n;
				Vg[i,j] = (rhoarr[k]**(rts[j] - rts[i]))*nuarr[k];
				Vg[j,i] = Vg[i,j];
			  end; 
		  	end; 
			call inv(Vg, Wg);								/* Wg = Vg^{-1} */

			/*****************************************************/
			/* common cubic-cubic trend model with no intercepts */
			/*****************************************************/
		    call mult(b6Xt, Wg, b6XtW);						/* multiply bXt and Wg */
		    call mult(b6XtW, b6X, b6XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb6XtWX, b6XtWX, sumb6XtWX);	/* cumulative matrix sum */
		    call mult(b6XtW, Zvec, b6zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb6zbeta,b6zbeta,sumb6zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common cubic-quad trend model with no intercepts */
			/*****************************************************/
		    call mult(b5Xt, Wg, b5XtW);						/* multiply bXt and Wg */
		    call mult(b5XtW, b5X, b5XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb5XtWX, b5XtWX, sumb5XtWX);	/* cumulative matrix sum */
		    call mult(b5XtW, Zvec, b5zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb5zbeta,b5zbeta,sumb5zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common cubic-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b4Xt, Wg, b4XtW);						/* multiply bXt and Wg */
		    call mult(b4XtW, b4X, b4XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb4XtWX, b4XtWX, sumb4XtWX);	/* cumulative matrix sum */
		    call mult(b4XtW, Zvec, b4zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb4zbeta,b4zbeta,sumb4zbeta);	/* cumulative matrix sum */

			/***************************************************/
			/* common quad-quad trend model with no intercepts */
			/***************************************************/
		    call mult(b3Xt, Wg, b3XtW);						/* multiply bXt and Wg */
		    call mult(b3XtW, b3X, b3XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb3XtWX, b3XtWX, sumb3XtWX);	/* cumulative matrix sum */
		    call mult(b3XtW, Zvec, b3zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb3zbeta,b3zbeta,sumb3zbeta);	/* cumulative matrix sum */

			/*****************************************************/
			/* common quad-linear trend model with no intercepts */
			/*****************************************************/
		    call mult(b2Xt, Wg, b2XtW);						/* multiply bXt and Wg */
		    call mult(b2XtW, b2X, b2XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb2XtWX, b2XtWX, sumb2XtWX);	/* cumulative matrix sum */
		    call mult(b2XtW, Zvec, b2zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb2zbeta,b2zbeta,sumb2zbeta);	/* cumulative matrix sum */

			/*******************************************************/
			/* common linear-linear trend model with no intercepts */
			/*******************************************************/
		    call mult(b1Xt, Wg, b1XtW);						/* multiply bXt and Wg */
		    call mult(b1XtW, b1X, b1XtWX);					/* calculate bXtWX */
		    call addmatrix(sumb1XtWX, b1XtWX, sumb1XtWX);	/* cumulative matrix sum */
		    call mult(b1XtW, Zvec, b1zbeta);			 	/* contributions to posterior mean from WLS */
		    call addmatrix(sumb1zbeta,b1zbeta,sumb1zbeta);	/* cumulative matrix sum */

		end;												/* end cycle through groups */

		/*****************************************************/
		/* common cubic-cubic trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b6Dbetag, sumb6XtWX, b6DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b6prbeta, sumb6zbeta, b6pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b6pbeta, b6tpbeta);					/* transpose */
		call inv(b6DXtWX, b6CI);							/* inverse of posterior precision matrix  */
		call mult(b6CI, b6pbeta, b6pbeta);					/* re-scale pbeta */
		call mult(b6tpbeta, b6pbeta, b6exp);				/* exponent from normal pdf */
		pwts[7] = pwts[7] + 0.5*b6exp[1,1];					/* log scale */
		call det(b6DXtWX, b6wts);
		pwts[7] = pwts[7] - 0.5*log(b6wts); 				/* determinant for normalizing constant */

		/****************************************************/
		/* common cubic-quad trend model with no intercepts */
		/****************************************************/
		call addmatrix(b5Dbetag, sumb5XtWX, b5DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b5prbeta, sumb5zbeta, b5pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b5pbeta, b5tpbeta);					/* transpose */
		call inv(b5DXtWX, b5CI);							/* inverse of posterior precision matrix  */
		call mult(b5CI, b5pbeta, b5pbeta);					/* re-scale pbeta */
		call mult(b5tpbeta, b5pbeta, b5exp);				/* exponent from normal pdf */
		pwts[8] = pwts[8] + 0.5*b5exp[1,1];					/* log scale */
		call det(b5DXtWX, b5wts);
		pwts[8] = pwts[8] - 0.5*log(b5wts); 				/* determinant for normalizing constant */

		/******************************************************/
		/* common cubic-linear trend model with no intercepts */
		/******************************************************/
		call addmatrix(b4Dbetag, sumb4XtWX, b4DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b4prbeta, sumb4zbeta, b4pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b4pbeta, b4tpbeta);					/* transpose */
		call inv(b4DXtWX, b4CI);							/* inverse of posterior precision matrix  */
		call mult(b4CI, b4pbeta, b4pbeta);					/* re-scale pbeta */
		call mult(b4tpbeta, b4pbeta, b4exp);				/* exponent from normal pdf */
		pwts[9] = pwts[9] + 0.5*b4exp[1,1];					/* log scale */
		call det(b4DXtWX, b4wts);
		pwts[9] = pwts[9] - 0.5*log(b4wts); 				/* determinant for normalizing constant */

		/***************************************************/
		/* common quad-quad trend model with no intercepts */
		/***************************************************/
		call addmatrix(b3Dbetag, sumb3XtWX, b3DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b3prbeta, sumb3zbeta, b3pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b3pbeta, b3tpbeta);					/* transpose */
		call inv(b3DXtWX, b3CI);							/* inverse of posterior precision matrix  */
		call mult(b3CI, b3pbeta, b3pbeta);					/* re-scale pbeta */
		call mult(b3tpbeta, b3pbeta, b3exp);				/* exponent from normal pdf */
		pwts[10] = pwts[10] + 0.5*b3exp[1,1];				/* log scale */
		call det(b3DXtWX, b3wts);
		pwts[10] = pwts[10] - 0.5*log(b3wts); 				/* determinant for normalizing constant */

		/*****************************************************/
		/* common quad-linear trend model with no intercepts */
		/*****************************************************/
		call addmatrix(b2Dbetag, sumb2XtWX, b2DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b2prbeta, sumb2zbeta, b2pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b2pbeta, b2tpbeta);					/* transpose */
		call inv(b2DXtWX, b2CI);							/* inverse of posterior precision matrix  */
		call mult(b2CI, b2pbeta, b2pbeta);					/* re-scale pbeta */
		call mult(b2tpbeta, b2pbeta, b2exp);				/* exponent from normal pdf */
		pwts[11] = pwts[11] + 0.5*b2exp[1,1];				/* log scale */
		call det(b2DXtWX, b2wts);
		pwts[11] = pwts[11] - 0.5*log(b2wts); 				/* determinant for normalizing constant */

		/*******************************************************/
		/* common linear-linear trend model with no intercepts */
		/*******************************************************/
		call addmatrix(b1Dbetag, sumb1XtWX, b1DXtWX); 		/* posterior precision matrix for common beta is bDbetag + sumbXtWX */
		call addmatrix(b1prbeta, sumb1zbeta, b1pbeta);		/* sum of prior and the cumulative WLS contributions */
		call transpose(b1pbeta, b1tpbeta);					/* transpose */
		call inv(b1DXtWX, b1CI);							/* inverse of posterior precision matrix  */
		call mult(b1CI, b1pbeta, b1pbeta);					/* re-scale pbeta */
		call mult(b1tpbeta, b1pbeta, b1exp);				/* exponent from normal pdf */
		pwts[12] = pwts[12] + 0.5*b1exp[1,1];				/* log scale */
		call det(b1DXtWX, b1wts);
		pwts[12] = pwts[12] - 0.5*log(b1wts); 				/* determinant for normalizing constant */

		/************************************/
		/* Posterior model weights and draw */
		/************************************/
		do m = 1 to &fp;									/* calculate using differences on log-scale (Bayes factors) for numerical stability */
			qwtsum = 0;
			do l = 1 to &fp;
				qwtsum = qwtsum + wts[l]*exp(pwts[l]-pwts[m]);
			end;
			qwts[m] = wts[m]/qwtsum;
		end;
		qwtsum = .;											/* check for any missing values */
		do m = 1 to &fp;
			if qwts[m] = . then qwtsum = 0;					/* set qwtsum to zero if any missings */
		end;
		if qwtsum = 0 then do;								/* replace missing values with zeroes and cumulate sum (if applicable) */
			do m = 1 to &fp;
				if qwts[m] = . then qwts[m] = 0;
				qwtsum = qwtsum + qwts[m];
			end;
		end;
		if qwtsum > 0 then do;								/* rescale to sum to 1 (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = qwts[m]/qwtsum;
			end;
		end;
		if qwtsum = 0 then do;								/* in case all weights are zero, use prior weights (if applicable) */
			do m = 1 to &fp;						
				qwts[m] = wts[m];
			end;
		end;
															/* fp = 13 here */
		iflg = rand('table',qwts[1],qwts[2],qwts[3],qwts[4],qwts[5],qwts[6],qwts[7],qwts[8],qwts[9],qwts[10],qwts[11],qwts[12],qwts[13]);

		if iflg = 1 then flg = 11;							/* eMKF v2.4: re-label flg per nomenclature */
		else do;
			if iflg = 2 then flg = 12;
			else do;
				if iflg = 3 then flg = 13;
				else do;
					if iflg = 4 then flg = 22;
					else do;
						if iflg = 5 then flg = 23;
						else do;
							if iflg = 6 then flg = 33;
							else do;
								if iflg = 7 then flg = 44;
								else do;
									if iflg = 8 then flg = 45;
									else do;
										if iflg = 9 then flg = 46;
										else do;
											if iflg = 10 then flg = 55;
											else do;
												if iflg = 11 then flg = 56;
												else do;
													if iflg = 12 then flg = 66;
													else do;
														if iflg = 13 then flg = 77;
													end;
												end;
											end;
										end;
									end;
								end;
							end;
						end;
					end;
				end;
			end;
		end;

		s1flg = intz(flg/10);
		s2flg = modz(flg, 10);

		endsub;
	run;
	quit;

%end;

%mend gibbs_uds_compile_FP_xptf;

data _null_;
run;

/*********************************************************************************************************/
/* eMKF v2.4: Implementation of algorithms by Robert (1995) for efficient sampling from truncated normal */
/* Code is based on rtnorm in R package msm. Default values are same as for INF and SINGDEN in proc mcmc */
/* See also PROC MCMC help files, example 19, for a similar implementation in the left-truncated case    */
/*********************************************************************************************************/
%macro gibbs_uds_compile_TNORM(loc=, infty=%sysevalf(1e15), zero=%sysevalf(1e-11), method=reject);

%local uloc meth;
%let uloc = &loc..uds;
%let meth = 1;
%if %upcase(&method) ^= REJECT %then %let meth = 0;
 
proc fcmp outlib=&uloc; 			

	/**********************************************/
	/* Generate interval-truncated normal variate */
	/**********************************************/
	function rtnorm(mu, sig, lower, upper);
	sdzero = 0; sdna = 0;
	if sig < &zero then sdzero = 1; 
    if sdzero = 1 and ((mu ^= . and mu < lower and lower ^= . and lower ^= .M) or (mu ^= . and mu > upper and upper ^= . and upper ^= .I)) then sdna = 1;
	if lower ^= .M and lower ^= .I and lower ^= . then lwr = (lower-mu)/sig;
	else do;
		if lower = .M then lwr = .M;
		if lower = .I or lower = . then lwr = .;
	end;
	if upper ^= .I and upper ^= .M and upper ^= . then upr = (upper-mu)/sig;
	else do;
		if upper = .I then upr = .I;
		if upper = .M or upper = . then upr = .;
	end;
	if lwr ^= . and lwr > &infty then lwr = .;
	if lwr ^= . and lwr ^= .M and -lwr > &infty then lwr = .M;
	if upr ^= . and -upr > &infty then upr = .;
	if upr ^= . and upr ^= .I and upr > &infty then upr = .I;
	if mu = . or sig = . or lwr = . or upr = . or sdna = 1 or (lwr ^= .M and upr ^= .I and upr < lwr) then z = .;
	else do;
		if sdzero = 1 or upr = lwr then z = 0;
		else do; 
			if &meth = 1 then do; /* Accept-reject algorithms of Robert (1995) */
			    if (lwr = .M and upr = .I) or (lwr < 0 and lwr ^= .M and upr = .I) or (lwr = .M and upr > 0 and upr ^= .I) or 
						(lwr < 0 and lwr ^= .M and upr > 0 and upr ^= .I and upr > lwr + sqrt(2*constant("pi"))) then do;
					accept=0;
					do while(accept=0);
						z = rand('normal');
						if (lwr = .M or z ge lwr) and (upr = .I or z le upr) then accept=1;
					end;
				end;
				else do;
					if lwr ge 0 and (upr = .I or upr > lwr + 2*sqrt(exp(1))/(lwr+sqrt(lwr**2+4))*exp((lwr*2-lwr*sqrt(lwr**2+4))/4)) then do;
						alpha = (lwr + sqrt(lwr**2 + 4))/2;
						accept=0;
						do while(accept=0);
							z = lwr + rand('exponential')/alpha;
							lrho = -(z-alpha)**2/2;
							u = rand('uniform');
							lu = log(u);
							if (lu le lrho) and (upr = .I or z le upr) then accept=1;
						end;
					end;
					else do;
						if upr le 0 and (lwr = .M or -lwr > -upr + 2*sqrt(exp(1))/(-upr+sqrt(upr**2+4))*exp((upr*2+upr*sqrt(upr**2+4))/4)) then do;
							alpha = (-upr + sqrt(upr**2 + 4))/2;
							accept=0;
							do while(accept=0);
								z = -upr + rand('exponential')/alpha;
								lrho = -(z-alpha)**2/2;
								u = rand('uniform');
								lu = log(u);
								if (lu le lrho) and (lwr = .M or z le -lwr) then accept=1;
							end;
							z = -z;
						end;
						else do;
							accept=0;
							do while(accept=0);
								z = lwr + (upr-lwr)*rand('uniform');
								if (lwr > 0) then lrho = (lwr**2 - z**2)/2;
								else if (upr < 0) then lrho = (upr**2 - z**2)/2;
								else lrho = (- z**2)/2;
								u = rand('uniform');
								lu = log(u);
								if (lu le lrho) then accept=1;
							end;
						end;
					end;
				end;
			end;
			else do; /* inverse transformation method */
				if lwr ^= .M then Fa = cdf('normal', lwr); else Fa = 0;
				if upr ^= .I then Fb = cdf('normal', upr); else Fb = 1;
				z = quantile('normal', Fa+(Fb-Fa)*rand('uniform'));
			end;
		end;
	end;
	ans = sig*z + mu;
	return(ans);
	endfunc;

run;
quit;

%mend gibbs_uds_compile_TNORM;

data _null_;
run;

/*******************/
/* eMKF references */
/*******************/
/*
 * Talih M, Patel P, Rossen LM. An R-NIMBLE implementation of the enhanced modified Kalman filter (eMKF) tool for small domain 
 * estimation (version 2.4 2026-01-30). National Center for Health Statistics. 2026. https://github.com/CDCgov/eMKF.
 *
 * Talih M, Patel P, Rossen LM. The enhanced modified Kalman filter (eMKF) tool for small domain estimation 
 * (version 2.4 2026-01-30). National Center for Health Statistics. 2026. https://github.com/CDCgov/eMKF. 
 * 
 * Talih M, Rossen LM, Patel P, Earp M, Parker JD. The enhanced modified Kalman filter (eMKF) tool for small domain estimation 
 * (version 1.4 2024-08-10). National Center for Health Statistics. 2024. https://github.com/CDCgov/eMKF.
 * 
 * Talih M, Rossen L, Patel P, Earp M, Parker J. Technical guidance for using the modified Kalman filter in small domain  
 * estimation at the National Center for Health Statistics. Vital Health Stat 2(209). 2024. DOI: 10.15620/cdc/157496.
 * 
 * Rossen L, Talih M, Patel P, Earp M, Parker J. Evaluation of a modified Kalman filter approach for estimating health outcomes 
 * in small subpopulations. Vital Health Stat 2(208). 2024. DOI: 10.15620/cdc/157497.
 *
 */
